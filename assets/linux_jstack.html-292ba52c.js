import{_ as e,X as t,Y as p,a0 as c,a1 as i,Z as a,$ as s,a5 as l,E as o}from"./framework-608b3dd6.js";const d="/assets/images/linux-jstack01.jpeg",r="/assets/images/linux-jstack02.jpeg",u={},m=a("h1",{id:"内存溢出处理",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#内存溢出处理","aria-hidden":"true"},"#"),s(" 内存溢出处理")],-1),k=a("p",null,"由于服务器突然间报警内存占用过高，只好先查看服务器上是哪个服务占用内存过高，一点一点慢慢来",-1),v=l(`<h3 id="_1-查看内存占用情况定位线程" tabindex="-1"><a class="header-anchor" href="#_1-查看内存占用情况定位线程" aria-hidden="true">#</a> 1. 查看内存占用情况定位线程</h3><hr><p>使用top命令进行查看，由于要查看内存使用情况所以需要按内存排一下序</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#按进程的CPU使用率排序</span>
运行top命令后，键入大写P

<span class="token comment">#按进程的内存使用率排序</span>
运行top命令后，键入大写M
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+d+`" alt="top M" tabindex="0" loading="lazy"><figcaption>top M</figcaption></figure><h3 id="_2-定位线程问题-通过命令查看线程情况" tabindex="-1"><a class="header-anchor" href="#_2-定位线程问题-通过命令查看线程情况" aria-hidden="true">#</a> 2. 定位线程问题（通过命令查看线程情况）</h3><hr><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ps</span> p <span class="token number">10483</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-o</span> pcpu,pmem,pid,tid,time,tname,cmd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从这个可以看到线程情况，当时情况紧急没有截图，所以我下面的图是同一个服务写文档时运行的</p><figure><img src="`+r+`" alt="ps p 10483" tabindex="0" loading="lazy"><figcaption>ps p 10483</figcaption></figure><p>具体可以执行下面操作看有多少个线程</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token function">ps</span> p <span class="token number">24013</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-o</span> pcpu,pmem,pid,tid,time,tname,cmd <span class="token operator">|</span><span class="token function">wc</span> <span class="token parameter variable">-l</span>

 <span class="token number">100</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-查看内存使用堆栈" tabindex="-1"><a class="header-anchor" href="#_3-查看内存使用堆栈" aria-hidden="true">#</a> 3. 查看内存使用堆栈</h3><hr><p>在这里我挑选了TID=24014的线程进行分析(选择一个执行时间较长的)，首先需要将24014这个id转换为16进制。需输入如下命令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token builtin class-name">printf</span> <span class="token string">&quot;%x<span class="token entity" title="\\n">\\n</span>&quot;</span> <span class="token number">24014</span>

 5dce
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-将pid为-24013-的堆栈信息打印到jstack-log中" tabindex="-1"><a class="header-anchor" href="#_4-将pid为-24013-的堆栈信息打印到jstack-log中" aria-hidden="true">#</a> 4. 将PID为 24013 的堆栈信息打印到jstack.log中</h3><hr><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#输出目录自定</span>
jstack <span class="token parameter variable">-l</span> <span class="token number">24013</span> <span class="token operator">&gt;</span> /usr/local/temp/jstack.log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>查看具体信息后，发现程序中并没有自己写的代码有死锁或者是等待的东西，那就应该是默认配置相关了，其中有两个比较多<code>http-nio-xxxx-exec-xx</code>和<code>lettuce-eventExecutorLoop-1-x</code></p><p><code>http-nio-4001-exec-30</code>是Tomcat的工作线程名称。在Tomcat中，每个工作线程都被分配一个独特的名称，以便在调试和性能分析时能够轻松地跟踪线程的执行情况。</p><p><code>http-nio-4001-exec-30</code> 中的 <code>4001</code> 表示Tomcat监听的端口号， <code>exec</code> 表示该线程是Tomcat的工作线程， <code>30</code> 表示该线程的标识符。</p><p>如果在jstack输出中看到大量类似 <code>http-nio-xxxx-exec-xx</code> 的线程，这可能意味着应用程序正在处理大量的并发请求。每个请求都需要一个工作线程来处理，并且这些工作线程都需要占用一定的内存和CPU资源。如果应用程序的并发请求量过高，可能会导致系统资源瓶颈，进而影响应用程序的性能和稳定性。</p><p>如果应用程序需要处理大量的并发请求，建议根据实际情况来配置Tomcat的线程池参数，以确保应用程序的性能和稳定性。</p><p>这边使用的是springboot2.3X以上的版本，配置内置的tomcat参数与之前的有些不一样</p><p>在application.yml中进行配置，例如：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">tomcat</span><span class="token punctuation">:</span>
    <span class="token key atrule">threads</span><span class="token punctuation">:</span>
      <span class="token key atrule">max</span><span class="token punctuation">:</span> 500 //线程池的最大线程数。默认值200
      <span class="token key atrule">min-spare</span><span class="token punctuation">:</span> 50 //线程池中最少的空闲线程数。默认值10
      <span class="token key atrule">idle-timeout</span><span class="token punctuation">:</span> 60000 //指定在空闲线程被回收之前等待的最大毫秒数。默认值60s
    <span class="token key atrule">accept-count</span><span class="token punctuation">:</span> 200 //指定在队列中等待处理的最大连接数。默认值100
    <span class="token key atrule">max-connections</span><span class="token punctuation">:</span> 20000 //最大连接数。默认值10000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>lettuce-eventExecutorLoop-1-x</code> 是Lettuce Redis客户端的线程名称，其中的 <code>x</code> 表示线程标识符。Lettuce使用Netty作为底层网络通信框架，每个Netty EventLoop都会创建一个Lettuce线程，并分配一个独特的线程名称，以便在调试和性能分析时能够轻松地跟踪线程的执行情况。</p><p>在Lettuce Redis客户端中，每个Redis命令都是异步执行的，即客户端会在发送请求之后立即返回，并通过回调函数或者Future等方式获取结果。Lettuce使用EventLoop线程来处理I/O事件、连接管理和Redis命令执行等任务，以提高客户端的性能和吞吐量。</p><p>如果在jstack输出中看到大量类似 <code>lettuce-eventExecutorLoop-1-x</code> 的线程，这可能意味着应用程序正在与Redis进行大量的交互，并且使用了Lettuce客户端。每个Lettuce线程都需要占用一定的内存和CPU资源，如果线程数量过多，可能会导致系统资源瓶颈，进而影响应用程序的性能和稳定性。</p><p>如果应用程序需要与Redis进行大量的交互，建议根据实际情况来配置Lettuce的线程池参数，以确保应用程序的性能和稳定性。</p><p>在application.yml中进行配置，例如：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost  <span class="token comment"># Redis服务器地址，默认为localhost</span>
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>       <span class="token comment"># Redis服务器端口，默认为6379</span>
    <span class="token key atrule">password</span><span class="token punctuation">:</span>        <span class="token comment"># Redis密码，默认为空</span>
    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token comment"># Redis数据库索引（0-15），默认为0</span>
    <span class="token key atrule">timeout</span><span class="token punctuation">:</span> <span class="token number">1000</span>    <span class="token comment"># 连接超时时间（毫秒），默认为1000</span>
    <span class="token key atrule">jedis</span><span class="token punctuation">:</span>
      <span class="token key atrule">pool</span><span class="token punctuation">:</span>
        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span>       <span class="token comment"># 连接池最大连接数，默认为8</span>
        <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>         <span class="token comment"># 连接池最大空闲连接数，默认为8</span>
        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span>         <span class="token comment"># 连接池最小空闲连接数，默认为0</span>
        <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> <span class="token number">-1</span>        <span class="token comment"># 连接池最大等待时间（毫秒），默认为-1（表示无限等待）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改了配置文件在观察吧，我在导出jstack的时候运维已经重启了服务，我不清楚这个是不是当时有问题的原因，但是从后来分析的情况来看，确实存在一定的问题...</p><p>后续会跟进...</p><p>后续跟进 : 我在执行<code>ps p 10483 -L -o pcpu,pmem,pid,tid,time,tname,cmd</code>命令式发现有个线程时间2分钟还没结束，去jstack查看了一下，是 System Clock</p><p>这个线程是一个系统线程，是JVM中专门负责管理系统时钟的线程，它会定期更新JVM中的系统时间，以及JVM中的一些相关参数，如 java.util.Date 和 System.currentTimeMillis()等方法的返回值。该线程的状态为 TIMED_WAITING ，意味着它是在等待时钟时间的到来，并在等待的过程中处于定时等待状态。这种状态在Java应用程序中非常常见，并且通常是正常的行为，不应该引起太多的注意。但是2分钟还没执行完就多少有点时间长，查看了一下代码，发现使用了 SimpleDateFormat</p><p>SimpleDateFormat 并不是线程安全的，如果多个线程同时使用同一个 SimpleDateFormat 对象进行日期格式化，就有可能出现线程安全问题，在程序中我也看到不知怎么的这一块是写在属性当中，所有方法共用，这一块应该存在问题，优化到方法内部或者如果确定要只定义一个的话：</p><p>如果多个线程同时读取同一个SimpleDateFormat对象的话，会出现线程安全问题，因为SimpleDateFormat不是线程安全的。所以如果多个线程同时读取时可能会出现线程阻塞的情况。为了避免这种情况，可以考虑使用ThreadLocal来保证每个线程有自己的SimpleDateFormat对象。这样就可以避免多个线程之间的竞争，提高程序的性能和稳定性。</p>`,39);function b(h,x){const n=o("font");return t(),p("div",null,[m,c(n,{color:"red",size:"3"},{default:i(()=>[s(" 紧急‼️：今天线上项目突然间内存占用激增，下面记录一下自己查看分析问题的流程 "),k]),_:1}),v])}const y=e(u,[["render",b],["__file","linux_jstack.html.vue"]]);export{y as default};
