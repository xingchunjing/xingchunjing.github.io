const e=JSON.parse('{"key":"v-58459d5a","path":"/knowledge/redis-cache.html","title":"redis缓存","lang":"zh-CN","frontmatter":{"icon":"cache","date":"2020-11-26T00:00:00.000Z","category":["java","后端"],"tag":["java","后端","redis"],"star":true,"description":"redis缓存 一. 扩容与缩容 当哈希表中元素数量逐渐增加时，此时产生 hash 冲突的概率逐渐增大，且由于dict(哈希桶)也是采用拉链法解决 hash 冲突的，随着hash冲突概率上升，链表会越来越长，单个哈希桶链表上数据越来越多，查找时间复杂度退化到 O(n)，这就会导致查找效率下降。相反，当元素不断减少时，元素占用 dict 的空间就越少，出现对于内存的极致利用，此时就需要进行缩容操作。 负载因子。负载因子一般用于描述集合当前被填充的程度。在 Redis 的字典 dict 中， 负载因子 负载因子 = 哈希表中已保存节点数量 / 哈希表的大小，即： load factor = ht[0].used / ht[0].size","head":[["meta",{"property":"og:url","content":"https://gitee.com/jing-xingchun/knowledge/redis-cache.html"}],["meta",{"property":"og:site_name","content":"Jingxc"}],["meta",{"property":"og:title","content":"redis缓存"}],["meta",{"property":"og:description","content":"redis缓存 一. 扩容与缩容 当哈希表中元素数量逐渐增加时，此时产生 hash 冲突的概率逐渐增大，且由于dict(哈希桶)也是采用拉链法解决 hash 冲突的，随着hash冲突概率上升，链表会越来越长，单个哈希桶链表上数据越来越多，查找时间复杂度退化到 O(n)，这就会导致查找效率下降。相反，当元素不断减少时，元素占用 dict 的空间就越少，出现对于内存的极致利用，此时就需要进行缩容操作。 负载因子。负载因子一般用于描述集合当前被填充的程度。在 Redis 的字典 dict 中， 负载因子 负载因子 = 哈希表中已保存节点数量 / 哈希表的大小，即： load factor = ht[0].used / ht[0].size"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-06T09:51:40.000Z"}],["meta",{"property":"article:author","content":"Jingxc"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"后端"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2020-11-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-06T09:51:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redis缓存\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-11-26T00:00:00.000Z\\",\\"dateModified\\":\\"2023-05-06T09:51:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jingxc\\",\\"url\\":\\"/\\"}]}"]]},"headers":[{"level":2,"title":"一. 扩容与缩容","slug":"一-扩容与缩容","link":"#一-扩容与缩容","children":[]},{"level":2,"title":"二. rehash","slug":"二-rehash","link":"#二-rehash","children":[]},{"level":2,"title":"三. 主从复制","slug":"三-主从复制","link":"#三-主从复制","children":[{"level":3,"title":"3.1 优点","slug":"_3-1-优点","link":"#_3-1-优点","children":[]},{"level":3,"title":"3.2 一致性","slug":"_3-2-一致性","link":"#_3-2-一致性","children":[]},{"level":3,"title":"3.3 复制","slug":"_3-3-复制","link":"#_3-3-复制","children":[]}]},{"level":2,"title":"四. 哨兵模式","slug":"四-哨兵模式","link":"#四-哨兵模式","children":[{"level":3,"title":"4.1 作用","slug":"_4-1-作用","link":"#_4-1-作用","children":[]}]},{"level":2,"title":"五. 集群","slug":"五-集群","link":"#五-集群","children":[{"level":3,"title":"5.1 哈希槽算法","slug":"_5-1-哈希槽算法","link":"#_5-1-哈希槽算法","children":[]}]},{"level":2,"title":"六. 持久化","slug":"六-持久化","link":"#六-持久化","children":[{"level":3,"title":"6.1 redis持久化RDB","slug":"_6-1-redis持久化rdb","link":"#_6-1-redis持久化rdb","children":[]},{"level":3,"title":"6.2 redis持久化AOF","slug":"_6-2-redis持久化aof","link":"#_6-2-redis持久化aof","children":[]},{"level":3,"title":"6.3 redis持久化AOF重写","slug":"_6-3-redis持久化aof重写","link":"#_6-3-redis持久化aof重写","children":[]},{"level":3,"title":"6.4 如何选择RDB和AOF","slug":"_6-4-如何选择rdb和aof","link":"#_6-4-如何选择rdb和aof","children":[]},{"level":3,"title":"6.5 缺点","slug":"_6-5-缺点","link":"#_6-5-缺点","children":[]}]}],"git":{"createdTime":1683357718000,"updatedTime":1683366700000,"contributors":[{"name":"Jingxc","email":"2584982513@qq.com","commits":2}]},"readingTime":{"minutes":16.4,"words":4919},"filePathRelative":"knowledge/redis-cache.md","localizedDate":"2020年11月26日","excerpt":"<h1> redis缓存</h1>\\n<h2> 一. 扩容与缩容</h2>\\n<p>当哈希表中元素数量逐渐增加时，此时产生 hash 冲突的概率逐渐增大，且由于dict(哈希桶)也是采用拉链法解决 hash 冲突的，随着hash冲突概率上升，链表会越来越长，单个哈希桶链表上数据越来越多，查找时间复杂度退化到 O(n)，这就会导致查找效率下降。相反，当元素不断减少时，元素占用 dict 的空间就越少，出现对于内存的极致利用，此时就需要进行缩容操作。</p>\\n<p>负载因子。负载因子一般用于描述集合当前被填充的程度。在 Redis 的字典 dict 中，</p>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">负载因子</p>\\n<p>负载因子 = 哈希表中已保存节点数量 / 哈希表的大小，即：</p>\\n<p>load factor = ht[0].used / ht[0].size</p>\\n</div>","autoDesc":true}');export{e as data};
