import{_ as p}from"./JVM-6d87e914.js";import{_ as o}from"./Garbage-Collectors-d8b724ae.js";import{_ as l,X as i,Y as c,Z as u,$ as n,a0 as t,a1 as e,a2 as s,E as r}from"./framework-f01f539c.js";const d={},k=s(`<h1 id="_2023面试题" tabindex="-1"><a class="header-anchor" href="#_2023面试题" aria-hidden="true">#</a> 2023面试题</h1><h2 id="_1-java-oop" tabindex="-1"><a class="header-anchor" href="#_1-java-oop" aria-hidden="true">#</a> 1. JAVA OOP</h2><h3 id="_1-1-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" tabindex="-1"><a class="header-anchor" href="#_1-1-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" aria-hidden="true">#</a> 1.1 short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1; 有错吗？</h3><hr><div class="hint-container tip"><p class="hint-container-title">提示</p><p>赋值表达式等号两侧的转换的规则是右侧的向左侧的看齐，即右侧表达式要转换到和左边的类型一样。</p></div><p>short s1 = 1; s1 = s1 + 1;错！ s1 + 1，s1是short类型，1是int型，s1会自动转换为int型的1，与1相加后，得到int型的2，要向左侧的short类型的s1看齐，即需要通过强制类型转换。正确写法：s1 = (short) (s1 + 1);</p><p>short s1 = 1; s1 += 1;正确！ 执行s1+=1;其实执行的是s1 = (short) (s1 + 1); 其中会有一个强制转换的过程。</p><p>正确的写法是：short s1=1;s1=(short)(s1+1); 或者 short s1=1;s1+=1;</p><h3 id="_1-2-重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#_1-2-重载和重写的区别" aria-hidden="true">#</a> 1.2 重载和重写的区别</h3><hr><p>重载（Overloading）： 重载是指在同一个类中定义多个方法，它们具有相同的名称但参数列表不同（参数类型、参数个数或参数顺序不同）。重载方法通常用于提供不同的方法签名，以便根据不同的输入参数调用不同的方法。重载不涉及继承关系，而是在同一个类中进行定义。</p><p>重写（Overriding）： 重写是指在子类中重新定义父类中已有的方法，保持方法名称、参数列表以及返回类型完全相同。重写用于实现多态性，允许子类在保留父类方法签名的情况下，重新定义方法的具体实现。重写要求子类和父类之间存在继承关系。</p><p>总结：</p><p>重载用于在同一个类中根据参数的不同提供多个方法签名，方法名相同但参数不同。 重写用于子类中重新定义父类已有的方法，方法名、参数列表和返回类型必须完全一致。 重载和重写是面向对象编程的重要特性，它们共同为代码的灵活性和可维护性提供了支持。</p><p>数组是一种用于存储一组相同类型元素的数据结构。实例化数组意味着创建数组对象并分配内存空间，以便可以存储元素。以下是几种常见的数组实例化方式：</p><h3 id="_1-3-数组实例化有几种方式" tabindex="-1"><a class="header-anchor" href="#_1-3-数组实例化有几种方式" aria-hidden="true">#</a> 1.3 数组实例化有几种方式？</h3><hr><p><strong>静态初始化：</strong></p><p>在静态初始化中，您可以在声明数组变量的同时为数组分配内存空间并初始化元素。这种方式适用于您已经知道数组的元素值的情况。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Charlie&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>动态初始化：</strong></p><p>动态初始化是在声明数组变量后，通过使用 new 关键字为数组分配内存空间，并随后分配初始值给数组元素。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> scores <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 分配包含 5 个整数元素的数组</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cities <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 分配包含 3 个字符串元素的数组</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>多维数组初始化：</strong></p><p>多维数组可以在声明的同时进行静态初始化或动态初始化，实例化多维数组需要指定每个维度的大小。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 3x3 整数矩阵</span>
<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ticTacToe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 3x3 字符矩阵</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>匿名数组：</strong> 在某些情况下，您可以使用匿名数组进行一次性的操作，无需显式声明数组变量。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印并实例化匿名整数数组</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_1-4-java-中各种数据默认值" tabindex="-1"><a class="header-anchor" href="#_1-4-java-中各种数据默认值" aria-hidden="true">#</a> 1.4 Java 中各种数据默认值</h3><hr><p>在Java中，各种数据类型在被声明但尚未被初始化的情况下会被赋予默认值。以下是Java中各种数据类型的默认值：</p><p>数值类型（整数和浮点数）：</p><ul><li>byte: 0</li><li>short: 0</li><li>int: 0</li><li>long: 0L</li><li>float: 0.0f</li><li>double: 0.0</li></ul><p>字符类型：</p><ul><li>char: &#39;\\u0000&#39;，即Unicode中的空字符</li></ul><p>布尔类型：</p><ul><li>boolean: false</li></ul><p>引用类型（类、接口、数组）：</p><ul><li>对象引用类型（如类、接口）：null</li><li>数组引用类型：null</li></ul><p>需要注意的是，这些默认值是在变量被声明但尚未被显式初始化时所具有的初始值。当创建一个新的变量时，如果不为其赋值，它们将自动获得这些默认值。</p><p>例如，以下代码片段展示了各种数据类型的默认值：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultValuesExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span> b<span class="token punctuation">;</span>
    <span class="token keyword">short</span> s<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">long</span> l<span class="token punctuation">;</span>
    <span class="token keyword">float</span> f<span class="token punctuation">;</span>
    <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token keyword">char</span> c<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> bool<span class="token punctuation">;</span>
    <span class="token class-name">String</span> str<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">DefaultValuesExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultValuesExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;byte: &quot;</span> <span class="token operator">+</span> example<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;short: &quot;</span> <span class="token operator">+</span> example<span class="token punctuation">.</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;int: &quot;</span> <span class="token operator">+</span> example<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;long: &quot;</span> <span class="token operator">+</span> example<span class="token punctuation">.</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;float: &quot;</span> <span class="token operator">+</span> example<span class="token punctuation">.</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;double: &quot;</span> <span class="token operator">+</span> example<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;char: &quot;</span> <span class="token operator">+</span> example<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;boolean: &quot;</span> <span class="token operator">+</span> example<span class="token punctuation">.</span>bool<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;String: &quot;</span> <span class="token operator">+</span> example<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-5-object-类常用方法有那些" tabindex="-1"><a class="header-anchor" href="#_1-5-object-类常用方法有那些" aria-hidden="true">#</a> 1.5 Object 类常用方法有那些？</h3><hr><p>java.lang.Object 类是所有Java类的根类，它包含了一些常用的方法，这些方法可以被任何类继承和使用。以下是Object 类中一些常用的方法：</p><p><strong>equals(Object obj)：</strong> 用于比较两个对象是否相等。默认情况下，equals 方法比较的是对象的引用是否相同，但可以在子类中重写该方法以自定义对象相等的条件。</p><p><strong>hashCode()：</strong> 返回对象的哈希码值。哈希码通常用于在集合（如哈希表）中快速定位对象。对于相等的对象，它们的哈希码应该相同，但相同哈希码的对象不一定相等。</p><p><strong>toString()：</strong> 返回对象的字符串表示。默认情况下，toString 方法返回包含类名和哈希码的字符串。它通常会被重写以提供更有用的对象描述。</p><p><strong>getClass()：</strong> 返回对象的运行时类的引用，即对象所属的类。可以用于获取对象的类信息。</p><p><strong>finalize()：</strong> 在对象被垃圾回收之前，系统会调用该方法。通常情况下，不推荐使用该方法，而是使用AutoCloseable接口或者try-with-resources来确保资源的释放。</p><p><strong>notify()、notifyAll()、wait()：</strong> 用于支持线程之间的通信和协调。这些方法通常与wait()、notify()和notifyAll()结合使用，以实现多线程之间的同步。</p><p><strong>clone()：</strong> 创建并返回当前对象的浅拷贝（副本）。需要注意的是，为了正确实现对象的拷贝，被复制的对象需要实现Cloneable接口。</p><h3 id="_1-6-java-中是值传递引用传递" tabindex="-1"><a class="header-anchor" href="#_1-6-java-中是值传递引用传递" aria-hidden="true">#</a> 1.6 java 中是值传递引用传递？</h3><hr><p>Java 中是<strong>值传递（Pass-by-Value）</strong>。这意味着当你将一个参数传递给方法时，实际上传递的是参数的值（即引用的副本），而不是原始引用本身。这可能在处理基本数据类型和对象引用时产生不同的效果。</p><p>对于基本数据类型（如整数、浮点数等），传递的是实际的值，方法内对参数的修改不会影响调用处的变量：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Copy</span> code
<span class="token keyword">void</span> <span class="token function">modifyValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">modifyValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: 10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但对于对象引用，传递的是引用的副本，这意味着方法内的操作可能会影响调用处的对象，但不会改变原始引用指向的对象：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Copy</span> code
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    
    <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">modifyReference</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">;</span>
    person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Charlie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">modifyReference</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: Alice</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述例子中，虽然在方法内部修改了 person 对象的 name 属性，但在方法内部重新分配了一个新的 Person 对象，所以方法结束后，调用处的 person 仍然指向原来的对象。</p>`,60),v=s(`<h3 id="_1-7-形参与实参区别" tabindex="-1"><a class="header-anchor" href="#_1-7-形参与实参区别" aria-hidden="true">#</a> 1.7 形参与实参区别</h3><hr><p>在编程中，形参（Formal Parameter）和实参（Actual Argument）是两个重要的概念，用于描述方法或函数的参数传递过程。它们之间的区别如下：</p><p>形参（Formal Parameter）： 形参是在定义函数或方法时，用于表示该函数或方法接受的参数的名称。形参实际上是函数或方法的参数列表中的标识符，用于表示传递给函数或方法的数据。形参在函数或方法的定义中起到了占位符的作用，指定了函数需要接受的数据类型和个数。</p><p>例如，在以下方法中，x 和 y 就是形参：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实参（Actual Argument）： 实参是在调用函数或方法时，传递给函数或方法的具体数据值。实参是实际传递给函数或方法的数据，用于执行函数或方法的操作。实参的值将会被赋值给形参，在函数或方法的执行过程中被使用。</p><p>例如，在以下方法调用中，5 和 3 就是实参：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在方法调用时，实参的值会被传递给形参，这样函数或方法就可以使用这些值进行计算或其他操作。形参和实参的类型和数量应该匹配，以确保正确的参数传递和处理。</p>`,10),m=s(`<ul><li>形参是函数或方法定义中的参数名，用于指定需要传递给函数或方法的数据类型和个数。</li><li>实参是在调用函数或方法时传递给函数或方法的具体数据值，用于执行函数或方法的操作。</li></ul><h3 id="_1-8-构造方法能不能重写-能不能重载" tabindex="-1"><a class="header-anchor" href="#_1-8-构造方法能不能重写-能不能重载" aria-hidden="true">#</a> 1.8 构造方法能不能重写？能不能重载？</h3><hr><p>在Java中，构造方法是特殊的方法，用于在创建类的实例时初始化对象。构造方法在一些方面与普通方法有所不同，因此无法进行重写（Override），但可以进行重载（Overload）。</p><p>重写（Override）： 重写是指在子类中重新定义父类中已有的方法，保持方法名称、参数列表和返回类型完全相同。重写用于实现多态性，子类可以用自己的实现替换父类的方法。</p><p>由于构造方法在创建对象时由编译器自动调用，并且没有方法名，所以无法在子类中重写构造方法。子类可以使用父类的构造方法来初始化自己的成员变量，但不能像重写普通方法一样在子类中重新定义构造方法。</p><p>重载（Overload）： 重载是指在同一个类中定义多个方法，它们具有相同的名称但参数列表不同（参数类型、参数个数或参数顺序不同）。重载方法可以有不同的参数列表，包括不同的参数类型或不同的参数个数。</p><p>构造方法也可以进行重载。这允许在同一个类中定义多个不同参数列表的构造方法，以便于在创建对象时可以使用不同的初始化方式。</p><p>下面是一个构造方法重载的示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 默认构造方法</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，Person 类中定义了多个构造方法，每个构造方法都有不同的参数列表，从而实现了构造方法的重载。</p><p>总结：</p><ul><li>构造方法不能被重写，因为重写要求方法名和参数列表完全相同，而构造方法没有方法名。</li><li>构造方法可以进行重载，允许在同一个类中定义多个不同参数列表的构造方法。</li></ul><h3 id="_1-9-内部类与静态内部类的区别" tabindex="-1"><a class="header-anchor" href="#_1-9-内部类与静态内部类的区别" aria-hidden="true">#</a> 1.9 内部类与静态内部类的区别？</h3><hr><p>在Java中，内部类（Inner Class）是一个类定义在另一个类的内部的情况。内部类可以分为非静态内部类和静态内部类，它们之间有一些重要的区别。</p><p>非静态内部类（Inner Class）：</p><p>非静态内部类是定义在外部类实例中的类。它们与外部类的实例相关联，需要依赖外部类的实例存在。 非静态内部类可以访问外部类的成员（包括私有成员），因为它们共享外部类的实例。 非静态内部类不能包含静态成员，因为它们依赖于外部类的实例。 实例化非静态内部类时，需要通过外部类的实例来创建，例如：OuterClass.InnerClass inner = outer.new InnerClass(); 静态内部类（Static Inner Class）：</p><p>静态内部类是定义在外部类中但被声明为静态的类。它们不依赖于外部类的实例，可以在外部类实例不存在的情况下被实例化。 静态内部类不能直接访问外部类的非静态成员，但可以访问外部类的静态成员。 静态内部类可以包含静态成员，因为它们不依赖于外部类的实例。 实例化静态内部类时，不需要外部类的实例，例如：OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass(); 示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">OuterClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> outerField<span class="token punctuation">;</span>

    <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">{</span>
        <span class="token comment">// 非静态内部类</span>
        <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>outerField<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以访问外部类的成员</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerClass</span> <span class="token punctuation">{</span>
        <span class="token comment">// 静态内部类</span>
        <span class="token keyword">static</span> <span class="token keyword">int</span> staticInnerField<span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token function">staticInnerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticInnerField<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以访问外部类的静态成员</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：</p><ul><li>非静态内部类依赖于外部类的实例，可以访问外部类的成员。</li><li>静态内部类不依赖于外部类的实例，可以访问外部类的静态成员。</li></ul><h3 id="_1-10-static-关键字有什么作用" tabindex="-1"><a class="header-anchor" href="#_1-10-static-关键字有什么作用" aria-hidden="true">#</a> 1.10 Static 关键字有什么作用？</h3><hr><p>static 是Java中的一个关键字，用于声明静态成员和静态方法，它具有以下几个作用：</p><p><strong>静态变量（Static Variables）：</strong></p><p>使用 static 关键字声明的变量被称为静态变量或类变量。静态变量属于类，而不是类的实例。它们在类加载时被初始化，不需要实例化类就可以访问。所有类的实例都共享相同的静态变量副本。</p><p><strong>静态方法（Static Methods）：</strong></p><p>使用 static 关键字声明的方法被称为静态方法。静态方法属于类，而不是类的实例。它们可以通过类名直接调用，不需要通过类的实例来调用。静态方法内部不能访问实例变量，因为它们没有与特定实例关联。</p><p><strong>静态块（Static Blocks）：</strong></p><p>静态块是用 static 关键字定义的代码块，在类加载时执行。它可以用于在类加载时初始化静态变量或执行其他需要在类加载时完成的操作。</p><p><strong>静态内部类（Static Inner Classes）：</strong></p><p>静态内部类是嵌套在另一个类内部的类，使用 static 关键字声明。它不依赖于外部类的实例，可以通过外部类的类名直接访问。</p><p><strong>静态导入（Static Import）：</strong></p><p>使用 import static 关键字，可以直接导入一个类的静态成员，从而在代码中不需要使用类名前缀来访问这些静态成员。</p><p>static 关键字的作用在于创建与类关联而不是与类的实例关联的成员和方法，使其可以在没有实例的情况下访问和调用。但是，需要谨慎使用静态成员，因为它们在内存中只有一份副本，并且容易引起线程安全和内存管理问题。</p><h3 id="_1-11-final-在-java-中的作用-有哪些用法" tabindex="-1"><a class="header-anchor" href="#_1-11-final-在-java-中的作用-有哪些用法" aria-hidden="true">#</a> 1.11 final 在 java 中的作用，有哪些用法?</h3><hr><p>在Java中，final 是一个关键字，用于表示不可变性、不可继承性以及具有特定含义的修饰符。它具有以下几种主要的用法和作用：</p><p>不可变性（Immutable）：</p><p>用于修饰变量：使用 final 修饰的变量称为常量，一旦初始化后就无法再改变它们的值。常量通常用大写字母命名，例如：final int MAX_VALUE = 100;。 用于修饰方法参数：如果在方法参数列表中使用 final 修饰参数，意味着在方法内部不能修改参数的值。 不可继承性（Preventing Inheritance）：</p><p>用于修饰类：使用 final 修饰的类不能被其他类继承。这在某些情况下用于防止派生类对原始类的修改和扩展。 方法重写（Method Overriding）：</p><p>用于修饰方法：使用 final 修饰的方法不能被子类重写（Override）。这可以用于确保在子类中不会修改父类的方法行为。 内部类引用（Inner Class Reference）：</p><p>用于修饰内部类引用：在匿名内部类中，如果要引用外部方法的局部变量，该变量必须被声明为 final。这是因为匿名内部类会持有对这些变量的引用，而 final 保证了变量的值在匿名内部类中不会被修改。 示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> constantValue <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">finalMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> localVar <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 不可变的局部变量</span>
        <span class="token comment">// localVar = 10; // 编译错误，不能修改 final 变量</span>
        
        <span class="token keyword">final</span> <span class="token class-name">FinalExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// example = new FinalExample(); // 编译错误，不能修改 final 引用</span>
        
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>localVar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以访问 final 变量</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：</p><ul><li>final 关键字在Java中用于表示不可变性、不可继承性以及限制方法重写等。</li><li>final 可以用于修饰变量、方法、类以及内部类引用。</li></ul><h3 id="_1-12-string-str-aaa-与-string-str-new-string-aaa-一样吗" tabindex="-1"><a class="header-anchor" href="#_1-12-string-str-aaa-与-string-str-new-string-aaa-一样吗" aria-hidden="true">#</a> 1.12 String str=”aaa”,与 String str=new String(“aaa”)一样吗？</h3><hr><p>在大多数情况下，String str = &quot;aaa&quot; 和 String str = new String(&quot;aaa&quot;) 并不完全相同。虽然它们都可以用来创建一个字符串对象，但它们有一些关键的区别。</p><p>字符串字面值方式（String str = &quot;aaa&quot;）： 当使用字符串字面值创建字符串对象时，如果字符串常量池中已经存在相同内容的字符串，就会直接引用已存在的字符串对象，而不会创建新的对象。这是由于字符串常量池的特性，它是存储字符串字面值的一个池子。 如果字符串常量池中不存在相同内容的字符串，那么会在池中创建一个新的字符串对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">&quot;aaa&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个指向 &quot;aaa&quot; 的字符串对象</span>
<span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">&quot;aaa&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 直接引用已存在的字符串对象</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 new 关键字创建对象方式（String str = new String(&quot;aaa&quot;)）： 使用 new 关键字创建字符串对象时，无论字符串常量池中是否存在相同内容的字符串，都会在堆内存中创建一个新的字符串对象。 这种方式会始终创建一个新的对象，即使在字符串常量池中已经存在相同的内容。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在堆内存中创建一个新的字符串对象</span>
<span class="token class-name">String</span> str4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在堆内存中创建另一个新的字符串对象</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：</p><ul><li>使用字符串字面值方式创建字符串时，会尝试在字符串常量池中查找或创建字符串对象。</li><li>使用 new 关键字创建字符串对象时，会在堆内存中创建一个新的字符串对象，而不论字符串常量池中是否存在相同内容的字符串。</li><li>使用String a = “aaa” ，程序运行时会在常量池中查找”aaa”字符串，若没有，会将”aaa”字符串放进常量池，再将其地址赋给a；若有，将找到的”aaa”字符串的地址赋给a。</li><li>使用String b = new String(&quot;aaa&quot;)，程序会在堆内存中开辟一片新空间存放新对象，同时会将”aaa”字符串放入常量池，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会 在堆内存中开辟一片新空间存放新对象。</li></ul><h3 id="_1-13-讲下-java-中的-math-类有那些常用方法" tabindex="-1"><a class="header-anchor" href="#_1-13-讲下-java-中的-math-类有那些常用方法" aria-hidden="true">#</a> 1.13 讲下 java 中的 math 类有那些常用方法？</h3><hr><p>java.lang.Math 类是Java中提供的一个数学工具类，它包含了许多常用的数学方法，用于执行各种数学计算。以下是一些Math类中常用的方法：</p><p>基本数学运算方法：</p><ul><li>int abs(int a)：返回参数的绝对值。</li><li>double ceil(double a)：向上取整，返回大于等于参数的最小整数。</li><li>double floor(double a)：向下取整，返回小于等于参数的最大整数。</li><li>int max(int a, int b)：返回两个参数中较大的一个。</li><li>int min(int a, int b)：返回两个参数中较小的一个。</li><li>double pow(double base, double exponent)：返回一个数的指数幂。</li><li>double sqrt(double a)：返回参数的平方根。</li></ul><p>三角函数方法：</p><ul><li>double sin(double a)：返回参数的正弦值。</li><li>double cos(double a)：返回参数的余弦值。</li><li>double tan(double a)：返回参数的正切值。</li><li>double atan2(double y, double x)：返回以y/x为坐标的点的角度，范围是 -π 到 π。</li></ul><p>取整和舍入方法：</p><ul><li>double round(double a)：四舍五入到最接近的整数。</li><li>int round(float a)：四舍五入到最接近的整数。</li></ul><p>随机数生成方法：</p><ul><li>double random()：返回一个[0, 1)之间的随机浮点数。</li></ul><p>指数和对数方法：</p><ul><li>double exp(double a)：返回自然对数的底数e的参数次方。</li><li>double log(double a)：返回参数的自然对数（以e为底）。</li></ul><p>其他方法：</p><ul><li>double toRadians(double degrees)：将角度转换为弧度。</li><li>double toDegrees(double radians)：将弧度转换为角度。</li></ul><p>这只是Math类中一些常用方法的概述。通过使用这些方法，您可以执行各种数学运算，从基本的算术操作到三角函数、指数对数等复杂的计算。请注意，Math类中的方法都是静态方法，因此可以直接使用类名调用，如：Math.abs(-5)。</p><h3 id="_1-14-char-类型能不能转成-int-类型-能不能转化成-string-类型-能不能转成-double-类型" tabindex="-1"><a class="header-anchor" href="#_1-14-char-类型能不能转成-int-类型-能不能转化成-string-类型-能不能转成-double-类型" aria-hidden="true">#</a> 1.14 Char 类型能不能转成 int 类型？能不能转化成 string 类型，能不能转成 double 类型</h3><hr><p>Char 类型在 Java 中可以进行一些类型转换，但需要注意转换的方式和限制。</p><p>char 转 int：</p><p>Char 类型可以被隐式转换为 int 类型。因为 char 是 Unicode 编码的字符，其对应的整数值就是字符的 Unicode 码点。例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">&#39;A&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> intValue <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// 将字符 &#39;A&#39; 转换为整数 65</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>char 转 String：</p><p>Char 类型可以通过连接操作转换为 String 类型。当将 char 类型与 String 类型连接时，char 会被当作字符进行连接。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">&#39;A&#39;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;The character is: &quot;</span> <span class="token operator">+</span> c<span class="token punctuation">;</span> <span class="token comment">// 连接字符 &#39;A&#39; 到字符串</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>char 转 double：</p><p>Char 类型不能直接转换为 double 类型，因为 char 是表示字符的数据类型，而 double 是浮点数的数据类型。如果需要将 char 类型转换为 double 类型，需要经过 int 中间步骤。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">&#39;5&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> intValue <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// 将字符 &#39;5&#39; 转换为整数 53</span>
<span class="token keyword">double</span> doubleValue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> intValue<span class="token punctuation">;</span> <span class="token comment">// 将整数 53 转换为 double 53.0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：</p><ul><li>Char 类型可以隐式转换为 int 类型，Unicode 码点将作为整数值。</li><li>Char 类型可以通过连接操作转换为 String 类型。</li><li>Char 类型不能直接转换为 double 类型，需要通过 int 中间步骤。</li></ul><h3 id="_1-15-什么是拆装箱" tabindex="-1"><a class="header-anchor" href="#_1-15-什么是拆装箱" aria-hidden="true">#</a> 1.15 什么是拆装箱？</h3><p>拆装箱（Boxing and Unboxing）是 Java 中用于在基本数据类型（Primitive Types）和对应的包装类（Wrapper Classes）之间进行转换的过程。Java 提供了基本数据类型和对应的包装类来满足不同需求，但有时需要在它们之间进行转换。拆装箱就是这种转换过程的称呼。</p><p><strong>装箱（Boxing）：</strong></p><p>装箱是将基本数据类型转换为对应的包装类对象的过程。在装箱时，Java 会自动创建一个包装类的对象，然后将基本数据类型的值赋值给对象的属性。装箱可以通过直接赋值或方法调用来完成。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> intValue <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> integerValue <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>intValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 装箱</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>拆箱（Unboxing）：</strong></p><p>拆箱是将包装类对象转换为对应的基本数据类型的过程。在拆箱时，Java 会从包装类对象中提取出存储的基本数据类型的值，然后赋值给基本数据类型变量。拆箱可以通过直接赋值或方法调用来完成。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> integerValue <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> intValue <span class="token operator">=</span> integerValue<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拆箱</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在Java 5及以后的版本中，引入了自动拆装箱机制，使得拆装箱更加便捷。这意味着您可以在需要时直接使用基本数据类型和包装类，而不必显式进行装箱和拆箱操作。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> intValue <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> integerValue <span class="token operator">=</span> intValue<span class="token punctuation">;</span> <span class="token comment">// 自动装箱</span>
<span class="token keyword">int</span> intValueAgain <span class="token operator">=</span> integerValue<span class="token punctuation">;</span> <span class="token comment">// 自动拆箱</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结：</strong></p><ul><li>装箱是将基本数据类型转换为包装类对象。</li><li>拆箱是将包装类对象转换为基本数据类型。</li><li>自动拆装箱机制使得拆装箱更加方便。</li></ul><h3 id="_1-16-java-中的包装类都是那些" tabindex="-1"><a class="header-anchor" href="#_1-16-java-中的包装类都是那些" aria-hidden="true">#</a> 1.16 Java 中的包装类都是那些？</h3><hr><p>Java 中的包装类（Wrapper Classes）是用于将基本数据类型转换为对象的类，以便在需要对象的情况下使用。每种基本数据类型都有对应的包装类。以下是Java中的包装类：</p><p><strong>整数类型（Integer Types）：</strong></p><ul><li>Byte：对应 byte</li><li>Short：对应 short</li><li>Integer：对应 int</li><li>Long：对应 long</li></ul><p><strong>浮点数类型（Floating-Point Types）：</strong></p><ul><li>Float：对应 float</li><li>Double：对应 double</li></ul><p><strong>字符类型（Character Type）：</strong></p><ul><li>Character：对应 char</li></ul><p><strong>布尔类型（Boolean Type）：</strong></p><ul><li>Boolean：对应 boolean</li></ul><p>这些包装类都位于 java.lang 包中，因此在使用时不需要显式导入。包装类提供了许多方法来操作基本数据类型值，以及进行类型转换、字符串转换等操作。在需要对象的情况下，可以使用包装类来处理基本数据类型。</p><p>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> intValue <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 装箱</span>
<span class="token keyword">int</span> primitiveValue <span class="token operator">=</span> intValue<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拆箱</span>

<span class="token class-name">Character</span> charValue <span class="token operator">=</span> <span class="token char">&#39;A&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 自动装箱</span>
<span class="token keyword">char</span> primitiveChar <span class="token operator">=</span> charValue<span class="token punctuation">;</span> <span class="token comment">// 自动拆箱</span>

<span class="token class-name">Boolean</span> boolValue <span class="token operator">=</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">;</span> <span class="token comment">// 自动装箱</span>
<span class="token keyword">boolean</span> primitiveBool <span class="token operator">=</span> boolValue<span class="token punctuation">;</span> <span class="token comment">// 自动拆箱</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>包装类在许多场景中非常有用，例如在集合框架中，只能存储对象，因此需要使用包装类来存储基本数据类型值。同时，包装类也提供了许多方便的方法来进行数值计算和类型转换。</p><h3 id="_1-17-那针对浮点型数据运算出现的误差的问题-你怎么解决" tabindex="-1"><a class="header-anchor" href="#_1-17-那针对浮点型数据运算出现的误差的问题-你怎么解决" aria-hidden="true">#</a> 1.17 那针对浮点型数据运算出现的误差的问题，你怎么解决？</h3><hr><p>浮点数运算误差是由于计算机中使用有限的二进制位数来表示浮点数，从而导致无法精确表示某些分数或小数。这种误差在某些情况下可能会导致不准确的计算结果。虽然无法完全消除浮点数运算误差，但可以采取一些方法来减少其影响：</p><p><strong>使用 BigDecimal 类：</strong></p><p>java.math.BigDecimal 类提供了高精度的十进制运算，能够避免浮点数运算误差。它适用于需要精确计算的场景，但也会增加内存和计算开销。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigDecimal</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BigDecimalExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> num1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">&quot;0.1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BigDecimal</span> num2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">&quot;0.2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">BigDecimal</span> result <span class="token operator">=</span> num1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确计算结果</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>避免直接比较浮点数：</strong></p><p>浮点数之间的直接比较可能会受到舍入误差的影响，因此应该避免使用 == 来比较浮点数是否相等。可以使用一个很小的误差范围（称为 epsilon）来判断浮点数是否接近。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">double</span> num1 <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> num2 <span class="token operator">=</span> <span class="token number">0.2</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> sum <span class="token operator">=</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
<span class="token keyword">double</span> epsilon <span class="token operator">=</span> <span class="token number">1e-10</span><span class="token punctuation">;</span> <span class="token comment">// 很小的误差范围</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>sum <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> epsilon<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Approximately equal&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Not equal&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>尽量避免级联运算：</strong></p><p>在进行多次浮点数运算时，每次运算都可能引入额外的误差。尽量将运算合并为一个复杂的表达式，减少中间计算过程。</p><p>理解浮点数的精度限制： 了解浮点数在计算机中的表示以及二进制小数的特性，可以帮助您更好地理解和预测运算误差的产生。</p><p>无论采取何种方法，都需要根据具体的应用场景选择合适的处理方式。对于需要高精度的计算，使用 BigDecimal 类是一个可靠的选择。对于一般的浮点数计算，合适的比较方法和预估误差的方法可以帮助减少误差的影响。</p><h3 id="_1-19-面向对象的特征有哪些方面" tabindex="-1"><a class="header-anchor" href="#_1-19-面向对象的特征有哪些方面" aria-hidden="true">#</a> 1.19 面向对象的特征有哪些方面?</h3><hr><p>面向对象编程（Object-Oriented Programming，OOP）是一种软件开发范式，它基于对象和类的概念，将数据和操作封装在对象中，以提高代码的可维护性、可重用性和可扩展性。面向对象的特征主要有以下几个方面：</p><p><strong>封装（Encapsulation）：</strong></p><p>封装是将数据（属性）和操作（方法）封装在一个对象中，通过访问修饰符控制对内部数据的访问。这可以隐藏对象的内部实现细节，提供了抽象和封闭的界面。</p><p><strong>继承（Inheritance）：</strong></p><p>继承允许一个类（子类）从另一个类（父类）继承属性和方法。子类可以继承父类的特性，同时可以在其基础上进行扩展或修改。继承提供了代码重用的机制。</p><p><strong>多态（Polymorphism）：</strong></p><p>多态性允许对象可以根据上下文使用不同的方式呈现。多态性包括静态多态性（方法重载）和动态多态性（方法重写、接口实现）。多态性提供了灵活性和通用性，支持同一接口实现多种行为。</p><p><strong>抽象（Abstraction）：</strong></p><p>抽象是指从对象中提取共同的特征和行为，将其定义为类或接口。抽象类和接口提供了模板，具体的子类可以基于模板实现特定的功能。</p><p>这些面向对象的特征共同帮助开发者设计、构建和维护更加结构化、可重用和可扩展的软件系统。通过封装、继承、多态和抽象，开发者可以创建更具有组织性、模块化和可维护性的代码。</p><h3 id="_1-20-访问修饰符-public-private-protected-以及不写-默认-时的区别" tabindex="-1"><a class="header-anchor" href="#_1-20-访问修饰符-public-private-protected-以及不写-默认-时的区别" aria-hidden="true">#</a> 1.20 访问修饰符 public,private,protected,以及不写（默认） 时的区别？</h3><p>访问修饰符（Access Modifiers）用于控制类的成员（字段、方法、内部类等）的可见性和访问范围。在Java中，有四种主要的访问修饰符：public、private、protected 和默认（不写修饰符）。它们在访问范围和可见性方面有不同的作用。</p><p><strong>public 修饰符：</strong></p><ul><li>具有最广泛的访问范围，被 public 修饰的成员可以在任何地方访问。</li><li>可以在其他类、包内、不同的包甚至不同的项目中访问。</li><li>对于类来说，public 表示这个类可以被其他任何类访问。</li></ul><p><strong>private 修饰符：</strong></p><ul><li>具有最狭窄的访问范围，被 private 修饰的成员只能在同一个类内部访问。</li><li>无法在其他类中直接访问 private 成员。</li><li>对于类来说，private 表示这个类只能在自己内部使用，其他类无法直接访问。</li></ul><p><strong>protected 修饰符：</strong></p><p>拥有比 private 更广的访问范围，被 protected 修饰的成员可以在同一个包内部访问，以及在子类中访问（无论子类是否在同一个包中）。 对于类来说，protected 表示这个类只能在同一个包内和子类中使用。</p><p><strong>默认（不写修饰符）：</strong></p><ul><li>没有修饰符的成员被称为默认访问或包私有访问。</li><li>被默认修饰的成员可以在同一个包内访问，但在不同包中无法访问。</li><li>对于类来说，没有修饰符表示这个类只能在同一个包内使用。</li></ul><p>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> publicField<span class="token punctuation">;</span>       <span class="token comment">// 可在任何地方访问</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> privateField<span class="token punctuation">;</span>     <span class="token comment">// 只能在同一个类内访问</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> protectedField<span class="token punctuation">;</span> <span class="token comment">// 可在同一个包和子类中访问</span>
    <span class="token keyword">int</span> defaultField<span class="token punctuation">;</span>             <span class="token comment">// 只能在同一个包内访问</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>选择适当的访问修饰符是设计良好的面向对象编程的重要组成部分，可以提供良好的封装、尽量减少对内部细节的暴露，并且能够控制代码的访问级别。</p><table><thead><tr><th style="text-align:left;">访问修饰符</th><th style="text-align:left;">同一类</th><th style="text-align:left;">同一包</th><th style="text-align:left;">子类</th><th style="text-align:left;">不同包的非子类</th></tr></thead><tbody><tr><td style="text-align:left;">public</td><td style="text-align:left;">✅</td><td style="text-align:left;">✅</td><td style="text-align:left;">✅</td><td style="text-align:left;">✅</td></tr><tr><td style="text-align:left;">private</td><td style="text-align:left;">✅</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">protected</td><td style="text-align:left;">✅</td><td style="text-align:left;">✅</td><td style="text-align:left;">✅</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">默认（不写）</td><td style="text-align:left;">✅</td><td style="text-align:left;">✅</td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr></tbody></table><h3 id="_1-21-接口有什么特点" tabindex="-1"><a class="header-anchor" href="#_1-21-接口有什么特点" aria-hidden="true">#</a> 1.21 接口有什么特点？</h3><hr><p>接口（Interface）是Java编程语言中的一种重要的概念，用于定义一组抽象方法和常量。接口具有以下特点：</p><p><strong>抽象方法：</strong></p><p>接口中的方法都是抽象方法，没有方法体。实现接口的类必须提供这些方法的具体实现。</p><p><strong>多继承：</strong></p><p>类可以同时实现多个接口，从而实现多继承。这使得一个类可以继承多个不同的抽象特性，提高了代码的灵活性和可重用性。</p><p><strong>实现：</strong></p><p>类实现接口时，必须提供接口中所有方法的实现。实现接口是通过 implements 关键字来实现的。</p><p><strong>无状态：</strong></p><p>接口本身没有状态，只定义了方法的契约。这使得接口成为定义方法签名和行为的一种机制。</p><p><strong>常量：</strong></p><p>接口可以包含常量，这些常量在接口中默认为 public static final。它们通常表示一些常用的常量值。</p><p><strong>隐式抽象：</strong></p><p>接口本身是隐式抽象的，不需要使用 abstract 关键字来修饰。它定义的方法都是抽象的。</p><p><strong>不可实例化：</strong></p><p>接口本身不能被实例化，只能通过实现接口的类来使用接口。</p><p><strong>默认方法：</strong></p><p>Java 8 引入了接口的默认方法（default 方法），允许在接口中提供默认实现。这样实现接口的类不必强制性地提供默认方法的实现。</p><p><strong>静态方法：</strong></p><p>Java 8 也允许在接口中定义静态方法。这些静态方法可以直接通过接口名称来调用，而不需要实例化接口。</p><p><strong>用途：</strong></p><p>接口通常用于定义类的规范、约束和行为，实现类可以根据需要实现接口中的方法。</p><p>接口在面向对象编程中具有重要作用，它提供了一种将相关功能进行分组的方式，并可以在不同的类中共享和实现这些功能。接口的使用使得代码更加模块化、可维护和可扩展。</p><h3 id="_1-22-抽象类和接口的区别" tabindex="-1"><a class="header-anchor" href="#_1-22-抽象类和接口的区别" aria-hidden="true">#</a> 1.22 抽象类和接口的区别？</h3><hr><p>抽象类和接口是Java中两种不同的机制，用于实现抽象和多继承。它们具有一些相似之处，但也有一些关键的区别。以下是抽象类和接口的主要区别：</p><table><thead><tr><th style="text-align:left;">特点</th><th style="text-align:left;">抽象类</th><th style="text-align:left;">接口</th></tr></thead><tbody><tr><td style="text-align:left;">方法实现</td><td style="text-align:left;">包含抽象方法和具体方法</td><td style="text-align:left;">只能包含抽象方法、默认方法、静态方法</td></tr><tr><td style="text-align:left;">多继承</td><td style="text-align:left;">只能继承一个类</td><td style="text-align:left;">可以实现多个接口</td></tr><tr><td style="text-align:left;">构造函数</td><td style="text-align:left;">可以有构造函数</td><td style="text-align:left;">不能有构造函数</td></tr><tr><td style="text-align:left;">字段</td><td style="text-align:left;">可以包含实例字段</td><td style="text-align:left;">只能包含常量字段</td></tr><tr><td style="text-align:left;">访问修饰符</td><td style="text-align:left;">方法可以有不同的访问修饰符</td><td style="text-align:left;">方法默认为 public</td></tr><tr><td style="text-align:left;">实现</td><td style="text-align:left;">子类继承抽象类时，继承和复用方法和字段</td><td style="text-align:left;">实现接口时，需要提供所有方法的具体实现</td></tr><tr><td style="text-align:left;">单继承</td><td style="text-align:left;">继承抽象类时只能单继承</td><td style="text-align:left;">类可以实现多个接口</td></tr><tr><td style="text-align:left;">设计目的</td><td style="text-align:left;">提供共享基本功能和有状态行为</td><td style="text-align:left;">定义规范、契约和纯粹行为接口</td></tr></tbody></table><p>选择使用抽象类还是接口取决于您的设计需求。抽象类适用于共享基本功能、有状态的行为和代码复用。接口适用于定义规范、契约和实现多继承的场景。在某些情况下，抽象类和接口可以结合使用，以满足不同的设计目标。</p><h3 id="_1-23-hashcode-的作用" tabindex="-1"><a class="header-anchor" href="#_1-23-hashcode-的作用" aria-hidden="true">#</a> 1.23 Hashcode 的作用</h3><hr><p>在Java中，hashCode() 是一个对象方法，它返回对象的哈希码（哈希值）。哈希码是一个整数，通常用于支持哈希表（Hash Table）等数据结构，以提高数据的查找效率。hashCode() 方法的作用包括：</p><p><strong>1.在哈希表中查找：</strong></p><p>哈希表是一种用于快速查找的数据结构，它将键映射到值，并通过哈希函数将键转换为索引。哈希码作为索引可以用于在哈希表中查找对象，从而加快数据访问速度。</p><p><strong>2.在集合和映射中使用：</strong></p><p>Java的集合（如HashSet、HashMap）和映射（如HashMap）类使用哈希码来组织和存储元素。哈希码可以用于确定元素的存储位置，从而加速插入、查找和删除操作。</p><p><strong>3.提高性能：</strong></p><p>通过使用哈希码来分配对象在内存中的存储位置，可以使得相似的对象在相邻的内存位置，从而减少内存碎片，提高内存访问效率。</p><p><strong>4.在自定义哈希集合中使用：</strong></p><p>如果您创建了自己的哈希集合类，或者需要自定义哈希函数，可以使用对象的哈希码来计算存储位置。</p><p>要注意的是，根据Java规范，如果两个对象通过 equals() 方法被认为是相等的，那么它们的 hashCode() 方法应该返回相同的哈希码。然而，相等的哈希码并不意味着两个对象一定相等，因为哈希码可能会发生冲突，不同的对象可能计算出相同的哈希码。因此，hashCode() 方法的正确实现需要根据实际对象的状态来生成哈希码，以尽量减少哈希冲突的概率。</p><h3 id="_1-24-普通类与抽象类有什么区别" tabindex="-1"><a class="header-anchor" href="#_1-24-普通类与抽象类有什么区别" aria-hidden="true">#</a> 1.24 普通类与抽象类有什么区别？</h3><hr><p>普通类（Concrete Class）和抽象类（Abstract Class）是Java中的两种类别，它们具有一些区别。以下是普通类和抽象类的主要区别：</p><p><strong>1.实例化能力：</strong></p><ul><li>普通类可以被实例化，即可以创建类的对象。</li><li>抽象类不能直接被实例化，只能被继承并由子类实现其抽象方法后才能创建子类的对象。</li></ul><p><strong>2.方法实现：</strong></p><ul><li>普通类可以包含具体方法（有方法体的方法）和字段。</li><li>抽象类可以包含抽象方法和具体方法，但至少要包含一个抽象方法（没有方法体的方法）。</li></ul><p><strong>3.继承：</strong></p><ul><li>普通类可以被其他类继承，而无论它是否包含抽象方法。</li><li>抽象类通常被其他类继承，子类必须实现其抽象方法，或者子类本身也可以是抽象类。</li></ul><p><strong>4.作用：</strong></p><ul><li>普通类用于创建具体对象，包含实现细节和具体行为。</li><li>抽象类用于定义模板和规范，可以包含共享的抽象功能，需要子类实现具体行为。</li></ul><p><strong>5.多态性：</strong></p><ul><li>普通类的对象可以通过多态性，引用其子类对象。</li><li>抽象类本身不可以被实例化，但可以通过多态性，引用实现了抽象类的子类对象。</li></ul><p><strong>6.构造函数：</strong></p><ul><li>普通类可以有构造函数，用于初始化对象。</li><li>抽象类也可以有构造函数，但在子类实例化时，会调用抽象类的构造函数。</li></ul><p><strong>7.设计目的：</strong></p><ul><li>普通类用于创建具体对象，实现具体功能。</li><li>抽象类用于创建基于共享规范的模板，让子类实现特定功能。</li></ul><p><strong>8.实现多继承：</strong></p><ul><li>普通类无法实现多继承，一个类只能继承一个类。</li><li>抽象类可以实现多继承，一个类可以继承多个接口。</li></ul><p>总之，普通类用于创建具体的对象，包含实现细节；抽象类用于定义规范、契约和共享的抽象功能，需要子类实现具体的行为。选择使用哪种类取决于您的设计需求。</p><h3 id="_1-25-什么是接口-为什么需要接口" tabindex="-1"><a class="header-anchor" href="#_1-25-什么是接口-为什么需要接口" aria-hidden="true">#</a> 1.25 什么是接口？为什么需要接口？</h3><hr><p>接口（Interface）是Java编程语言中的一种重要的概念，用于定义一组抽象方法和常量。接口是一种规范、契约，它描述了一个类应该实现的方法和行为，但不提供具体的实现。接口提供了一种实现多继承、解耦合和代码复用的机制。</p><p>需要接口的主要原因包括：</p><p><strong>1.多继承：</strong></p><p>Java中，一个类只能继承一个类（单继承）。但是一个类可以实现多个接口，通过实现多个接口，一个类可以获得多个不同的抽象特性，从而实现多继承的效果。</p><p><strong>2.解耦合：</strong></p><p>接口可以将类的行为和实现分离。通过定义接口，您可以定义规范，而不需要暴露类的具体实现细节。这样在不影响接口使用者的情况下，可以更改实现。</p><p><strong>3.约定契约：</strong></p><p>接口可以作为一种契约，规定了实现类应该提供的方法。这有助于不同的开发者在不同模块中协作，确保类的实现符合预期。</p><p><strong>4.代码复用：</strong> 接口可以用于定义一组共享的抽象方法，多个类可以实现同一个接口，从而使得相似的功能可以在不同类中共享，提高代码复用性。</p><p><strong>5.灵活性和扩展性：</strong></p><p>通过实现接口，类可以在不改变继承关系的情况下，添加或修改特定的行为。这使得代码更加灵活，易于扩展。</p><p><strong>6.制定规范：</strong></p><p>接口可以作为一种制定规范的方式，要求实现类提供特定的方法和行为。这有助于确保项目中的类都遵循相同的规范。</p><p>总之，接口是一种用于定义规范、实现多继承、解耦合和增加代码灵活性的重要机制。通过定义接口，可以为类提供一组共享的抽象方法，让不同的类实现这些方法以实现具体的行为。</p><h3 id="_1-26-接口有什么特点" tabindex="-1"><a class="header-anchor" href="#_1-26-接口有什么特点" aria-hidden="true">#</a> 1.26 接口有什么特点？</h3><hr><p>接口（Interface）是Java中的一个重要概念，具有以下特点：</p><p><strong>1.抽象方法：</strong></p><p>接口只能包含抽象方法（没有方法体的方法）。这些方法没有默认实现，需要实现接口的类提供具体的实现。</p><p><strong>2.多继承：</strong></p><p>一个类可以实现多个接口，从而实现多继承的效果。这允许一个类获得多个不同的抽象特性。</p><p><strong>3.实现：</strong></p><p>类实现接口时，必须提供接口中所有方法的具体实现。一个类可以实现一个或多个接口。</p><p><strong>4.无状态：</strong></p><p>接口本身没有状态，不包含实例字段（属性）。它只定义了一组方法的规范。</p><p><strong>5.常量：</strong></p><p>接口可以包含常量字段，这些字段默认为 public static final，通常表示一些常用的常量值。</p><p><strong>6.隐式抽象：</strong></p><p>接口本身是隐式抽象的，不需要使用 abstract 关键字来修饰。接口定义的方法都是抽象的。</p><p><strong>7.不可实例化：</strong></p><p>接口本身不能被实例化，无法创建接口的对象。它需要被实现后才能通过实现类来使用。</p><p><strong>8.默认方法：</strong></p><p>Java 8 引入了接口的默认方法（default 方法），允许在接口中提供默认的方法实现。实现类可以直接继承或重写默认方法。</p><p><strong>9.静态方法：</strong></p><p>Java 8 也允许在接口中定义静态方法。这些方法可以通过接口名称直接调用，无需实例化接口。</p><p><strong>10.用途：</strong></p><p>接口通常用于定义类的规范、约定和行为，实现类可以根据需要实现接口中的方法。</p><p><strong>11.实现分离：</strong></p><p>接口实现了类的行为和实现的分离，允许不同类在具体实现上有不同的策略。</p><p>接口在面向对象编程中具有重要作用，它提供了一种将相关功能进行分组的方式，并可以在不同的类中共享和实现这些功能。接口的使用使得代码更加模块化、可维护和可扩展。</p><h3 id="_1-27-拷贝和浅拷贝的区别是什么" tabindex="-1"><a class="header-anchor" href="#_1-27-拷贝和浅拷贝的区别是什么" aria-hidden="true">#</a> 1.27 拷贝和浅拷贝的区别是什么?</h3><hr><p>拷贝（Copying）是指将一个对象的值复制到另一个对象中，使得两个对象具有相同的内容。在Java中，拷贝可以分为浅拷贝和深拷贝两种。</p><p><strong>浅拷贝（Shallow Copy）：</strong></p><p>浅拷贝是指创建一个新对象，将原始对象的字段值复制到新对象中，但不复制对象引用指向的内容。新对象中的引用仍然指向原始对象中的相同内容。换句话说，浅拷贝只是复制了对象的引用，而不是实际内容。</p><p><strong>深拷贝（Deep Copy）：</strong></p><p>深拷贝是指创建一个新对象，将原始对象的字段值复制到新对象中，同时递归地复制对象引用指向的内容。这样，新对象中的所有引用都是指向新复制的对象，而不是原始对象中的内容。</p><p>区别总结：</p><ul><li>浅拷贝只复制对象的引用，不复制引用指向的内容。</li><li>深拷贝复制对象的引用，并递归地复制引用指向的内容。</li></ul><p>在Java中，通过实现 Cloneable 接口和重写 clone() 方法可以实现对象的浅拷贝。要实现对象的深拷贝，通常需要手动递归复制对象的每个部分或者使用第三方库来实现。需要注意的是，进行深拷贝可能会涉及到循环引用等问题，需要特别处理。</p><h3 id="_1-28-jdbc-操作的步骤" tabindex="-1"><a class="header-anchor" href="#_1-28-jdbc-操作的步骤" aria-hidden="true">#</a> 1.28 JDBC 操作的步骤</h3><hr><p>JDBC（Java Database Connectivity）是用于在Java应用程序中与数据库进行交互的标准API。以下是使用JDBC进行数据库操作的一般步骤：</p><p><strong>1.加载数据库驱动程序：</strong></p><p>在使用JDBC之前，需要加载适用于特定数据库的驱动程序。不同的数据库有不同的驱动程序。使用Class.forName(&quot;驱动类全名&quot;)来加载驱动程序。</p><p><strong>2.建立数据库连接：</strong></p><p>使用驱动程序提供的DriverManager.getConnection(url, username, password)方法来建立与数据库的连接。其中url是数据库的连接URL，username和password是数据库的登录凭证。</p><p><strong>3.创建和执行 SQL 语句：</strong></p><p>使用连接对象的createStatement()方法创建一个Statement对象，然后使用Statement对象执行SQL语句，如SELECT、INSERT、UPDATE、DELETE等。</p><p><strong>4.处理查询结果：</strong></p><p>如果执行的是SELECT查询语句，可以通过Statement对象的executeQuery()方法获取一个ResultSet对象，然后使用ResultSet对象处理查询结果。</p><p><strong>5.执行更新操作：</strong></p><p>对于INSERT、UPDATE、DELETE等更新操作，可以使用Statement对象的executeUpdate()方法执行更新，并获取更新的行数。</p><p><strong>6.释放资源：</strong></p><p>在操作完成后，需要关闭ResultSet、Statement和连接对象，以便释放资源。通常在finally块中执行这些操作，以确保资源得到释放。</p><p><strong>7.异常处理：</strong></p><p>在操作数据库时，可能会出现异常，如连接失败、SQL语句错误等。需要适当地进行异常处理，以保证程序的稳定性。</p><p>这些是JDBC操作的基本步骤。为了更好地组织和管理数据库操作，也可以使用连接池来管理数据库连接，从而提高性能和资源的利用率。</p><h3 id="_1-29-什么时候用-assert" tabindex="-1"><a class="header-anchor" href="#_1-29-什么时候用-assert" aria-hidden="true">#</a> 1.29 什么时候用 assert</h3><hr><p>assert 是Java中的一个关键字，用于在代码中添加断言（Assertions）。断言是一种用于检查代码的有效性和预期结果的机制，通常用于开发和测试阶段。assert 的主要目的是在代码中插入一些检查点，确保程序在运行时满足预期的条件。</p><p>断言通常用于以下情况：</p><p>调试和测试： 在开发和测试阶段，断言可以用来检查代码中的假设是否成立。如果断言失败，程序会抛出AssertionError异常，指示出现了意外情况。这有助于发现和解决潜在的问题。</p><p><strong>1.验证假设：</strong></p><p>在编程过程中，您可能会有一些假设，例如参数不应该为负数，数组不应该为空等。您可以使用断言来验证这些假设，以确保程序在满足这些条件的情况下才能正确运行。</p><p><strong>2.检查不可到达的代码：</strong></p><p>断言可以用于检查代码中的某些分支是否会被执行。如果某个分支永远不应该被执行，您可以在分支处添加一个断言，如果该分支被错误地执行，将会触发断言失败。</p><p><strong>3.代码维护：</strong></p><p>断言可以在代码中作为文档，明确说明代码的预期行为。这对于维护代码和与他人合作时非常有用。</p><p>需要注意的是，assert 在默认情况下是被禁用的。要启用断言，需要在运行Java程序时添加 -ea 或 -enableassertions 参数。例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">java</span> <span class="token parameter variable">-ea</span> YourClassName
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然而，尽管断言在开发和测试中很有用，但它们不应该用于处理预期的错误或异常情况。在生产环境中，断言可能会被禁用，因此不应该依赖于断言来处理重要的错误情况。实际上，建议使用异常处理机制来处理运行时错误。</p><p>以下是一个使用断言的示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AssertionExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 使用断言检查 value 是否大于等于 0</span>
        <span class="token keyword">assert</span> value <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token string">&quot;Value must be non-negative&quot;</span><span class="token punctuation">;</span>
        
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Value is: &quot;</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-30-数组有没有-length-这个方法-string-有没有-length-这个方法" tabindex="-1"><a class="header-anchor" href="#_1-30-数组有没有-length-这个方法-string-有没有-length-这个方法" aria-hidden="true">#</a> 1.30 数组有没有 length()这个方法? String 有没有 length()这个方法</h3><hr><p>在Java中，数组和字符串都有长度属性，但是它们的获取方式略有不同。</p><p><strong>数组：</strong></p><p>数组是使用长度属性length来获取其元素的数量。它不是方法，而是一个公共的实例变量。例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> length <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 获取数组长度，不需要括号</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>字符串：</strong></p><p>字符串是使用length()方法来获取其字符数量（长度）。length()是字符串类的一个方法，它返回字符串的长度。例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取字符串长度，需要括号</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，总结起来：</p><ul><li>数组使用 length 属性获取长度。</li><li>字符串使用 length() 方法获取长度。</li></ul><h3 id="_1-31-用最有效率的方法算出3乘以8等于几" tabindex="-1"><a class="header-anchor" href="#_1-31-用最有效率的方法算出3乘以8等于几" aria-hidden="true">#</a> 1.31 用最有效率的方法算出3乘以8等于几？</h3><hr><p>位移操作是指将二进制数向左或向右移动一定的位数。对于2的幂次方，左移操作相当于乘以2的幂次方，右移操作相当于除以2的幂次方。</p><p>对于3乘以8，可以使用左移操作来实现：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 3左移3位，等于3的3次方，结果为24</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_1-32-string-和-stringbuilder、stringbuffer-的区别" tabindex="-1"><a class="header-anchor" href="#_1-32-string-和-stringbuilder、stringbuffer-的区别" aria-hidden="true">#</a> 1.32 String 和 StringBuilder、StringBuffer 的区别？</h3><hr><p><strong><code>String</code></strong>、<strong><code>StringBuilder</code></strong> 和 <strong><code>StringBuffer</code></strong> 都是在Java中用于处理字符串的类，但它们在性能、可变性和线程安全性方面有一些区别。</p><p><strong>1.String：</strong></p><ul><li>String 是不可变的，一旦创建就不能更改其内容。</li><li>每次对 String 进行操作（连接、截取等），都会创建一个新的 String 对象，原始对象保持不变，这可能会产生大量的临时对象，影响性能和内存。</li><li>String 是线程安全的，因为它的内容不可修改，所以多个线程共享一个 String 是安全的。</li></ul><p><strong>2.StringBuilder：</strong></p><ul><li>StringBuilder 是可变的，可以进行多次操作而不创建新的对象。</li><li>StringBuilder 的性能更好，适用于需要频繁操作字符串的场景，如循环拼接、修改等。</li><li>StringBuilder 不是线程安全的，不适合在多线程环境下使用，如果需要在多线程环境下使用可变字符串，应该使用 StringBuffer。</li></ul><p><strong>3.StringBuffer：</strong></p><ul><li>StringBuffer 也是可变的，类似于 StringBuilder，但是它是线程安全的。</li><li>StringBuffer 的操作方法都是 synchronized，所以在多线程环境下更安全，但也因此可能会带来一些性能损失。</li><li>StringBuffer 适用于在多线程环境下需要可变字符串的场景。</li></ul><p><strong>总结：</strong></p><ul><li>如果需要频繁进行字符串操作且不在多线程环境中，可以使用 StringBuilder，因为它性能更好。</li><li>如果在多线程环境中需要可变字符串，应该使用 StringBuffer，因为它是线程安全的。</li><li>如果需要处理不可变的字符串内容，可以使用 String。</li></ul><h3 id="_1-33-接口是否可继承-extends-接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concreteclass" tabindex="-1"><a class="header-anchor" href="#_1-33-接口是否可继承-extends-接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concreteclass" aria-hidden="true">#</a> 1.33 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？</h3><hr><p>接口、抽象类和具体类之间的关系可以总结如下：</p><p><strong>1.接口继承接口：</strong></p><p>是，接口可以继承（extends）其他接口。这样可以将多个接口的方法声明组合到一个新的接口中。</p><p><strong>2.抽象类实现接口：</strong></p><p>是，抽象类可以实现（implements）接口。抽象类可以在其内部实现接口中的一些方法，并将一些方法声明延迟到其子类中实现。</p><p><strong>3.抽象类继承具体类：</strong></p><p>是，抽象类可以继承具体类。抽象类继承具体类的主要目的是为了继承其行为和状态。但是，这样的继承关系在一些情况下可能会引入不必要的耦合，应该谨慎使用。</p><p>总结：</p><ul><li>接口可以继承接口，抽象类可以实现接口，抽象类也可以继承具体类。</li><li>在设计中，应根据需求和设计原则来选择是否使用继承关系，以确保代码结构的合理性和可维护性。</li></ul><h3 id="_1-34-一个-java-源文件中是否可以包含多个类-不是内部类-有什么限制" tabindex="-1"><a class="header-anchor" href="#_1-34-一个-java-源文件中是否可以包含多个类-不是内部类-有什么限制" aria-hidden="true">#</a> 1.34 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h3><hr><p>在Java中，一个.java源文件可以包含多个类，但有一些限制和规则需要遵循：</p><p><strong>1.一个公共类：</strong></p><p>每个.java源文件中只能有一个公共（public）类。这个公共类的类名必须与文件名相同，且每个.java源文件只能有一个与文件名相同的公共类。</p><p><strong>2.非公共类：</strong></p><p>除了公共类之外，一个.java源文件中可以包含任意数量的非公共类（默认访问修饰符或包内可见的类）。这些非公共类的类名可以与文件名不同。</p><p><strong>3.文件名和公共类名的关系：</strong></p><p>公共类的类名必须与文件名相同，包括大小写。如果文件名为MyClass.java，那么公共类的类名必须是MyClass。</p><p><strong>4.主类：</strong></p><p>如果Java程序中有一个public static void main(String[] args) 方法，这个方法所在的类通常会被称为主类。主类不一定是公共类，但在运行程序时，Java虚拟机会从主类的main方法开始执行。</p><p><strong>总结：</strong></p><p>一个.java源文件可以包含一个公共类和任意数量的非公共类。每个公共类的类名必须与文件名相同。这样的设计灵活性允许将多个相关的类组织在同一个文件中，但通常更推荐将每个类放在独立的文件中，以提高代码的可读性和维护性。</p><h3 id="_1-35-java-中的-final-关键字有哪些用法" tabindex="-1"><a class="header-anchor" href="#_1-35-java-中的-final-关键字有哪些用法" aria-hidden="true">#</a> 1.35 Java 中的 final 关键字有哪些用法？</h3><hr><p>在Java中，final 是一个关键字，用于修饰变量、方法和类，具有不同的用法和含义。以下是final 关键字的主要用法：</p><p><strong>1.Final 变量：</strong></p><ul><li>修饰变量时，表示该变量是一个常量，其值在初始化后不能被修改。</li><li>必须在声明时或构造方法中对final变量进行初始化。</li><li>常用于表示不变的常量，如数学常数、配置参数等。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_VALUE</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2.Final 方法：</strong></p><ul><li>修饰方法时，表示该方法不能被子类重写（覆盖）。</li><li>子类无法修改final方法的实现。</li><li>在设计中，可以使用final方法确保方法的行为在继承层次中不会被改变。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Parent&#39;s print method&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token comment">// 无法重写 Parent 类中的 final 方法</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.Final 类：</strong></p><ul><li>修饰类时，表示该类不能被继承。</li><li>不能有子类扩展final类。</li><li>在某些情况下，可以使用final类来防止子类扰乱基类的设计。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">MyFinalClass</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不能有子类继承 MyFinalClass</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4.Final 参数：</strong></p><ul><li>修饰方法的参数时，表示方法内部不能修改该参数的值。</li><li>这主要用于方法内部匿名内部类的访问，以确保参数不被修改。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// value 不能在方法内部被修改</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总之，final 关键字在Java中用于表示不可变性、方法不可重写、类不可继承等情况。根据不同的使用场景，它可以提供代码安全性、可读性和设计灵活性。</p><h2 id="_2-java集合-范型" tabindex="-1"><a class="header-anchor" href="#_2-java集合-范型" aria-hidden="true">#</a> 2.JAVA集合/范型</h2><h3 id="_2-1-arraylist-和-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#_2-1-arraylist-和-linkedlist-的区别" aria-hidden="true">#</a> 2.1 ArrayList 和 linkedList 的区别</h3><hr><p>ArrayList 和 LinkedList 都是Java集合框架中的List实现，用于存储一组元素。它们在底层实现和性能方面有一些区别，适用于不同的使用场景。</p><p><strong>1.底层实现：</strong></p><ul><li>ArrayList 底层使用动态数组实现。它在内存中分配一块连续的内存空间来存储元素。</li><li>LinkedList 底层使用双向链表实现。每个元素都包含一个指向前一个元素和一个指向后一个元素的引用。</li></ul><p><strong>2.访问效率：</strong></p><ul><li>ArrayList 支持随机访问，因为它使用数组来存储元素。通过索引可以快速访问元素。</li><li>LinkedList 需要从头或尾开始遍历链表来访问元素，因此随机访问效率较低。</li></ul><p><strong>3.插入和删除操作：</strong></p><ul><li>ArrayList 在中间或末尾插入或删除元素时，需要移动后续元素来填补空缺，所以插入和删除操作的效率可能较低。</li><li>LinkedList 在插入和删除元素时，只需要调整前后元素的引用，因此在某些情况下插入和删除操作的效率更高。</li></ul><p><strong>4.空间消耗：</strong></p><ul><li>ArrayList 通常会预分配一定大小的内存，因此可能会有一些空间浪费。</li><li>LinkedList 需要额外的空间来存储链表节点的引用，可能会占用更多的内存。</li></ul><p><strong>5.适用场景：</strong></p><ul><li>如果主要是进行随机访问和读取操作，ArrayList 的性能更好。</li><li>如果主要是进行插入、删除和频繁的操作，特别是在链表的首尾操作，LinkedList 的性能更好。</li></ul><p><strong>总结：</strong></p><p>选择使用 ArrayList 还是 LinkedList 取决于具体的使用场景。如果需要频繁的插入、删除操作，或者链表的大小可能会动态变化，LinkedList 可能更适合。如果主要进行随机访问和读取操作，ArrayList 更适合。</p><h3 id="_2-2-hashmap-排序" tabindex="-1"><a class="header-anchor" href="#_2-2-hashmap-排序" aria-hidden="true">#</a> 2.2 HashMap 排序</h3><hr><p>HashMap 是一种无序的键值对集合，它不会保持任何特定的顺序。如果你想对 HashMap 中的键值对进行排序，可以将其转换为一个有序的集合，如 TreeMap 或者将其按照某种规则排序后放入一个列表中。</p><p>下面是一种方法，通过将 HashMap 的键值对放入一个 ArrayList 中，并使用 Collections.sort() 方法对列表进行排序：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapSorting</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个HashMap并放入键值对</span>
        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;apple&quot;</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;banana&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;cherry&quot;</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 将HashMap的键值对放入ArrayList中</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entryList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 使用Collections.sort()对ArrayList进行排序</span>
        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>entryList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry1<span class="token punctuation">,</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> entry1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>entry2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按值升序排序</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 打印排序后的结果</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> entryList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们使用了 Collections.sort() 方法来对包含 HashMap 键值对的 ArrayList 进行排序。在比较器中，我们按照值的升序对键值对进行排序。你可以根据需要更改排序方式，比如按照键排序、按照值降序排序等。</p><h3 id="_2-3-collection-包结构-与-collections-的区别" tabindex="-1"><a class="header-anchor" href="#_2-3-collection-包结构-与-collections-的区别" aria-hidden="true">#</a> 2.3 Collection 包结构，与 Collections 的区别</h3><hr><p>Collection 是Java集合框架的根接口，它是所有集合类的基础接口，它定义了一组通用的方法来操作集合中的元素。Collection 接口继承自 Iterable 接口，它是Java中的集合框架的核心。</p><p>Collections 是一个实用类，位于java.util包中，提供了一系列静态方法来操作集合，这些方法可以用于对集合进行排序、查找、反转等常见操作。Collections 类不是集合类的直接实现，而是提供了一组静态方法，用于操作各种集合类型。</p><p><strong>总结：</strong></p><ul><li>Collection 是一个接口，是Java集合框架的根接口，它定义了操作集合元素的通用方法。</li><li>Collections 是一个实用类，提供了静态方法来操作集合，比如排序、查找等。它不是集合类，而是针对集合操作的工具类。</li><li>Collection 是集合框架的核心，Collections 是对集合操作的实用工具类。</li></ul><h3 id="_2-4-说说-list-set-map-三者的区别" tabindex="-1"><a class="header-anchor" href="#_2-4-说说-list-set-map-三者的区别" aria-hidden="true">#</a> 2.4 说说 List,Set,Map 三者的区别</h3><hr><p>List、Set 和 Map 都是Java集合框架中的接口，用于存储和操作一组元素。它们在存储方式、元素的唯一性以及元素和键值对的关系上有所不同。</p><p><strong>List：</strong></p><ul><li>List 是一个有序的集合，可以包含重复的元素。</li><li>元素按照插入顺序存储，可以通过索引访问和操作。</li><li>常用实现类有 ArrayList、LinkedList 等。</li></ul><p><strong>Set：</strong></p><ul><li>Set 是一个无序的集合，不允许重复的元素。</li><li>元素没有明确的顺序，不能通过索引访问和操作。</li><li>常用实现类有 HashSet、LinkedHashSet、TreeSet 等。</li></ul><p><strong>Map：</strong></p><ul><li>Map 是一种键值对映射的集合，每个键对应一个值。</li><li>键是唯一的，值可以重复。</li><li>常用实现类有 HashMap、LinkedHashMap、TreeMap 等。</li></ul><p>总结：</p><ul><li>List 是有序集合，允许重复元素。</li><li>Set 是无序集合，不允许重复元素。</li><li>Map 是键值对映射集合，每个键对应一个值。</li></ul><p>选择使用哪个集合类型取决于你的需求。如果需要有序访问且可能有重复元素，选择 List；如果需要无序访问且不允许重复元素，选择 Set；如果需要存储键值对映射，选择 Map。每种集合类型都有其特定的应用场景和适用性。</p><h3 id="_2-5-并发集合和普通集合的区别" tabindex="-1"><a class="header-anchor" href="#_2-5-并发集合和普通集合的区别" aria-hidden="true">#</a> 2.5 并发集合和普通集合的区别</h3><hr><p>Java中的并发集合和普通集合之间的主要区别在于它们在多线程环境下的线程安全性和性能方面。以下是它们之间的一些主要区别：</p><p><strong>1.线程安全性：</strong></p><p><strong>普通集合：</strong> 普通集合类（如ArrayList、HashMap等）不是线程安全的，这意味着在多个线程同时访问和修改集合时，可能会导致数据不一致性和并发问题（如数据损坏、死锁等）。</p><p><strong>并发集合：</strong> 并发集合类是专门设计用于多线程环境的，它们提供了线程安全的操作。多个线程可以同时读取、写入并发集合，而不会引发数据损坏或其他并发问题。</p><p><strong>2.同步机制：</strong></p><p><strong>普通集合：</strong> 普通集合没有内置的同步机制，如果需要在多线程环境中使用它们，需要手动实现同步措施，如使用显式的锁机制（synchronized关键字等）。</p><p><strong>并发集合：</strong> 并发集合内部已经实现了适当的同步机制，使得多个线程可以安全地同时访问和修改集合。</p><p><strong>3.性能：</strong></p><p><strong>普通集合：</strong> 由于普通集合没有内置的同步机制，需要在多线程环境中进行额外的同步操作，这可能会降低性能并引入线程争用。</p><p><strong>并发集合：</strong> 并发集合经过优化，可以在多线程环境下提供较好的性能。它们使用了更精细的锁机制、CAS（比较并交换）操作等技术来减少线程竞争。</p><p><strong>一些常见的并发集合包括：</strong></p><ul><li>ConcurrentHashMap: 用于线程安全的哈希表操作。</li><li>ConcurrentLinkedQueue: 用于线程安全的队列操作。</li><li>CopyOnWriteArrayList: 在写入操作时复制底层数组，用于读多写少的场景。</li></ul><p>当在多线程环境中需要使用集合时，如果涉及并发访问，最好选择适当的并发集合，以确保线程安全和性能。如果在单线程环境中使用集合，普通集合可能更适合，因为它们不会引入额外的同步开销。</p><h3 id="_2-6-map-有什么特点" tabindex="-1"><a class="header-anchor" href="#_2-6-map-有什么特点" aria-hidden="true">#</a> 2.6 Map 有什么特点</h3><hr><p>Map是Java中的一种集合类型，用于存储键值对（key-value pairs）。它具有以下特点：</p><p><strong>1.键值对存储：</strong> Map存储的是键值对，其中每个键（key）都是唯一的，而值（value）可以重复。通过键可以快速地查找和获取对应的值。</p><p><strong>2.唯一键：</strong> 每个键在Map中是唯一的，不允许重复的键存在。这确保了通过键的查找操作是明确的，不会出现歧义。</p><p><strong>3.无序性（通常情况下）：</strong> 在许多Map的实现中，键值对的存储是无序的，即它们不会按照插入的顺序来排列。但也有一些Map的实现保持插入顺序（如LinkedHashMap）或按照键的特定顺序（如自然顺序或自定义比较器顺序）排列（如TreeMap）。</p><p><strong>4.高效的查找操作：</strong> Map提供了高效的查找操作，可以通过键来快速定位对应的值。这对于存储大量数据并且需要快速检索的场景非常有用。</p><p><strong>5.支持多种数据类型：</strong> Map的键和值可以是任何引用类型，包括基本数据类型的包装类和自定义类对象。</p><p><strong>6.动态大小：</strong> Map可以根据需要动态地增长或缩小，以适应存储的键值对数量的变化。</p><p>常见的Map实现包括：</p><ul><li>HashMap: 基于哈希表实现的Map，提供了快速的查找操作。键的顺序是不确定的。</li><li>LinkedHashMap: 基于哈希表和链表实现的Map，保持了插入顺序，可以按插入顺序或访问顺序迭代键值对。</li><li>TreeMap: 基于红黑树实现的Map，键是有序的，可以使用自然顺序或自定义比较器进行排序。</li><li>ConcurrentHashMap: 针对并发访问进行了优化的哈希表实现，支持高并发环境下的安全访问。</li><li>WeakHashMap: 允许键为弱引用的Map，在没有其他强引用指向键时，键值对可能会被自动回收。</li></ul><p>总之，Map是一个重要的数据结构，适用于存储和管理键值对，并在许多Java应用中都得到了广泛的应用。</p><h3 id="_2-7-集合类存放于-java-util-包中-主要有几种接口" tabindex="-1"><a class="header-anchor" href="#_2-7-集合类存放于-java-util-包中-主要有几种接口" aria-hidden="true">#</a> 2.7 集合类存放于 <code>Java.util</code> 包中， 主要有几种接口</h3><hr><p>在Java的java.util包中，主要有以下几种重要的集合接口：</p><p><strong>1.Collection 接口：</strong> Collection是所有集合类的根接口，它定义了一些通用的方法，适用于各种集合类型。它派生了许多其他集合接口，包括：</p><ul><li>List：有序集合，允许重复元素。</li><li>Set：不允许重复元素的无序集合。</li><li>Queue：队列接口，用于实现队列数据结构。</li><li>Deque：双端队列接口，支持在队列两端进行元素的插入和删除。</li></ul><p><strong>2.List 接口：</strong> 继承自Collection接口，代表有序的列表集合，允许重复元素。常见的实现类包括：</p><ul><li>ArrayList：基于动态数组实现的列表。</li><li>LinkedList：基于链表实现的列表，支持高效的插入和删除操作。</li><li>Vector：类似于ArrayList，但是是线程安全的，因此在并发环境中使用较多。</li></ul><p><strong>3.Set 接口：</strong> 继承自Collection接口，代表不允许重复元素的无序集合。常见的实现类包括：</p><ul><li>HashSet：基于哈希表实现的集合，不保证元素的顺序。</li><li>LinkedHashSet：基于哈希表和链表实现的集合，保持插入顺序。</li><li>TreeSet：基于红黑树实现的有序集合，可以指定自然顺序或自定义比较器。</li></ul><p><strong>4.Queue 接口：</strong> 继承自Collection接口，代表队列，通常按照先进先出（FIFO）的顺序进行操作。常见的实现类包括：</p><ul><li>LinkedList：可以用作队列的实现。</li><li>PriorityQueue：基于优先级堆实现的优先队列，可以按照元素的优先级进行操作。</li></ul><p><strong>5.Deque 接口：</strong> 继承自Queue接口，代表双端队列，支持在队列的两端进行元素的插入和删除。常见的实现类包括：</p><ul><li>ArrayDeque：基于动态数组实现的双端队列。</li></ul><p>除了上述主要的集合接口，还有一些其他的接口和抽象类，如Map接口代表键值对的集合，还有一些特定用途的集合类和接口，如SortedSet、NavigableSet、Map.Entry等。这些集合接口和类提供了丰富的功能和选择，以满足不同类型的数据结构需求。</p><h3 id="_2-8-什么是-list-接口" tabindex="-1"><a class="header-anchor" href="#_2-8-什么是-list-接口" aria-hidden="true">#</a> 2.8 什么是 list 接口</h3><hr><p>List接口是Java集合框架中的一个接口，它继承自Collection接口，用于表示有序的元素列表，允许重复元素存在。List接口的特点是可以通过索引访问元素，并且可以按照元素的插入顺序进行迭代。</p><p>主要特点和方法包括：</p><p><strong>1.有序性：</strong> List中的元素是有序的，即它们按照被添加的顺序排列，可以通过索引来访问指定位置的元素。</p><p><strong>2.允许重复元素：</strong> List允许存储重复的元素，不同于Set接口，后者要求元素唯一。</p><p><strong>3.基本操作：</strong> List接口提供了基本的添加、删除、获取和修改元素的方法，如add()、remove()、get()、set()等。</p><p><strong>4.索引访问：</strong> 可以通过整数索引访问列表中的元素。索引从0开始，依次递增。例如，通过list.get(0)可以获取列表的第一个元素。</p><p><strong>5.迭代：</strong> 可以使用迭代器或者增强型for循环来遍历List中的元素。迭代的顺序是按照元素插入的顺序。</p><p>常见的实现类包括：</p><ul><li>ArrayList：基于动态数组实现的列表，支持随机访问，适用于频繁的读操作。</li><li>LinkedList：基于双向链表实现的列表，支持高效的插入和删除操作，适用于频繁的插入和删除操作。</li><li>Vector：类似于ArrayList，但是是线程安全的，适用于在多线程环境中使用。</li></ul><p>示例代码演示如何创建一个List并操作其中的元素：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个ArrayList</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 添加元素</span>
        names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Charlie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 访问元素</span>
        <span class="token class-name">String</span> secondName <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Second name: &quot;</span> <span class="token operator">+</span> secondName<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 修改元素</span>
        names<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;Alicia&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 遍历元素</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 删除元素</span>
        names<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过List接口，你可以灵活地操作有序的元素集合，满足各种应用场景下的需求。</p><h3 id="_2-9-说说-arraylist-数组" tabindex="-1"><a class="header-anchor" href="#_2-9-说说-arraylist-数组" aria-hidden="true">#</a> 2.9 说说 ArrayList（数组）</h3><hr><p>ArrayList是Java集合框架中基于动态数组实现的一个类，它可以自动扩容以适应不断变化的元素数量。以下是关于ArrayList的数组实现和扩容机制的详细说明：</p><p><strong>数组实现：</strong></p><p>ArrayList内部使用一个数组来存储元素，这个数组的初始大小是一个固定的值。当向ArrayList添加元素时，如果数组已满，就会触发扩容操作，将当前数组的元素复制到一个更大的新数组中，以容纳更多的元素。通过数组实现，ArrayList具备了随机访问的高效特性，可以通过索引快速访问元素。</p><p><strong>扩容机制：</strong></p><p>ArrayList的扩容机制是通过调整底层数组的大小来实现的。当需要扩容时，ArrayList会创建一个新的更大的数组，并将原数组中的元素逐个复制到新数组中，然后使用新数组替代原数组。具体的扩容机制如下：</p><p><strong>1.初始容量：</strong> 当你创建一个空的ArrayList时，它会分配一个初始容量，通常为10个元素（这个初始容量可以通过构造函数进行设置）。</p><p><strong>2.扩容因子：</strong> ArrayList的扩容机制涉及一个扩容因子（load factor），通常是0.5或0.75。这个扩容因子表示，当数组中的元素占据了数组容量的一定比例时，就触发扩容操作。</p><p><strong>3.触发扩容：</strong> 当ArrayList的元素数量达到当前数组容量乘以扩容因子时，就会触发扩容操作。例如，如果扩容因子是0.75，而当前数组容量为10，那么当元素数量达到10 * 0.75 = 7 时，就会触发扩容。</p><p><strong>新数组大小：</strong> 扩容时，ArrayList会创建一个新的数组，其大小通常是当前数组大小的1.5倍或2倍（具体取决于实现和版本）。</p><p><strong>复制元素：</strong> 在扩容过程中，ArrayList会逐个复制原数组中的元素到新数组中，以保持元素的顺序。</p><p><strong>性能影响：</strong> 扩容操作会引入一定的性能开销，因为需要复制元素。但是，由于扩容的频率较低，通常不会对整体性能产生明显影响。</p><p>通过自动扩容机制，ArrayList能够在不同元素数量的场景下有效地管理存储空间，从而避免了静态数组固定大小的限制。但需要注意，在某些情况下，可以通过设置合适的初始容量来减少扩容的频率，从而提升性能。</p><h3 id="_2-10-说说vector的-数组实现、-线程同步" tabindex="-1"><a class="header-anchor" href="#_2-10-说说vector的-数组实现、-线程同步" aria-hidden="true">#</a> 2.10 说说Vector的（ 数组实现、 线程同步）</h3><hr><p>Vector是Java集合框架中的一个实现类，它是基于动态数组实现的，与ArrayList相似。然而，与ArrayList不同的是，Vector是线程安全的，这意味着它可以在多线程环境下使用而不会引发并发访问问题。下面是关于Vector的数组实现和线程同步的详细解释：</p><p><strong>数组实现：</strong></p><p>Vector内部同样使用一个数组来存储元素，与ArrayList的实现类似。它也具备动态扩容的特性，以适应不断变化的元素数量。</p><p><strong>线程同步：</strong></p><p>Vector是一个线程安全的集合类。这意味着多个线程可以同时访问和修改一个Vector实例，而不会引发数据不一致性或其他并发问题。Vector实现线程安全的机制是通过在各种操作上使用同步锁来实现的。</p><p><strong>方法级别同步：</strong> Vector的各种方法（如add()、get()、remove()等）都是同步的，即在调用这些方法时会获取一个同步锁，以确保只有一个线程可以执行这些方法。这使得在多线程环境下，同一时刻只能有一个线程操作Vector，从而避免了数据不一致性。</p><p><strong>迭代器同步：</strong> Vector的迭代器也是同步的，这意味着在迭代过程中，其他线程无法修改Vector的内容。</p><p><strong>使用场景：</strong></p><p>Vector适用于需要在多线程环境下使用的场景。如果你需要一个线程安全的动态数组，Vector是一个选择。然而，需要注意的是，由于Vector的线程同步机制会引入一定的性能开销，因此在单线程环境下使用ArrayList可能会更高效。</p><h3 id="_2-11-说说-linklist的链表" tabindex="-1"><a class="header-anchor" href="#_2-11-说说-linklist的链表" aria-hidden="true">#</a> 2.11 说说 LinkList的链表</h3><hr><p>LinkedList是Java集合框架中的一个实现类，它基于双向链表（doubly linked list）数据结构来存储元素。与基于数组的ArrayList不同，LinkedList通过节点之间的引用连接来组织元素。以下是关于LinkedList链表的一些详细说明：</p><p><strong>链表结构：</strong></p><p>LinkedList内部使用节点（Node）来存储元素，每个节点包含两个引用，一个指向前一个节点，一个指向后一个节点，这就是双向链表的结构。第一个节点称为头节点，最后一个节点称为尾节点。</p><p><strong>插入和删除操作：</strong></p><p>由于LinkedList的插入和删除操作只需要修改节点的引用，而不需要像数组那样进行元素的复制，因此在插入和删除方面，LinkedList比ArrayList更加高效。特别是在列表的中间位置进行插入和删除操作时，LinkedList的性能通常更好。</p><p><strong>随机访问：</strong></p><p>由于LinkedList不像ArrayList那样通过索引进行随机访问，它的随机访问效率相对较低。要访问特定位置的元素，需要从头或尾开始遍历链表，直到达到所需的位置。</p><p><strong>迭代和遍历：</strong></p><p>LinkedList可以通过迭代器或者增强型for循环来遍历元素，遍历的顺序是按照元素的插入顺序。</p><p><strong>链表的优势和适用场景：</strong></p><p>LinkedList的插入和删除操作更高效，特别是在列表中间位置的操作。 当需要频繁进行插入和删除操作，而对随机访问的性能要求不高时，LinkedList可能更适合。 LinkedList在栈、队列等数据结构的实现中也非常常见。</p><p><strong>链表的劣势：</strong></p><p>相对于基于数组的ArrayList，LinkedList在随机访问元素时性能较差，因为它需要遍历节点。 LinkedList占用的内存空间较多，因为每个节点都需要存储两个引用。</p><h3 id="_2-12-什么-set-集合" tabindex="-1"><a class="header-anchor" href="#_2-12-什么-set-集合" aria-hidden="true">#</a> 2.12 什么 Set 集合</h3><hr><p>Set是Java集合框架中的一个接口，它表示一种不允许重复元素的无序集合。每个元素在Set中是唯一的，重复的元素会被自动过滤掉。Set接口派生了许多实现类，每个实现类都有其特定的特点和用途。</p><p>Set的主要特点包括：</p><p><strong>无序性：</strong> Set中的元素是无序的，即它们没有特定的排列顺序。这与List接口不同，List中的元素是有序的，具有插入的顺序。</p><p><strong>唯一性：</strong> Set中的元素是唯一的，不允许重复。如果尝试向Set中添加一个已经存在的元素，添加操作会被忽略。</p><p><strong>基本操作：</strong> Set接口提供了基本的添加、删除、包含检查等操作，允许用户向集合中添加元素，从集合中删除元素，以及检查集合中是否包含指定的元素。</p><p><strong>不同实现：</strong> Set接口的常见实现类包括：</p><ul><li>HashSet：基于哈希表实现的集合，提供了快速的查找操作。</li><li>LinkedHashSet：基于哈希表和链表实现的集合，保持插入顺序。</li><li>TreeSet：基于红黑树实现的有序集合，可以指定自然顺序或自定义比较器。</li></ul><p><strong>性能考虑：</strong> 不同的Set实现在性能方面可能会有所不同。通常情况下，HashSet提供了较好的性能，但是不保证元素的顺序。如果需要有序的集合，可以使用LinkedHashSet或TreeSet。</p><h3 id="_2-13-hashset-hash-表" tabindex="-1"><a class="header-anchor" href="#_2-13-hashset-hash-表" aria-hidden="true">#</a> 2.13 HashSet（ Hash 表）</h3><hr><p>当谈到HashSet的哈希表时，我们通常在计算机科学中引用的是散列集合数据结构。HashSet是许多编程语言中提供的一种集合实现，它基于哈希表数据结构，用于存储一组唯一的元素。</p><p>哈希表是一种数据结构，用于快速存储和检索键-值对。在HashSet中，我们不关心键-值对，而只关心存储唯一的元素。这是通过使用哈希函数来实现的。以下是一些关于HashSet哈希表的重要概念：</p><p><strong>1.哈希函数（Hash Function）：</strong> 哈希函数是将输入值（元素）映射到固定大小的哈希值的算法。理想情况下，不同的元素将映射到不同的哈希值，但由于哈希函数的有限输出范围，不同的元素也可能映射到相同的哈希值，这就是所谓的哈希冲突。</p><p><strong>2.哈希冲突（Hash Collision）：</strong> 当两个不同的元素被映射到相同的哈希值时，就会发生哈希冲突。哈希表的设计和性能取决于如何处理这些冲突。常见的解决方法包括链式哈希法和开放寻址法。</p><p><strong>3.桶（Bucket）：</strong> 在HashSet的哈希表中，桶是存储元素的主要位置。每个桶对应一个可能的哈希值。当元素被添加到哈希表时，哈希函数计算其哈希值，并将其放置在相应的桶中。</p><p><strong>4.负载因子（Load Factor）：</strong> 负载因子是衡量哈希表占用程度的指标，通常定义为元素数量与桶数量的比率。负载因子高时，哈希表容易发生冲突，性能下降。为了保持性能，可以在负载因子达到一定阈值时进行扩容，增加桶的数量。</p><p><strong>5.扩容（Resizing）：</strong> 当负载因子达到一定阈值时，为了保持性能，哈希表会自动扩容。扩容涉及创建一个更大的哈希表，并重新将所有元素哈希到新的桶中。这有助于减少冲突，提高查找和插入操作的效率。</p><p>总之，HashSet使用哈希表作为其基础数据结构，通过哈希函数和桶来存储和管理元素。这使得HashSet能够在平均情况下实现快速的插入、删除和查找操作。然而，选择合适的哈希函数以及适当的负载因子阈值等因素对于哈希表的性能至关重要。</p><h3 id="_2-14-什么是-treeset-二叉树" tabindex="-1"><a class="header-anchor" href="#_2-14-什么是-treeset-二叉树" aria-hidden="true">#</a> 2.14 什么是 TreeSet（二叉树）</h3><hr><p>TreeSet是许多编程语言中提供的一种集合实现，它基于平衡二叉搜索树（也称为二叉查找树）数据结构。平衡二叉搜索树是一种特殊的二叉树，具有以下性质：</p><p><strong>1.二叉树结构：</strong> 每个节点最多有两个子节点，分别称为左子节点和右子节点。</p><p><strong>2.有序性：</strong> 对于树中的每个节点，其左子树中的所有节点的值都小于该节点的值，而右子树中的所有节点的值都大于该节点的值。这使得在树中进行搜索操作时具有良好的有序性。</p><p><strong>3.平衡性：</strong> 平衡二叉搜索树要求左子树和右子树的高度差不超过一个固定的值（通常为1），从而保持树的平衡状态。这有助于维持树的性能，使得插入、删除和查找等操作的平均时间复杂度保持在对数级别。</p><p>在TreeSet中，这种平衡二叉搜索树的特性用于存储一组有序的唯一元素。通过将元素按照一定的顺序插入到树中，可以保证树的有序性。这使得在TreeSet中进行范围查找、插入、删除等操作具有较好的性能。</p><p>需要注意的是，虽然平衡二叉搜索树在一般情况下提供了较好的性能，但是在极端情况下，树可能会失衡，导致操作的时间复杂度变高。因此，实际使用中，需要确保树的平衡性，或者使用自平衡的变种，如红黑树，以确保操作的稳定性和性能。</p><p>总之，TreeSet使用平衡二叉搜索树作为其基础数据结构，通过这种结构来维护有序性，并提供高效的插入、删除和查找操作。</p><h3 id="_2-15-list-和-map、set-的区别" tabindex="-1"><a class="header-anchor" href="#_2-15-list-和-map、set-的区别" aria-hidden="true">#</a> 2.15 List 和 Map、Set 的区别？</h3><hr><p>List、Map和Set是在编程中常用的三种不同类型的集合，它们各自具有不同的特性和用途。</p><p><strong>List：</strong></p><ul><li>List是一个有序的集合，允许元素重复。</li><li>每个元素在列表中都有一个特定的索引，可以通过索引访问元素。</li><li>常见的List实现包括动态数组（例如Java中的ArrayList）和链表（例如Java中的LinkedList）。</li><li>适用于需要保留元素插入顺序并且可能包含重复元素的场景。</li></ul><p><strong>Map：</strong></p><ul><li>Map是一种键-值对（key-value pairs）的集合，每个键唯一对应一个值。</li><li>键用于查找值，因此具有快速的查找性能。</li><li>常见的Map实现包括散列映射（例如Java中的HashMap）和树映射（例如Java中的TreeMap）。</li><li>适用于需要使用键来查找值的场景，例如字典、缓存等。</li></ul><p><strong>Set：</strong></p><ul><li>Set是一个无序的集合，不允许重复元素。</li><li>与List不同，Set没有像索引一样的方式来访问元素，而是通过成员关系来判断一个元素是否在集合中。</li><li>常见的Set实现包括散列集（例如Java中的HashSet）和有序集（例如Java中的TreeSet）。</li><li>适用于需要存储一组唯一元素且不关心顺序的场景。</li></ul><p><strong>总结：</strong></p><ul><li>List适用于有序集合，元素可以重复，可以根据索引访问元素。</li><li>Map适用于键-值对的映射，键是唯一的，可以通过键来查找值。</li><li>Set适用于无序集合，元素唯一，通过成员关系来判断元素是否存在。</li></ul><p>选择使用哪种集合类型取决于具体的需求和数据操作。</p><h3 id="_2-16-数组和链表分别比较适合用于什么场景-为什么" tabindex="-1"><a class="header-anchor" href="#_2-16-数组和链表分别比较适合用于什么场景-为什么" aria-hidden="true">#</a> 2.16 数组和链表分别比较适合用于什么场景，为什么？</h3><hr><p>数组和链表是两种不同的数据结构，每种数据结构都适用于不同的场景，具体选择取决于操作的需求和性能要求。</p><p><strong>数组：</strong></p><ul><li><p><strong>适用场景：</strong></p><ol><li>当需要快速随机访问元素时，数组是一个较好的选择，因为数组中的元素是连续存储的，可以通过索引直接访问。</li><li>适用于元素数量固定且不经常插入和删除的情况。</li><li>在空间上比较紧凑，因为只需要存储元素本身和索引，没有额外的指针开销。</li></ol></li><li><p><strong>优点：</strong></p><ol><li>随机访问效率高，时间复杂度为 O(1)。</li><li>空间利用率高。</li></ol></li><li><p><strong>缺点：</strong></p><ol><li>插入和删除操作需要移动其他元素，时间复杂度为 O(n)。</li><li>在元素数量不固定、频繁插入和删除的情况下，可能会造成内存碎片。</li></ol></li></ul><p><strong>链表：</strong></p><ul><li><p><strong>适用场景：</strong></p><ol><li>当需要频繁插入和删除元素时，链表是一个较好的选择，因为插入和删除操作只需要修改指针，不需要移动其他元素。</li><li>适用于元素数量不固定的情况，可以动态扩展和缩小。</li><li>在需要在任意位置插入或删除元素的场景中。</li></ol></li><li><p><strong>优点：</strong></p><ol><li>插入和删除操作效率高，平均时间复杂度为 O(1)。</li><li>不会出现内存碎片问题。</li></ol></li><li><p><strong>缺点：</strong></p><ol><li>随机访问效率低，需要从头开始遍历，时间复杂度为 O(n)。</li><li>需要额外的指针开销，占用较多的内存。</li></ol></li></ul><p><strong>综上所述：</strong>，如果需要频繁的随机访问操作，数组是更好的选择。如果需要频繁的插入和删除操作，链表可能更适合。实际选择应该根据具体情况，权衡操作的频率、性能要求以及内存使用等因素。有时也可以通过结合两种数据结构来满足不同的需求，例如链表中存储数组，或者数组中存储链表的头指针。</p><h3 id="_2-17-说说-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_2-17-说说-concurrenthashmap" aria-hidden="true">#</a> 2.17 说说 ConcurrentHashMap</h3><hr><p>ConcurrentHashMap是Java中多线程环境下使用的线程安全的哈希表实现。它是对HashMap的线程安全扩展，专门设计用于多线程并发访问，提供了高效的并发操作和较低的锁竞争。</p><p>以下是ConcurrentHashMap的一些重要特点和关键点：</p><p><strong>1.分段锁设计：</strong> ConcurrentHashMap将内部数据结构分成了多个段（Segment），每个段类似于一个小的哈希表。每个段都有自己的锁，这意味着不同的线程可以同时访问不同的段，从而减少了锁竞争的范围，提高了并发性能。</p><p><strong>2.段内操作线程安全：</strong> 在每个段内部，操作是线程安全的，因此多个线程可以同时对不同段的数据进行操作，而不会出现线程冲突。</p><p><strong>3.扩容方式：</strong> ConcurrentHashMap在进行扩容时，不会像普通的HashMap那样需要整体复制所有数据，而是仅需要扩容其中的某个段，从而降低了扩容时的性能开销。</p><p><strong>4.迭代器一致性：</strong> ConcurrentHashMap的迭代器具有弱一致性，意味着在迭代过程中，迭代器能够反映出在迭代开始之前发生的修改，但不能保证在整个迭代过程中反映出新的修改。</p><p><strong>5.线程安全性：</strong> 虽然ConcurrentHashMap是线程安全的，但需要注意，某些操作（如putIfAbsent）虽然是原子的，但不能保证多个原子操作之间的组合是线程安全的，需要根据实际需求做好同步控制。</p><p>ConcurrentHashMap在多线程环境下提供了高性能的并发访问，适用于需要在多个线程之间共享数据，并且要求高效、线程安全的场景。然而，需要根据具体的使用场景和需求来选择合适的集合类型，以确保线程安全和性能的平衡。</p><h3 id="_2-18-java-中-arraylist-和-linkedlist-区别" tabindex="-1"><a class="header-anchor" href="#_2-18-java-中-arraylist-和-linkedlist-区别" aria-hidden="true">#</a> 2.18 Java 中 ArrayList 和 LinkedList 区别？</h3><hr><p>ArrayList和LinkedList都是Java集合框架中的列表实现，用于存储一组元素。它们在内部实现和性能特点上有一些重要区别，适用于不同的使用场景。</p><p><strong>ArrayList:</strong></p><ul><li>ArrayList是基于动态数组的实现，内部使用数组来存储元素。</li><li>插入和删除元素的操作复杂度取决于插入/删除点之后的元素数量，因为需要进行元素的移动。</li><li>随机访问元素效率高，因为可以通过索引直接访问数组中的元素。</li><li>适用于对元素进行频繁的随机访问、遍历和查找，但不太适用于频繁的插入和删除操作。</li></ul><p><strong>LinkedList:</strong></p><ul><li>LinkedList是基于双向链表的实现，每个节点都包含一个元素以及指向前一个节点和后一个节点的引用。</li><li>插入和删除元素的操作复杂度不受插入/删除点之后的元素数量影响，因为只需要调整节点的引用。</li><li>随机访问元素效率较低，因为需要从头或尾开始遍历链表，时间复杂度为O(n)。</li><li>适用于频繁的插入和删除操作，因为链表对这些操作具有较好的性能。在需要在任意位置插入或删除元素的场景中，LinkedList比ArrayList更具优势。</li></ul><p>总之，ArrayList适用于需要频繁访问和遍历元素的场景，而LinkedList适用于需要频繁插入和删除元素的场景。在选择使用哪种列表实现时，应该根据具体的操作需求和性能要求做出决策。</p><h3 id="_2-19-treemap-可排序" tabindex="-1"><a class="header-anchor" href="#_2-19-treemap-可排序" aria-hidden="true">#</a> 2.19 TreeMap（可排序）</h3><hr><p>TreeMap是Java集合框架中的一个实现，它基于红黑树数据结构来存储键-值对。红黑树是一种自平衡的二叉搜索树，具有一些特点，使得TreeMap中的键始终保持有序状态。因此，TreeMap是一个有序映射。</p><p>以下是TreeMap的排序特性：</p><p><strong>1.自然排序：</strong> 如果在创建TreeMap时未指定自定义的比较器（Comparator），那么它将使用键的自然顺序进行排序。这意味着键必须实现Comparable接口，以便能够进行比较和排序。</p><p><strong>2.自定义排序：</strong> 如果需要不同的排序方式，可以在创建TreeMap时提供一个自定义的比较器（Comparator）。这允许您根据特定的排序逻辑来决定键的顺序。</p><p><strong>3.键的有序性：</strong> 在TreeMap中，所有的键都将按照排序顺序存储在树中。这意味着当遍历TreeMap时，键的顺序将是有序的。</p><p><strong>4.查找范围：</strong> TreeMap支持按范围查找。您可以使用subMap()方法获取键的一个子集，该子集位于给定范围内。这对于需要处理某一范围内数据的场景非常有用。</p><p><strong>需要注意的是</strong>，虽然TreeMap提供了有序性，但这也意味着插入、删除和查找操作的性能可能相对于其他无序映射实现（如HashMap）略低，因为红黑树需要维护平衡。因此，在选择使用TreeMap时，需要权衡有序性和性能需求。</p><p>总之，TreeMap是一个基于红黑树的有序映射实现，可以根据键的自然顺序或自定义的比较逻辑来保持键的有序状态。</p><h3 id="_2-20-请用两个队列模拟堆栈结构" tabindex="-1"><a class="header-anchor" href="#_2-20-请用两个队列模拟堆栈结构" aria-hidden="true">#</a> 2.20 请用两个队列模拟堆栈结构？</h3><hr><p>可以使用两个队列来模拟堆栈的结构。以下是一种基于两个队列的堆栈实现方法，其中一个队列用于存储数据，另一个队列用于临时操作。这个方法确保在每次操作后，一个队列保持为空，而另一个队列保持有数据。这样可以模拟堆栈的后进先出（LIFO）特性。</p><p>假设我们有Queue接口的实现，如LinkedList可以用来作为队列的实现。我们称它们为queue1和queue2，并使用q1和q2表示它们的实例。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Queue</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TwoQueueStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> q1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> q2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">T</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Always enqueue the new element in q1</span>
        q1<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">&quot;Stack is empty&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Move all elements except the last one to q2</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>q1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            q2<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>q1<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// The last element in q1 is the element to be popped</span>
        <span class="token class-name">T</span> poppedElement <span class="token operator">=</span> q1<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Swap q1 and q2 references, so that q2 becomes empty</span>
        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> temp <span class="token operator">=</span> q1<span class="token punctuation">;</span>
        q1 <span class="token operator">=</span> q2<span class="token punctuation">;</span>
        q2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>

        <span class="token keyword">return</span> poppedElement<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> q1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> q1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的push操作将元素加入到q1中，而pop操作则将除了最后一个元素外的所有元素从q1移动到q2，然后交换q1和q2的引用，以保持q1为空。这样，每次pop操作都会返回最后一个入栈的元素，模拟了堆栈的行为。</p><p>需要注意的是，这个实现并不是线程安全的。在真正的多线程环境中，需要额外的同步措施来保证操作的原子性和正确性。</p><h3 id="_2-21-map-中的-key-和-value-可以为-null" tabindex="-1"><a class="header-anchor" href="#_2-21-map-中的-key-和-value-可以为-null" aria-hidden="true">#</a> 2.21 Map 中的 key 和 value 可以为 null？</h3><hr><p>在 Java 中，Map 中的 key 和 value 可以为 null，但是需要注意一些行为和注意事项。</p><p><strong>1.Key 可以为 null：</strong> 在大多数 Java 的 Map 实现中，key 是允许为 null 的，但是需要注意，如果你使用了相同的 null key 进行多次插入，后面的插入会覆盖前面的插入，因为 key 在 Map 中是唯一的，无法重复。</p><p><strong>2.Value 可以为 null：</strong> 同样，大多数情况下，Map 中的 value 也可以为 null。你可以使用 put(key, null) 来将 null 作为 value 存储在 Map 中。</p><p>然而，需要注意以下几点：</p><p>当使用一个 null key 或 null value 时，你必须小心处理，以免在之后的操作中出现意外的 NullPointerException。</p><p>一些特殊的 Map 实现，<strong><code>比如 Hashtable，要求 key 和 value 都不能为 null。</code></strong></p><p>总之，在 Java 中，大部分情况下，Map 的 key 和 value 都是可以为 null 的，但要注意处理可能的异常情况。</p><h3 id="_2-22-hashmap-的底层实现" tabindex="-1"><a class="header-anchor" href="#_2-22-hashmap-的底层实现" aria-hidden="true">#</a> 2.22 HashMap 的底层实现</h3><hr><p>在 Java 中，HashMap 是一种常用的哈希表实现，用于存储键值对。它基于<code>数组和链表（或红黑树）</code>的组合来实现。以下是 HashMap 的简要底层实现原理：</p><p><strong>数组桶（Buckets）：</strong> HashMap 内部维护了一个数组，被称为桶（buckets）或者哈希桶数组。每个桶可以存储一个或多个键值对。</p><p><strong>哈希函数：</strong> 当你往 HashMap 中添加一个键值对时，HashMap 首先会通过哈希函数计算键的哈希码（hash code）。哈希码是一个整数，用来确定键值对在数组中的位置。</p><p><strong>索引计算：</strong> 哈希码可能会比数组的长度大，所以 HashMap 使用哈希码的低位几个比特位来计算键值对在数组中的索引位置。这个过程可以通过对数组长度取余数来完成。</p><p><strong>解决哈希冲突：</strong> 由于不同的键可能会计算得到相同的哈希码，这就是哈希冲突。为了解决冲突，HashMap 使用链表或红黑树（自 JDK 8 开始引入）来存储具有相同索引位置的键值对。当多个键值对的哈希码相同时，它们会被链接成一个链表（或者被组织成一棵红黑树），通过比较键的值来查找目标键值对。</p><p><strong>链表和红黑树转换：</strong> 在 JDK 8 引入的 HashMap 中，当链表的长度超过一定阈值时，链表会被自动转换为红黑树，以提高查找效率。这是因为链表在长度很大时查找效率较低，而红黑树的查找效率更高。</p><p><strong>负载因子和重新哈希：</strong> HashMap 会维护一个负载因子（load factor），用来控制数组的填充程度。当数组中的键值对数量超过负载因子与数组长度的乘积时，HashMap 会自动进行扩容（重新哈希），创建一个更大的数组，并重新计算键值对的索引位置。</p><p>总之，HashMap 使用哈希码和数组结构来实现高效的键值对存储和查找。然而，在操作时需要注意选择适当的哈希函数、负载因子等参数，以及处理哈希冲突的方式，以确保 HashMap 的性能和正确性。</p><h3 id="_2-23-concurrenthashmap-和-hashtable有什么区别" tabindex="-1"><a class="header-anchor" href="#_2-23-concurrenthashmap-和-hashtable有什么区别" aria-hidden="true">#</a> 2.23 ConcurrentHashMap 和 Hashtable有什么区别</h3><hr><p>ConcurrentHashMap 和 Hashtable 都是用来存储键值对的线程安全的集合，但它们在实现和性能方面有一些重要的区别。以下是它们之间的主要区别：</p><ul><li><p><strong>锁的粒度：</strong></p><ol><li><strong>ConcurrentHashMap：</strong> ConcurrentHashMap 使用了分段锁（Segment Locking）机制。内部将数据分成多个段（Segments），每个段都维护了一个小的哈希表。在操作时，只需要锁定对应的段，不同的段可以在并发情况下独立地被操作，从而提高了并发性能。</li><li><strong>Hashtable：</strong> Hashtable 使用一个大锁来保护整个数据结构。这意味着在任何操作期间，只能有一个线程访问 Hashtable，这可能导致并发性能瓶颈。</li></ol></li><li><p><strong>性能：</strong></p><ol><li>由于 ConcurrentHashMap 使用了分段锁，它在高并发环境下能够提供更好的性能。多个线程可以同时操作不同的段，从而减少了竞争和锁争用。</li><li>Hashtable 的性能可能在高并发环境下受到限制，因为所有操作都需要争夺同一个锁。</li></ol></li><li><p><strong>扩展性：</strong></p><ol><li><strong>ConcurrentHashMap</strong> 的分段锁机制使得在并发情况下，只需要锁定特定的段，从而减少了锁的竞争。这使得 ConcurrentHashMap 在大多数并发情况下都能够提供良好的扩展性。</li><li><strong>Hashtable</strong> 的整体锁可能在高并发情况下成为瓶颈，因此它的扩展性相对较差。</li></ol></li><li><p><strong>Null 值：</strong></p><ol><li>ConcurrentHashMap 允许 key 和 value 均为 null。</li><li>Hashtable 不允许 key 和 value 为 null。</li></ol></li><li><p><strong>迭代器支持：</strong></p><ol><li>ConcurrentHashMap 的迭代器是弱一致性的，意味着在迭代过程中，如果有其他线程修改了集合，迭代器可能会看到更新前或更新后的状态，但不会抛出 ConcurrentModificationException 异常。</li><li>Hashtable 的迭代器是强一致性的，如果在迭代过程中有其他线程修改了集合，将会抛出 ConcurrentModificationException 异常。</li></ol></li></ul><p>综上所述，如果你需要在高并发环境下使用线程安全的键值存储，ConcurrentHashMap 是一个更好的选择，因为它的设计更加适应并发操作，提供了更好的性能和扩展性。</p><h3 id="_2-24-说说-arraylist-vector-linkedlist-的存储性能和特性" tabindex="-1"><a class="header-anchor" href="#_2-24-说说-arraylist-vector-linkedlist-的存储性能和特性" aria-hidden="true">#</a> 2.24 说说 ArrayList,Vector,LinkedList 的存储性能和特性</h3><hr><p>ArrayList，Vector 和 LinkedList 都是 Java 中用于存储集合元素的类，它们在存储性能和特性方面有一些区别。</p><p><strong>ArrayList:</strong></p><ul><li>ArrayList 是基于数组的动态数组实现，它可以自动增长和缩小。</li><li>存储性能较好，因为它使用连续的内存块，可以更好地利用 CPU 缓存和内存预取。</li><li>随机访问元素的性能很好，时间复杂度为 O(1)。</li><li>插入和删除元素可能会导致元素的后移和数组的重新分配，时间复杂度为 O(n)。但是，在列表的末尾进行插入和删除操作的性能相对较好。</li><li>非线程安全，在多线程环境中需要进行外部同步操作。</li></ul><p><strong>Vector:</strong></p><ul><li>Vector 也是基于数组的动态数组实现，类似于 ArrayList，但是 Vector 是线程安全的。</li><li>存储性能相对较好，但由于线程安全的要求，可能在高并发环境下性能较低。</li><li>随机访问元素的性能与 ArrayList 类似，时间复杂度为 O(1)。</li><li>插入和删除操作的性能与 ArrayList 类似，可能涉及元素的移动和数组的重新分配，时间复杂度为 O(n)。</li><li>由于线程安全的开销，一般情况下，在不需要线程安全保障的情况下，推荐使用 ArrayList 而不是 Vector。</li></ul><p><strong>LinkedList:</strong></p><ul><li>LinkedList 是基于双向链表的实现，适用于频繁的插入和删除操作。</li><li>随机访问元素的性能较差，需要遍历链表，时间复杂度为 O(n)。</li><li>插入和删除元素的性能较好，特别是在列表的开头和中间进行插入和删除操作，时间复杂度为 O(1)。</li><li>在高并发环境下可能会存在线程安全问题，需要进行外部同步操作。</li><li>LinkedList 在某些特定场景下可能比 ArrayList 或 Vector 更适合，比如需要频繁的插入和删除操作时。</li></ul><p>综合考虑，如果你需要高性能的随机访问和在列表末尾进行插入/删除操作，选择 ArrayList。如果你需要线程安全的版本，可以使用 Vector，尽管在非并发情况下可能有些性能开销。如果你需要频繁的插入和删除操作，特别是在开头和中间进行，可以考虑使用 LinkedList。</p><h3 id="_2-25-hashmap-原理-java8-做了什么改变" tabindex="-1"><a class="header-anchor" href="#_2-25-hashmap-原理-java8-做了什么改变" aria-hidden="true">#</a> 2.25 HashMap 原理，java8 做了什么改变</h3><hr><p>HashMap 是 Java 中用于存储键值对的散列表（hash table）实现，用于高效地存储和查找数据。Java 8 对 HashMap 进行了一些改变和优化，主要集中在减少哈希冲突、提高性能和减少内存占用方面。</p><p>Java 8 对 HashMap 的改变和优化包括：</p><p><strong>1.红黑树优化：</strong> 在 Java 8 中，HashMap 对哈希冲突的处理进行了优化。当链表长度超过一定阈值时，会将链表转化为红黑树，以提高查找性能。这样，在某些情况下，哈希冲突较多的情况下，仍然能够保持较好的性能。</p><p><strong>2.链表的拆分：</strong> 在早期版本的 HashMap 中，多个哈希冲突的键值对会被组织成一个链表。在 Java 8 中，如果链表长度过长，会将链表拆分成更小的链表，减少哈希冲突造成的性能问题。</p><p><strong>3.优化的哈希算法：</strong> Java 8 中改进了哈希算法，以减少哈希碰撞的可能性，从而更均匀地分布键值对。</p><p><strong>4.增强的迭代器：</strong> 在 Java 8 中，HashMap 的迭代器支持并行操作，可以同时遍历和修改 HashMap 中的元素，而不会抛出 ConcurrentModificationException 异常。</p><p><strong>5.put 操作的性能优化：</strong> Java 8 对 put 操作进行了一些性能优化，包括减少不必要的哈希计算和数组访问，以提高插入性能。</p><p><strong>6.空键处理：</strong> Java 8 改进了对空键的处理，使得空键的存储和查找更加高效。</p><p><strong>7.尽量减少扩容：</strong> 在 Java 8 中，HashMap 尽量减少扩容的次数，从而减少了数组的重新分配，提高了性能。</p><p>总的来说，Java 8 在 HashMap 中进行了许多改进，以提高性能、降低哈希冲突的影响，并且引入了更高效的数据结构（红黑树）来优化在特定情况下的查找性能。这些改进使得 HashMap 在大多数情况下都能够更好地满足性能需求。</p><h3 id="_2-26-poll-方法和-remove-方法的区别" tabindex="-1"><a class="header-anchor" href="#_2-26-poll-方法和-remove-方法的区别" aria-hidden="true">#</a> 2.26 poll()方法和 remove()方法的区别？</h3><hr><p>在 Java 中，poll() 方法和 remove() 方法都是用于从集合（如队列）中移除元素的方法，但它们在元素不存在时的行为上有所不同。</p><p><strong>poll() 方法：</strong></p><ul><li>poll() 方法用于从集合中移除并返回集合的头部（首个元素）。</li><li>如果集合为空，poll() 方法会返回 null，而不会抛出异常。</li></ul><p><strong>remove() 方法：</strong></p><ul><li>remove() 方法用于从集合中移除指定的元素。</li><li>如果集合中包含指定的元素，则会将该元素移除并返回 true。</li><li>如果集合中不包含指定的元素，则会返回 false。</li><li>此外，remove() 方法还可以用于从队列中移除并返回队列的头部元素（首个元素）。在这种情况下，如果队列为空，remove() 方法会抛出 NoSuchElementException 异常。</li></ul><p>总结：</p><ul><li>poll() 方法在集合为空时会返回 null，不会抛出异常。</li><li>remove() 方法在集合为空时会抛出 NoSuchElementException 异常，而在指定元素不存在时会返回 false。当用于队列时，remove() 方法在队列为空时会抛出异常。</li></ul><h3 id="_2-27-写一段代码在遍历-arraylist-时移除一个元素" tabindex="-1"><a class="header-anchor" href="#_2-27-写一段代码在遍历-arraylist-时移除一个元素" aria-hidden="true">#</a> 2.27 写一段代码在遍历 ArrayList 时移除一个元素</h3><hr><p>在遍历 ArrayList 时，直接在循环内部使用 remove() 方法来移除元素会引发 ConcurrentModificationException 异常，因为这会导致迭代器的状态发生变化。为了安全地在遍历时移除元素，你可以使用<code>迭代器的 remove() </code>方法来实现。这里是一个示例代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoveElementDuringIteration</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> arrayList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Integer</span> element <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 安全地移除元素</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出 [1, 2, 4, 5]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用迭代器进行遍历，当遇到元素值为 3 的时候，使用 iterator.remove() 方法安全地将该元素移除。这样可以避免并发修改异常。最后，输出的结果为 [1, 2, 4, 5]。</p><h2 id="_3-java-异常" tabindex="-1"><a class="header-anchor" href="#_3-java-异常" aria-hidden="true">#</a> 3. Java 异常</h2><h3 id="_3-1-java-中异常分为哪两种" tabindex="-1"><a class="header-anchor" href="#_3-1-java-中异常分为哪两种" aria-hidden="true">#</a> 3.1 Java 中异常分为哪两种？</h3><hr><ul><li>编译时异常</li><li>运行时异常</li></ul><h3 id="_3-2-异常的处理机制有几种" tabindex="-1"><a class="header-anchor" href="#_3-2-异常的处理机制有几种" aria-hidden="true">#</a> 3.2 异常的处理机制有几种？</h3><ul><li>异常捕捉：</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>异常抛出：throws。</li></ul><h3 id="_3-3-如何自定义一个异常" tabindex="-1"><a class="header-anchor" href="#_3-3-如何自定义一个异常" aria-hidden="true">#</a> 3.3 如何自定义一个异常</h3><hr><p>继承一个异常类，通常是 RumtimeException 或者 Exception</p><h3 id="_3-4-try-catch-fifinally-try-里有-return-finally-还执行么" tabindex="-1"><a class="header-anchor" href="#_3-4-try-catch-fifinally-try-里有-return-finally-还执行么" aria-hidden="true">#</a> 3.4 try catch fifinally，try 里有 return，finally 还执行么？</h3><hr><p>执行，并且 finally 的执行早于 try 里面的 return</p><p>结论：</p><ol><li>不管有木有出现异常，finally 块中代码都会执行；</li><li>当 try 和 catch 中有 return 时，finally 仍然会执行；</li><li>finally 是在 return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管 finally 中的代码怎么样，返回的值都不会改变，任然是之前保存的值），<code>所以函数返回值是在 finally 执行前确定的；</code></li><li>finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。</li></ol><h3 id="_3-5-excption-与-error-包结构" tabindex="-1"><a class="header-anchor" href="#_3-5-excption-与-error-包结构" aria-hidden="true">#</a> 3.5 Excption 与 Error 包结构</h3><hr><p>在 Java 中，异常（Exception）和错误（Error）是两种不同类型的可抛出（throwable）对象，用于处理程序执行过程中的异常情况。它们都继承自 Throwable 类，但在其包结构和用途方面有一些区别。</p><ul><li><p><strong>Exception（异常）：</strong></p><ol><li>Exception 是用于表示在程序运行期间可能出现的异常情况的基类。</li><li>Exception 又分为受检异常（checked exceptions）和非受检异常（unchecked exceptions）。</li><li>受检异常是指在代码编译期间就必须处理或声明抛出的异常，否则代码无法通过编译。受检异常主要继承自 java.lang.Exception。</li><li>非受检异常（也称为运行时异常）是指在运行时可能发生的异常，但在代码编译期间不强制处理或声明抛出。非受检异常主要继承自 java.lang.RuntimeException。</li><li>典型的异常包括 IOException（受检异常）和 NullPointerException（非受检异常）。</li></ol></li><li><p><strong>Error（错误）：</strong></p><ol><li>Error 是用于表示程序在执行过程中遇到的严重问题或错误，通常是由于系统问题或资源不足引起的。</li><li>Error 不应该被程序显式地捕获和处理，因为它们通常表示无法恢复的问题，例如 OutOfMemoryError（内存不足错误）或 StackOverflowError（栈溢出错误）。</li><li>典型的错误包括 OutOfMemoryError 和 StackOverflowError。</li></ol></li></ul><p>包结构示例：</p><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code>Copy code
java<span class="token operator">.</span>lang<span class="token operator">.</span>Throwable
    ├── java<span class="token operator">.</span>lang<span class="token operator">.</span>Error
    │    ├── OutOfMemoryError
    │    ├── StackOverflowError
    │    └── <span class="token operator">...</span>
    └── java<span class="token operator">.</span>lang<span class="token operator">.</span>Exception
         ├── 受检异常<span class="token operator">...</span>
         └── java<span class="token operator">.</span>lang<span class="token operator">.</span><span class="token function">RuntimeException</span> <span class="token punctuation">(</span>非受检异常<span class="token punctuation">)</span>
              ├── NullPointerException
              ├── IllegalArgumentException
              ├── IndexOutOfBoundsException
              └── <span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总之，异常和错误都是用于处理程序执行期间可能发生的异常情况，但它们在程度和用途上有所不同。异常主要用于表示程序可能处理的异常情况，而错误主要用于表示无法恢复的严重问题。</p><h3 id="_3-6-thow-与-thorws-区别" tabindex="-1"><a class="header-anchor" href="#_3-6-thow-与-thorws-区别" aria-hidden="true">#</a> 3.6 Thow 与 thorws 区别</h3><hr><p>在 Java 中，<code>throw</code> 和 <code>throws</code> 是两个关键字，用于处理异常情况，但它们的作用和用法有所不同。</p><ol><li><strong>throw:</strong><ul><li>throw 是一个关键字，用于在代码中显式地抛出一个异常对象。</li><li>当你希望在代码块中引发某个特定异常时，可以使用 throw。你可以抛出任何继承自 Throwable 的异常类的对象，包括自定义的异常类。 例子：</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>someCondition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CustomException</span><span class="token punctuation">(</span><span class="token string">&quot;This is a custom exception&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>throws:</strong><ul><li>throws 是一个关键字，用于在方法声明中指定该方法可能抛出的异常类型。</li><li>当方法可能引发某些异常，但在方法内部不处理这些异常，而是将它们传递给方法的调用者来处理时，可以使用 throws 来声明这些可能的异常。</li><li>在方法声明中使用 throws 并列出可能抛出的异常类型，可以告诉调用者该方法可能抛出哪些异常，以便调用者采取适当的处理措施。 例子：</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token class-name">String</span> fileName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结：</strong></p><ul><li>throw 用于在代码中抛出一个异常对象。</li><li>throws 用于在方法声明中指定可能抛出的异常类型，以告知方法调用者需要处理哪些异常。</li></ul><h3 id="_3-7-error-与-exception-区别" tabindex="-1"><a class="header-anchor" href="#_3-7-error-与-exception-区别" aria-hidden="true">#</a> 3.7 Error 与 Exception 区别？</h3><hr><p>在编程中，&quot;Error&quot;（错误）和&quot;Exception&quot;（异常）是两个相关但不同的概念。它们都是指程序执行过程中的问题，但在处理方式和含义上有所不同。</p><ol><li><strong>Error（错误）：</strong></li></ol><p>错误通常是指严重的问题，可能会导致程序无法继续执行或崩溃。错误通常是由于系统级别的问题，例如内存耗尽、硬件故障等引起的。程序员通常很难或无法预料和处理错误，因为它们超出了代码控制范围。例如，&quot;Out of Memory&quot;（内存不足）错误就是一种常见的错误类型。</p><ol start="2"><li><strong>Exception（异常）：</strong></li></ol><p>异常是指在程序执行过程中出现的意外情况，可能会干扰正常的程序流程。异常通常是可以被预料到的，因此程序员可以在代码中进行适当的处理。</p><p>异常可以分为两种类型：已检查异常（checked exceptions）和未检查异常（unchecked exceptions）。</p><ul><li>已检查异常：这些异常在代码中必须明确地处理，通常是通过使用try-catch语句来捕获和处理。例如，文件操作中的IOException就是一种已检查异常，因为在读写文件时可能会出现问题，需要在代码中进行处理。</li><li>未检查异常：也被称为运行时异常，通常是由于程序逻辑错误引起的，例如除以零、空指针引用等。这些异常通常不需要在代码中显式地进行处理，但仍然可以通过捕获来进行处理以防止程序崩溃。</li></ul><p>总结来说，错误是更严重且通常无法通过代码处理的问题，而异常是程序执行过程中可能出现的可预料问题，可以通过异常处理机制来进行处理，以保持程序的稳定性和可靠性。</p><h3 id="_3-8-final、finally、finalize-的区别" tabindex="-1"><a class="header-anchor" href="#_3-8-final、finally、finalize-的区别" aria-hidden="true">#</a> 3.8 final、finally、finalize 的区别？</h3><hr><p><code>final</code>、<code>finally</code> 和 <code>finalize</code> 是在Java编程中使用的三个不同的关键词，它们有不同的用途和含义：</p><ul><li><strong>final：</strong></li></ul><ol><li><p>final 是一个修饰符，用于标识类、方法或变量。</p><ul><li>当应用于类时，表示该类不能被继承，即它是一个最终类，不能有子类。</li><li>当应用于方法时，表示该方法不能被子类重写（覆盖）。</li><li>当应用于变量时，表示该变量是一个常量，一旦赋值后就不能再被修改。</li></ul></li><li><p><strong>finally：</strong></p><ul><li>finally 是一个关键字，用于在异常处理中的 try-catch-finally 结构中。</li><li>无论是否发生异常，finally 块中的代码都会被执行。这使得它适合于资源清理、文件关闭等操作，以确保资源得到正确释放。</li><li>finally 块是可选的，可以与 try 或 try-catch 配合使用。</li></ul></li><li><p><strong>finalize：</strong></p><ul><li>finalize 是一个方法，定义在 java.lang.Object 类中，可以在子类中进行重写。</li><li>在Java中，每个对象都有一个垃圾回收机制，当对象不再被引用时，垃圾回收器可能会在适当的时候自动调用对象的 finalize 方法来进行清理和释放资源。</li><li><strong>然而，从Java 9 开始，finalize 方法不再被推荐使用，因为它的调用时机不确定性很大，可能会导致一些问题。</strong></li></ul></li></ol><p><strong>简要总结：</strong></p><ol><li>final 用于声明不可变的类、方法或变量。</li><li>finally 用于异常处理中的代码块，确保其中的代码无论是否发生异常都会被执行。</li><li>finalize 是一个方法，被用于对象的垃圾回收过程，但从Java 9 开始已不推荐使用。</li></ol><h3 id="_3-9-java-异常处理机制的理解" tabindex="-1"><a class="header-anchor" href="#_3-9-java-异常处理机制的理解" aria-hidden="true">#</a> 3.9 Java 异常处理机制的理解？</h3><hr><p>异常处理的一般流程如下：</p><ol><li><strong>抛出异常（Throwing Exceptions）：</strong></li></ol><p>当程序出现异常情况时，可以使用 throw 关键字手动抛出一个异常对象。异常对象通常是异常类的一个实例，包含有关异常的信息。 2. <strong>捕获异常（Catching Exceptions）：</strong></p><p>使用 try-catch 语句块来捕获和处理异常。try 块包含可能会引发异常的代码，而在 catch 块中，可以指定要捕获的异常类型，并提供异常处理逻辑。 3. <strong>处理异常（Handling Exceptions）：</strong></p><p>在 catch 块中，可以编写代码来处理异常，例如记录日志、显示错误消息、恢复正常流程等。 4. <strong>最终处理（Finally Block）：</strong></p><p>可以使用 finally 块来包含在无论是否抛出异常的情况下都需要执行的代码。这通常用于资源释放，确保资源得到正确的清理。</p><p>异常处理的好处在于，即使程序遇到了问题，也可以通过适当的处理来保证程序的继续执行，而不会导致整个应用崩溃。然而，过多或不恰当地使用异常处理也可能导致代码的可读性和维护性下降，因此在编写代码时需要谨慎处理异常。</p><h3 id="_3-10-说出最常见的-5-个-runtimeexception" tabindex="-1"><a class="header-anchor" href="#_3-10-说出最常见的-5-个-runtimeexception" aria-hidden="true">#</a> 3.10 说出最常见的 5 个 RuntimeException？</h3><hr><p>RuntimeException 是 Java 中的一个未检查异常（unchecked exception）类别，通常是由于程序逻辑错误引起的。以下是最常见的五个 RuntimeException：</p><ol><li>NullPointerException（空指针异常）： 当试图在一个空对象上调用方法、访问成员变量或数组元素时，会引发空指针异常。例如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里会抛出 NullPointerException</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>IllegalArgumentException（非法参数异常）： 当传递给方法的参数不满足方法的要求或范围时，会引发非法参数异常。例如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> dividend<span class="token punctuation">,</span> <span class="token keyword">int</span> divisor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Divisor cannot be zero&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>ArrayIndexOutOfBoundsException（数组下标越界异常）： 当试图访问数组中不存在的索引位置时，会引发数组下标越界异常。例如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> value <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 这里会抛出 ArrayIndexOutOfBoundsException</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>ArithmeticException（算术异常）： 当进行数学运算出现问题时，比如除以零，会引发算术异常。例如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 这里会抛出 ArithmeticException</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="5"><li>ClassCastException（类转换异常）： 当试图在类型之间进行无效的类型转换时，会引发类转换异常。例如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span> <span class="token comment">// 这里会抛出 ClassCastException</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这些异常通常是由于编程错误引起的，应该通过合适的编程实践和异常处理来避免和处理这些问题。</p><p>当涉及到多线程编程时，以下是几个常见的并发相关的异常：</p><ol start="6"><li>InterruptedException（中断异常）： 当一个线程在等待或睡眠状态被中断时，会引发中断异常。这通常用于线程之间的协作和中断操作。例如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 线程在睡眠期间被中断</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7"><li>IllegalMonitorStateException（非法监视器状态异常）： 当一个线程试图在没有获得锁的情况下调用对象的 wait()、notify() 或 notifyAll() 方法时，会引发非法监视器状态异常。例如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里会抛出 IllegalMonitorStateException</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="8"><li>ConcurrentModificationException（并发修改异常）： 在使用迭代器遍历集合时，如果在遍历过程中集合被修改，会引发并发修改异常。例如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> item <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里会抛出 ConcurrentModificationException</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-java-中的-io-与-nio" tabindex="-1"><a class="header-anchor" href="#_4-java-中的-io-与-nio" aria-hidden="true">#</a> 4. Java 中的 IO 与 NIO</h2><h3 id="_4-1-字节流如何转为字符流" tabindex="-1"><a class="header-anchor" href="#_4-1-字节流如何转为字符流" aria-hidden="true">#</a> 4.1 字节流如何转为字符流?</h3><hr><p>在Java中，字节流可以通过使用字符流的适配器类来转换为字符流。适配器类是用于在不同类型的流之间进行转换的工具类。要将字节流转换为字符流，可以使用以下步骤：</p><ol><li>创建一个字节输入流（例如 FileInputStream）来读取字节数据。</li><li>使用适配器类将字节输入流转换为字符输入流。这可以通过 InputStreamReader 类来实现，它将字节流转换为字符流。</li><li>现在你可以使用字符输入流来读取字符数据。 以下是一个示例代码，演示如何将字节流转换为字符流：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">FileInputStream</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ByteToCharStreamExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Step 1: Create a byte input stream</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;byteData.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment">// Step 2: Convert byte input stream to character input stream</span>
            <span class="token class-name">InputStreamReader</span> isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>fis<span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// You can specify the character encoding</span>
            
            <span class="token comment">// Step 3: Read character data using BufferedReader</span>
            <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>isr<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">String</span> line<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们使用了 FileInputStream 来创建一个字节输入流，然后使用 InputStreamReader 将其转换为字符输入流。最后，我们使用 BufferedReader 来逐行读取字符数据。</p><p>请注意，需要指定字符编码（在上面的示例中是UTF-8）以确保正确地将字节流转换为字符流。根据实际情况，你可能需要调整代码中的文件名和字符编码。</p><h3 id="_4-2-常用-io-类有那些" tabindex="-1"><a class="header-anchor" href="#_4-2-常用-io-类有那些" aria-hidden="true">#</a> 4.2 常用 io 类有那些</h3><hr><p>在Java中，有许多常用的IO类和接口，用于处理输入和输出操作。这些类和接口位于java.io包中。以下是一些常用的IO类：</p><ol><li><p><strong>字节流（Byte Streams）：</strong></p><ul><li>InputStream 和 OutputStream：抽象基类，用于字节输入和输出操作。</li><li>FileInputStream 和 FileOutputStream：用于读取和写入文件的字节流。</li><li>ByteArrayInputStream 和 ByteArrayOutputStream：用于读取和写入字节数组的字节流。</li><li>DataInputStream 和 DataOutputStream：用于读取和写入基本数据类型的字节流。</li><li>BufferedInputStream 和 BufferedOutputStream：提供缓冲功能，提高读写效率。</li></ul></li><li><p>字符流（Character Streams）：</p><ul><li>Reader 和 Writer：抽象基类，用于字符输入和输出操作。</li><li>FileReader 和 FileWriter：用于读取和写入文件的字符流。</li><li>BufferedReader 和 BufferedWriter：提供缓冲功能，提高读写效率。</li><li>InputStreamReader 和 OutputStreamWriter：将字节流转换为字符流的适配器类。</li></ul></li><li><p>对象流（Object Streams）：</p><ul><li>ObjectInputStream 和 ObjectOutputStream：用于读取和写入Java对象的字节流。对象需要实现Serializable接口。</li></ul></li><li><p>字符编码和解码：</p><ul><li>Charset：用于表示字符编码集。</li><li>CharsetEncoder 和 CharsetDecoder：用于执行字符编码和解码操作。</li></ul></li><li><p>文件操作相关：</p><ul><li>File：用于表示文件和目录的抽象路径名。</li><li>FileReader 和 FileWriter：用于读取和写入文件的字符流。</li><li>FileInputStream 和 FileOutputStream：用于读取和写入文件的字节流。</li></ul></li><li><p>流过滤器：</p><ul><li>FilterInputStream 和 FilterOutputStream：用于添加过滤功能的装饰者类。</li><li>BufferedInputStream 和 BufferedOutputStream：提供缓冲功能，提高读写效率。</li></ul></li><li><p>其他IO相关类：</p><ul><li>PrintStream 和 PrintWriter：用于格式化输出文本。</li><li>RandomAccessFile：支持随机访问文件的类。</li></ul></li></ol><p>以上只是一些常用的IO类，还有许多其他类和接口可用于不同的IO操作。根据你的需求，可以选择适当的IO类来处理输入和输出。</p><h3 id="_4-3-如何将一个-java-对象序列化到文件里" tabindex="-1"><a class="header-anchor" href="#_4-3-如何将一个-java-对象序列化到文件里" aria-hidden="true">#</a> 4.3 如何将一个 java 对象序列化到文件里？</h3><hr><p>要将一个Java对象序列化到文件中，你可以使用ObjectOutputStream类。以下是一个简单的步骤示例：</p><ol><li>首先，确保你的Java对象类实现了Serializable接口。这是必要的，因为Serializable接口告诉Java对象可以被序列化。</li><li>创建一个FileOutputStream来将数据写入文件。</li><li>创建一个ObjectOutputStream，将其连接到FileOutputStream，以便将对象序列化并写入文件。</li><li>调用ObjectOutputStream的writeObject()方法，将你想要序列化的对象写入文件。</li><li>关闭ObjectOutputStream和FileOutputStream以释放资源。</li></ol><p>下面是一个示例代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">FileOutputStream</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">ObjectOutputStream</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Serializable</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Getters and setters...</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerializeObjectExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileOutputStream</span> fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">&quot;student.ser&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Student object has been serialized.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们创建了一个Student类，该类实现了Serializable接口。然后，我们创建一个Student对象并使用ObjectOutputStream将其序列化并写入名为&quot;student.ser&quot;的文件中。</p><p>请注意，当你序列化一个对象时，它的类和实例变量的状态都将被保存。反序列化时，可以从文件中读取对象的状态并重新构建对象。</p><p>在实际应用中，你可能需要更多的异常处理和资源管理，但上述示例演示了基本的序列化过程。</p><h3 id="_4-4-字节流和字符流的区别" tabindex="-1"><a class="header-anchor" href="#_4-4-字节流和字符流的区别" aria-hidden="true">#</a> 4.4 字节流和字符流的区别？</h3><hr><p>字节流（Byte Streams）和字符流（Character Streams）是Java中用于处理输入和输出的两种基本流类型。它们的主要区别在于处理的数据单元和数据类型：</p><ol><li><p><strong>字节流（Byte Streams）：</strong></p><ul><li>字节流以字节为单位进行输入和输出操作。</li><li>适用于处理二进制数据，如图像、音频、视频等。</li><li>InputStream 和 OutputStream 是字节流的抽象基类。</li><li>字节流不关心数据的字符编码，直接处理字节数据。</li><li>示例：FileInputStream、FileOutputStream、BufferedInputStream、BufferedOutputStream 等。</li></ul></li><li><p><strong>字符流（Character Streams）：</strong></p><ul><li>字符流以字符为单位进行输入和输出操作。</li><li>适用于处理文本数据，如文本文件中的字符。</li><li>Reader 和 Writer 是字符流的抽象基类。</li><li>字符流关心数据的字符编码，能够处理不同字符编码的文本数据。</li><li>示例：FileReader、FileWriter、BufferedReader、BufferedWriter 等。</li></ul></li><li><p><strong>主要区别总结如下：</strong></p><ul><li>数据单元：字节流以字节为单位处理，字符流以字符为单位处理。</li><li>适用数据类型：字节流适用于二进制数据，字符流适用于文本数据。</li><li>抽象基类：字节流的抽象基类是 InputStream 和 OutputStream，字符流的抽象基类是 Reader 和 Writer。</li><li>数据编码：字符流关心字符编码，可以处理不同字符编码的数据。字节流不关心字符编码，直接处理字节数据。</li></ul></li></ol><p>一般来说，如果你需要处理文本文件等字符数据，最好使用字符流，因为字符流会自动处理字符编码问题。如果你需要处理二进制数据，如图像或音频文件，那么字节流更合适。</p><h3 id="_4-5-如何实现对象克隆" tabindex="-1"><a class="header-anchor" href="#_4-5-如何实现对象克隆" aria-hidden="true">#</a> 4.5 如何实现对象克隆？</h3><hr><p>在Java中，要实现对象克隆，可以通过以下两种方式来完成：</p><p><strong>1.实现Cloneable接口并重写clone()方法：</strong></p><p>Java提供了Cloneable接口，该接口标记了一个类可以被克隆。然而，需要注意的是，Cloneable接口本身并不包含任何方法，它只是一个标记接口。要实现克隆，需要在类中重写Object类的clone()方法。重写时，通常需要调用super.clone()来得到一个浅拷贝，然后再根据需要深度复制对象的属性。</p><p>下面是一个示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token comment">// Constructor, getters, setters...</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上述示例只是浅拷贝，如果Person类包含引用类型的成员变量，那么只会复制引用而不是实际对象。</p><p><strong>2.使用拷贝构造函数或拷贝工厂方法：</strong></p><p>另一种克隆对象的方法是通过拷贝构造函数或拷贝工厂方法。在类中提供一个构造函数或静态工厂方法，接受另一个对象作为参数，然后使用传入对象的属性来初始化新对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token comment">// Constructor, getters, setters...</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">Person</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> other<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> other<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Alternatively, you can use a static factory method</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Person</span> <span class="token function">createCopy</span><span class="token punctuation">(</span><span class="token class-name">Person</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用拷贝构造函数或拷贝工厂方法时，可以根据需要执行深度复制操作。</p><p>无论使用哪种方式，需要根据对象的具体属性和需求来决定是执行浅拷贝还是深拷贝。对于深度复制，可能需要递归地克隆对象的所有引用属性。在实现深度复制时，需要小心避免循环引用和性能问题。</p><h3 id="_4-6-什么是-java-序列化-如何实现-java-序列化" tabindex="-1"><a class="header-anchor" href="#_4-6-什么是-java-序列化-如何实现-java-序列化" aria-hidden="true">#</a> 4.6 什么是 java 序列化，如何实现 java 序列化？</h3><hr><p>Java序列化是一种将Java对象转换为字节流的过程，以便可以将对象在网络上传输或者保存到文件中。反序列化则是将字节流重新转换回Java对象的过程。序列化和反序列化在分布式系统、缓存、持久化存储等场景中非常常见，它们可以用来在不同的Java应用之间传递对象，或者将对象存储到磁盘或数据库中。</p><p>要实现Java序列化，需要按照以下步骤进行操作：</p><p><strong>1. 让类实现Serializable接口：</strong></p><p>要使一个类可以被序列化，该类必须实现java.io.Serializable接口。这个接口并没有包含任何方法，只是一个标记接口，表示该类可以被序列化。如果一个类没有实现Serializable接口，那么当尝试序列化该类的对象时，会抛出java.io.NotSerializableException异常。</p><p><strong>2.定义需要序列化的字段：</strong></p><p>在类中定义需要被序列化的字段。通常，基本类型和标准库中的类（如String、ArrayList等）都是默认可序列化的。如果类包含非序列化的字段，可以使用transient关键字标记，从而在序列化过程中排除这些字段。</p><p><strong>3.使用输入输出流进行序列化和反序列化：</strong></p><p>使用ObjectOutputStream来序列化对象，使用ObjectInputStream来反序列化对象。下面是一个简单的示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerializationExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Serialization</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// Serialize an object to a file</span>
            <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">&quot;object.ser&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
            oos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Deserialization</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// Deserialize an object from a file</span>
            <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;object.ser&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Person</span> deserializedPerson <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ois<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Deserialized: &quot;</span> <span class="token operator">+</span> deserializedPerson<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，Person类需要实现Serializable接口，否则在序列化过程中会抛出异常。</p><p>需要注意的是，序列化并不适用于所有情况，例如，序列化匿名内部类、单例模式的对象等可能会有一些问题。此外，序列化也可能涉及到版本控制、安全性等方面的考虑。</p><h3 id="_4-7-nio-的缓冲区" tabindex="-1"><a class="header-anchor" href="#_4-7-nio-的缓冲区" aria-hidden="true">#</a> 4.7 NIO 的缓冲区</h3><hr><p>NIO（New I/O）是Java中提供的一种用于非阻塞I/O操作的API。NIO引入了一套新的I/O概念，其中缓冲区（Buffer）是其核心之一。NIO的缓冲区提供了一种更灵活、高效的方式来进行数据的读写操作，特别适用于处理大量数据和网络通信。</p><p>以下是关于NIO缓冲区的重要信息：</p><p><strong>1.缓冲区基本概念：</strong></p><p>缓冲区是一个有限的、线性有序的数据结构，用于存储不同类型的数据（基本类型数据、字节数组、字符数组等）。它是在内存中的一块区域，可以用于临时存储数据，然后在I/O操作中进行传输。</p><p><strong>2.缓冲区类型：</strong></p><p>Java NIO提供了以下几种类型的缓冲区：</p><ul><li>ByteBuffer：用于存储字节数据。</li><li>CharBuffer：用于存储字符数据。</li><li>ShortBuffer、IntBuffer、LongBuffer：用于存储不同大小的整数数据。</li><li>FloatBuffer、DoubleBuffer：用于存储浮点数数据。</li></ul><p><strong>3.缓冲区属性：</strong></p><p>缓冲区具有一些重要的属性，例如容量（capacity）、位置（position）、限制（limit）和标记（mark）。这些属性在进行读写操作时具有重要意义，可以帮助控制数据的处理。</p><p><strong>4.缓冲区状态：</strong></p><ul><li>容量（capacity）：缓冲区的最大存储容量。</li><li>位置（position）：下一个要读取或写入的元素索引。</li><li>限制（limit）：第一个不应该读取或写入的元素索引（limit &lt;= capacity）。</li><li>标记（mark）：一个临时的位置标记，可以在稍后回到该位置。</li></ul><p><strong>5.缓冲区操作：</strong></p><p>使用缓冲区进行读写操作需要调用相关的方法，例如put()将数据写入缓冲区，get()从缓冲区读取数据。在操作缓冲区时，位置会自动前进，直到限制位置。</p><p><strong>6.缓冲区模式：</strong></p><p>缓冲区可以处于读取模式和写入模式之一。当切换模式时，需要调用flip()方法。在读取模式下，位置被设置为缓冲区中第一个未读取的元素，限制被设置为之前位置的值；在写入模式下，位置被设置为缓冲区中当前位置，限制被设置为容量。</p><p>使用NIO缓冲区可以提高I/O操作的效率，特别是在进行大规模数据传输时。不同类型的缓冲区可以根据数据类型进行选择，以满足特定的需求。</p><h3 id="_4-8-面向-stream-和面向-buffer" tabindex="-1"><a class="header-anchor" href="#_4-8-面向-stream-和面向-buffer" aria-hidden="true">#</a> 4.8 面向 Stream 和面向 Buffer</h3><hr><p>&quot;面向Stream&quot;和&quot;面向Buffer&quot;是在处理数据时常用的两种不同的方法。它们主要涉及到数据的处理和传输方式，特别是在输入输出操作和网络通信中，这两种方法具有不同的特点和适用场景。</p><p><strong>1.面向Stream：</strong></p><p>&quot;面向Stream&quot;是指通过流（Stream）的方式来处理数据。流是一个连续的数据序列，可以是字节流或字符流。Java中的InputStream和OutputStream以及Reader和Writer等类就是典型的流处理方式的代表。这种方法适用于逐个读取或写入数据，适合于一些较小规模的数据处理，比如读取文件内容或从网络中逐个读取数据。</p><p>优点：</p><ul><li>逐个读取或写入数据，适合于流式处理。</li><li>内存使用较低，不需要一次性加载全部数据。</li></ul><p>缺点：</p><ul><li>不太适合处理大量的数据，因为需要频繁的I/O操作。</li><li>不能像缓冲区一样进行随机访问，只能顺序处理。</li></ul><p><strong>2.面向Buffer：</strong></p><p>&quot;面向Buffer&quot;是指通过缓冲区（Buffer）的方式来处理数据。缓冲区是在内存中的一块连续区域，可以一次性加载一定量的数据，然后进行随机访问、处理和传输。Java NIO中的ByteBuffer、CharBuffer等就是缓冲区的代表。这种方法适用于处理大规模数据、网络通信、文件传输等情况。</p><p>优点：</p><ul><li>能够一次性加载较大量的数据，减少I/O操作次数，提高效率。</li><li>可以进行随机访问，灵活处理数据。</li></ul><p>缺点：</p><ul><li>可能需要更多的内存，因为需要一次性加载一定量的数据到缓冲区。</li></ul><p>选择使用哪种方法取决于应用的具体需求。在某些情况下，可以将两种方法结合使用，例如，通过流将数据从磁盘读取到缓冲区，然后通过缓冲区进行分析和处理。在网络通信中，常常会使用缓冲区来处理数据的传输，因为可以有效地减少网络I/O的次数。</p><h2 id="_5-java-反射" tabindex="-1"><a class="header-anchor" href="#_5-java-反射" aria-hidden="true">#</a> 5. Java 反射</h2><h3 id="_5-1-什么是反射" tabindex="-1"><a class="header-anchor" href="#_5-1-什么是反射" aria-hidden="true">#</a> 5.1 什么是反射？</h3><hr><p>反射（Reflection）是一种在运行时检查、获取和操作类、接口、字段、方法等程序结构的能力。它允许程序在执行过程中获取有关类的信息，并且可以动态地创建对象、调用方法、访问字段等，而不需要提前在代码中硬编码这些信息。</p><p>Java的反射机制允许你在运行时获取类的各种信息，如类名、父类、实现的接口、构造函数、方法、字段等，并且可以动态地操作这些元素。Java中提供了一些反射相关的类，主要集中在java.lang.reflect包中。</p><p>反射的主要用途包括但不限于以下几点：</p><ol><li>动态创建对象： 通过反射可以在运行时创建一个类的对象，而不需要提前知道具体的类名。</li><li>动态调用方法： 可以通过方法名来动态地调用类的方法，无需在代码中直接写出方法调用。</li><li>动态访问字段： 可以通过字段名来动态地访问类的字段，读取或修改字段的值。</li><li>分析注解： 反射可以用于检查类和方法上的注解，以便在运行时执行不同的逻辑。</li><li>实现通用的代码处理工具： 例如，像ORM（对象关系映射）框架、依赖注入容器等都是基于反射实现的。</li></ol><p>尽管反射提供了一些灵活性，但它也带来了一些性能上的开销，因为反射操作通常比直接使用编译时确定的方法和字段更慢。此外，<code>由于反射涉及到运行时的元信息，编译器无法在编译时进行一些错误检查</code>，所以在使用反射时需要格外小心，以避免出现运行时错误。</p><p>总之，反射在某些场景下是非常有用的，例如在框架、工具和库中。然而，应该在需要的情况下谨慎使用，以避免降低代码的可读性和性能。</p><h3 id="_5-2-java-反射创建对象效率高还是通过-new-创建对象的效率高" tabindex="-1"><a class="header-anchor" href="#_5-2-java-反射创建对象效率高还是通过-new-创建对象的效率高" aria-hidden="true">#</a> 5.2 Java 反射创建对象效率高还是通过 new 创建对象的效率高？</h3><hr><p>在大多数情况下，直接通过 new 关键字创建对象的效率要高于使用 Java 反射来创建对象。这是因为 Java 反射涉及到更多的步骤和资源消耗，从而导致创建对象的开销增加。</p><p>下面是一些影响效率的因素：</p><ol><li>开销更高的步骤： 使用反射创建对象需要获取类的构造函数、解析参数类型等步骤，这会比直接使用 new 创建对象多出一些操作。</li><li>访问权限检查： 反射会在运行时执行访问权限检查，以确保代码具有对被创建对象的访问权限，这也会增加开销。</li><li>性能损耗： 反射调用通常比直接方法调用慢，因为它涉及到更多的动态调度和查找。</li><li>编译器优化限制： 由于反射涉及到动态查找和创建，编译器无法进行很多优化，可能导致性能下降。</li><li>代码可读性： 直接使用 new 关键字创建对象更直观，提高了代码的可读性。</li></ol><p>然而，尽管直接使用 new 创建对象效率更高，Java 反射仍然有其应用场景。例如：</p><p>在某些框架和库中，需要在运行时根据配置文件或其他因素来决定创建哪个对象时，反射是一种灵活的方式。 在工具类中，需要在不知道具体类名的情况下进行对象实例化。 在 ORM（对象关系映射）框架等场景中，需要根据数据库结构动态地创建对象。 总之，如果你在编写业务逻辑代码或者需要高性能的代码，建议尽量避免过多地使用反射，而是使用普通的 new 关键字来创建对象。只有在需要动态性和灵活性的场景下才考虑使用反射。</p><h3 id="_5-3-哪里会用到反射机制" tabindex="-1"><a class="header-anchor" href="#_5-3-哪里会用到反射机制" aria-hidden="true">#</a> 5.3 哪里会用到反射机制？</h3><hr><p>反射机制在许多情况下都有用武之地，尤其是在需要在运行时动态地检查、创建和操作类、方法、字段等信息的场景。以下是一些常见的应用场景：</p><ol><li>框架和库： 许多框架和库使用反射来实现通用的、动态的行为。例如，依赖注入框架（如Spring）可以通过反射来实现对对象的注入，ORM框架（如Hibernate）可以根据对象模型和数据库结构进行映射。</li><li>配置文件： 当需要从配置文件中加载类名、方法名等信息时，可以使用反射来动态地加载并执行这些类和方法。</li><li>单元测试： 在单元测试中，可以使用反射来测试私有方法或者内部状态。</li><li>插件系统： 使用反射可以实现插件化系统，允许动态地加载和卸载插件，而不需要重新编译代码。</li><li>动态代理： 反射可以用来创建动态代理，代理对目标对象的方法调用进行拦截和增强。</li><li>反序列化： 反序列化需要根据保存的数据重新构造对象，这通常需要使用反射。</li><li>注解处理器： 反射可以用来处理注解，根据注解来生成代码或者做其他处理。</li><li>动态代码生成： 在某些场景下，需要动态生成代码并在运行时执行，反射可以帮助实现这一点。</li><li>国际化和本地化： 反射可以用于根据当前语言环境动态选择不同的资源文件。</li></ol><p>需要注意的是，虽然反射非常有用，但也需要小心使用。反射可能会影响代码的性能和可读性，并且可能导致运行时的异常。在使用反射时，应该考虑它的适用性和代价，确保使用得当。</p><h3 id="_5-4-反射机制的优缺点" tabindex="-1"><a class="header-anchor" href="#_5-4-反射机制的优缺点" aria-hidden="true">#</a> 5.4 反射机制的优缺点</h3><hr><p>反射机制在Java编程中具有一些优点和缺点，让我们来看看它们各自是什么：</p><p><strong>优点：</strong></p><ol><li>动态性： 反射允许在运行时检查和操作类、方法、字段等信息，从而实现动态性。这对于需要在运行时根据不同情况做出决策的场景非常有用。</li><li>灵活性： 反射允许通过字符串来指定类名、方法名等，从而实现灵活性。这在需要根据配置文件或用户输入来加载不同类和执行不同方法时非常有用。</li><li>通用性： 反射可以用于实现通用的代码，例如依赖注入框架、ORM框架等。这样的框架可以处理多种不同的类和结构，而不需要针对每个具体情况编写特定的代码。</li></ol><p><strong>缺点：</strong></p><ol><li>性能开销： 反射通常比直接方法调用或对象创建更耗时。因为它需要进行额外的步骤，如权限检查、动态调度等。这可能导致应用程序的性能下降。</li><li>安全性问题： 反射可以绕过访问权限，可以在不考虑安全性检查的情况下访问和修改类的私有字段和方法。这可能导致潜在的安全漏洞。</li><li>编译时检查限制： 由于反射是在运行时进行的，编译器无法在编译时检查一些错误。这可能导致在运行时出现一些异常，而不是在编译时捕获。</li><li>代码可读性下降： 使用反射可能会降低代码的可读性，因为它会导致一些动态生成的代码，这对于阅读和理解代码来说可能更加困难。</li></ol><ul><li>难以调试： 由于反射操作是动态的，因此在调试代码时可能会导致一些困难。错误可能发生在运行时，而不是在编译时。</li></ul><p>总之，反射机制在需要动态性和灵活性的情况下是非常有用的。然而，它也需要谨慎使用，以避免潜在的性能问题、安全问题和可维护性问题。在编写代码时，应该权衡使用反射的利弊，根据具体情况决定是否使用。</p><h3 id="_5-5-动态代理是什么-有哪些应用" tabindex="-1"><a class="header-anchor" href="#_5-5-动态代理是什么-有哪些应用" aria-hidden="true">#</a> 5.5 动态代理是什么？有哪些应用？</h3><hr><p>动态代理（Dynamic Proxy）是一种设计模式，它允许你在运行时创建一个代理对象，该代理对象可以代表一个或多个真实对象，并允许你在代理对象的方法调用前后进行一些附加操作。动态代理通常通过反射机制来实现。</p><p>在 Java 中，动态代理可以通过 Java 反射和 Java Proxy API 来实现。Java 提供了 java.lang.reflect.Proxy 类，它允许你创建一个实现指定接口的代理对象。代理对象会将方法调用委托给一个实际对象，并可以在方法调用前后添加一些操作。</p><p>动态代理在以下几种应用中特别有用：</p><ul><li>AOP（面向切面编程）： 动态代理可以用于实现 AOP，其中代理对象可以在方法调用前后执行横切逻辑，如日志记录、性能监控、事务管理等。通过动态代理，可以将这些横切关注点与业务逻辑分离。</li><li>延迟加载： 动态代理可以用于实现延迟加载，即只有在真正需要时才实例化对象。例如，在 ORM 框架中，可以使用动态代理来实现按需加载数据库记录。</li><li>远程代理： 动态代理可以用于实现远程方法调用，其中代理对象可以隐藏底层网络通信的细节，使得远程方法调用看起来像是本地方法调用。</li><li>虚拟代理： 虚拟代理是一种懒加载机制，其中代理对象可以在需要时创建和初始化真实对象。这在加载大型资源或耗时对象时特别有用。</li><li>权限校验： 动态代理可以用于实现权限校验逻辑。代理对象可以在方法调用前进行权限检查，只有具有适当权限的用户才能调用方法。</li></ul><p>总之，动态代理是一种强大的技术，它可以帮助实现横切关注点的分离、延迟加载、远程调用等功能。然而，也需要注意在使用动态代理时仔细考虑性能、安全性和代码可维护性等方面的问题。</p><h3 id="_5-6-如何使用-java-的反射" tabindex="-1"><a class="header-anchor" href="#_5-6-如何使用-java-的反射" aria-hidden="true">#</a> 5.6 如何使用 Java 的反射?</h3><hr><p>Java 反射（Reflection）是一种在运行时检查和操作类、接口、字段、方法等程序元素的能力。使用反射，你可以动态地获取类的信息，调用方法，访问字段，创建实例等。下面是使用 Java 反射的一些基本步骤和示例代码：</p><ol><li><p><strong>获取 Class 对象：</strong> 首先，你需要获取要操作的类的 Class 对象。有三种常见的方式来获取 Class 对象：</p><ul><li>通过对象的 getClass() 方法：<code>Class&lt;?&gt; clazz = object.getClass();</code></li><li>通过类名获取：<code>Class&lt;?&gt; clazz = ClassName.class;</code></li><li>通过类全名获取：<code>Class&lt;?&gt; clazz = Class.forName(&quot;完整类名&quot;);</code></li></ul></li><li><p><strong>获取类的构造器：</strong> 通过 Class 对象，你可以获取类的构造器，从而实例化对象：</p></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>parameterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> instance <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>获取类的方法：</strong> 通过 Class 对象，你可以获取类的方法并调用它们：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Method</span> method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;methodName&quot;</span><span class="token punctuation">,</span> parameterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>获取类的字段：</strong> 通过 Class 对象，你可以获取类的字段并访问它们：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Field</span> field <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;fieldName&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果字段是私有的，需要设置访问权限</span>
<span class="token class-name">Object</span> value <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li><strong>调用静态方法和访问静态字段：</strong> 可以使用相似的方法来调用静态方法和访问静态字段：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Method</span> staticMethod <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;staticMethodName&quot;</span><span class="token punctuation">,</span> parameterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> staticResult <span class="token operator">=</span> staticMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Field</span> staticField <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;staticFieldName&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
staticField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> staticValue <span class="token operator">=</span> staticField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="6"><li><strong>异常处理：</strong> 在使用反射时，可能会遇到多种异常，如 <strong>NoSuchMethodException</strong>、<strong>IllegalAccessException</strong>、<strong>InvocationTargetException</strong> 等。务必进行适当的异常处理。</li></ol><p>这里是一个简单的示例，演示如何使用反射来实例化对象、调用方法和访问字段：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectionExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>

        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> instance <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Method</span> method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;printMessage&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Field</span> field <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> value <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Field value: &quot;</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello, Reflection!&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，虽然反射是强大的工具，但过度使用反射可能会导致代码更难维护和理解。在大多数情况下，应优先考虑使用正常的面向对象设计和编程实践。</p><h3 id="_5-7-java-反射的作用" tabindex="-1"><a class="header-anchor" href="#_5-7-java-反射的作用" aria-hidden="true">#</a> 5.7 java 反射的作用</h3><hr><p>Java 反射在编程中具有多种作用和用途，尽管它可能会增加代码的复杂性，但在某些情况下，它可以提供很大的灵活性和功能。以下是 Java 反射的一些常见用途和作用：</p><p>运行时获取类信息： 反射允许在运行时检查类的属性、方法、构造器等信息，这对于编写通用框架和工具非常有用，因为它们可以适应不同的类和接口。</p><ol><li><strong>动态创建对象：</strong> 反射可以通过构造器实例化对象，这在需要根据某些条件或配置动态地创建对象时非常有用。</li><li><strong>调用任意方法：</strong> 反射允许调用类中的方法，这对于需要根据用户输入来调用不同方法的场景很有帮助。</li><li><strong>访问私有成员：</strong> 反射可以绕过访问控制权限，访问并修改私有成员，但这需要小心使用，以避免破坏封装性。</li><li><strong>扩展性和插件机制：</strong> 反射可以帮助实现扩展性和插件机制，允许你在不修改主代码的情况下添加新功能。</li><li><strong>序列化和反序列化：</strong> 一些框架和库使用反射来实现对象的序列化和反序列化，将对象转换为字节流以及从字节流中恢复对象。</li><li><strong>注解处理器：</strong> 反射在编写注解处理器时非常有用，可以检查并处理注解信息，生成新的代码或修改现有代码。</li><li><strong>单元测试：</strong> 在单元测试中，你可以使用反射来测试私有方法和属性，尽管这在实际开发中并不是最佳实践。</li><li><strong>框架和框架集成：</strong> 许多框架使用反射来实现依赖注入、AOP（面向切面编程）等高级功能。</li><li><strong>动态代理：</strong> 反射在实现动态代理时非常有用，允许你在运行时为接口生成代理实例，以实现各种拦截和处理逻辑。</li></ol><p>总之，Java 反射可以在许多情况下提供更大的灵活性和动态性，但它也可能会使代码更难以理解和维护。在使用反射时，务必权衡其优点和缺点，并确保遵循最佳实践，以避免潜在的问题。</p><h2 id="_6-java-序列化" tabindex="-1"><a class="header-anchor" href="#_6-java-序列化" aria-hidden="true">#</a> 6. Java 序列化</h2><h3 id="_6-1-什么是-java-序列化" tabindex="-1"><a class="header-anchor" href="#_6-1-什么是-java-序列化" aria-hidden="true">#</a> 6.1 什么是 java 序列化？</h3><hr><p>Java 序列化是一种将对象转换为字节流的过程，以便可以在网络上传输或将对象保存到文件中，同时也可以通过反序列化将字节流重新转换回对象。序列化主要用于持久化对象状态，使其可以在不同的 JVM（Java 虚拟机）之间传输或存储。这在分布式系统、缓存、持久化存储等场景中非常有用。</p><p>要实现序列化，类需要实现 java.io.Serializable 接口，这是一个标记接口，没有定义任何方法。通过实现这个接口，类表明其对象可以被序列化。</p><p>序列化的过程将对象的状态（字段的值）转换为字节序列，以便可以在网络上传输或保存到文件中。反序列化则将字节序列重新还原为对象，恢复其状态。</p><p>以下是一个简单的示例，展示了如何在 Java 中进行序列化和反序列化：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerializationExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Serialization</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">MyClass</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, Serialization!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">FileOutputStream</span> fileOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">&quot;object.ser&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>fileOut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            fileOut<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Object has been serialized.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Deserialization</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">FileInputStream</span> fileIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;object.ser&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">ObjectInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>fileIn<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">MyClass</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyClass</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            fileIn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Object has been deserialized.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Message: &quot;</span> <span class="token operator">+</span> obj<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，虽然序列化在许多情况下很方便，但也存在一些潜在的问题，如版本兼容性、安全性和性能。在进行序列化时，应考虑类的字段是否需要被序列化，以及是否有可能在未来进行版本更改。有时，可以通过自定义序列化和反序列化方法来更好地控制对象状态的保存和恢复过程。</p><h3 id="_6-2-序列化id" tabindex="-1"><a class="header-anchor" href="#_6-2-序列化id" aria-hidden="true">#</a> 6.2 序列化id？</h3><hr><p>在 Java 的对象序列化过程中，每个实现了 java.io.Serializable 接口的类都会有一个与之关联的序列化ID（Serialization ID）。这个序列化ID用于标识类的版本，确保在反序列化时可以正确匹配类的版本。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p><strong>序列化ID是一个64位的长整型数字。在进行对象的序列化和反序列化时，Java 虚拟机会根据类的结构和成员来计算一个默认的序列化ID。如果类的结构发生了变化（比如添加、删除或修改了成员），默认的序列化ID也会随之改变，这可能会导致反序列化失败。</strong></p></div><p>为了避免这种问题，你可以显式地指定一个固定的序列化ID，以确保类的版本兼容性。这可以通过在类中添加一个名为 serialVersionUID 的静态字段来实现，如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Serializable</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">123456789L</span><span class="token punctuation">;</span>

    <span class="token comment">// Class members and methods</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，123456789L 是自定义的序列化ID。一旦你为一个类指定了序列化ID，即使类的结构发生了变化，只要序列化ID 保持不变，反序列化过程仍然可以成功。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>需要注意的是，序列化ID的值只是一个标识符，它不需要特定的格式或含义。唯一的要求是在类结构发生变化时，序列化ID 保持一致。</p></div><p>总之，序列化ID 是确保对象序列化和反序列化过程中版本兼容性的关键元素。指定自定义的序列化ID 可以帮助你更好地控制类的版本管理。</p><h3 id="_6-3-序列化用户远程对象传输" tabindex="-1"><a class="header-anchor" href="#_6-3-序列化用户远程对象传输" aria-hidden="true">#</a> 6.3 序列化用户远程对象传输</h3><hr><p>序列化用户远程对象用于在网络上传输对象的状态。这在分布式系统中非常有用，因为它允许不同的 Java 虚拟机（JVM）之间通过网络进行通信，传输对象数据。Java 提供了 RMI（远程方法调用）作为一种实现远程对象传输的机制。以下是一个简单的步骤示例：</p><ol><li><strong>定义远程接口：</strong> 首先，你需要定义一个接口，其中包含你想要在远程对象上调用的方法。这个接口需要扩展 java.rmi.Remote 接口，所有的方法都需要声明 throws RemoteException。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span></span><span class="token class-name">Remote</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span></span><span class="token class-name">RemoteException</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RemoteInterface</span> <span class="token keyword">extends</span> <span class="token class-name">Remote</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">performRemoteAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemoteException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>实现远程类：</strong> 实现远程接口的类需要继承 java.rmi.server.UnicastRemoteObject，这个类提供了一些与远程对象相关的基础设施。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span></span><span class="token class-name">RemoteException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>server<span class="token punctuation">.</span></span><span class="token class-name">UnicastRemoteObject</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoteClass</span> <span class="token keyword">extends</span> <span class="token class-name">UnicastRemoteObject</span> <span class="token keyword">implements</span> <span class="token class-name">RemoteInterface</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">RemoteClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemoteException</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">performRemoteAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemoteException</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Remote action performed!&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>创建服务器：</strong> 在服务器端，你需要创建一个 RMI 服务器来注册和提供远程对象。这可以通过 java.rmi.registry.LocateRegistry 和 java.rmi.registry.Registry 来完成。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span></span><span class="token class-name">LocateRegistry</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span></span><span class="token class-name">Registry</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Server</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">RemoteInterface</span> remoteObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RemoteClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Registry</span> registry <span class="token operator">=</span> <span class="token class-name">LocateRegistry</span><span class="token punctuation">.</span><span class="token function">createRegistry</span><span class="token punctuation">(</span><span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        registry<span class="token punctuation">.</span><span class="token function">rebind</span><span class="token punctuation">(</span><span class="token string">&quot;RemoteObject&quot;</span><span class="token punctuation">,</span> remoteObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Server is ready.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>创建客户端：</strong> 在客户端，你可以使用 java.rmi.Naming 来查找远程对象，并调用其方法。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span></span><span class="token class-name">Naming</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">RemoteInterface</span> remoteObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">RemoteInterface</span><span class="token punctuation">)</span> <span class="token class-name">Naming</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">&quot;//localhost/RemoteObject&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> result <span class="token operator">=</span> remoteObject<span class="token punctuation">.</span><span class="token function">performRemoteAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Remote result: &quot;</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>确保在执行远程调用时处理 RemoteException。此外，如果你在使用 RMI 时遇到了安全性问题，你可能需要配置安全策略文件和使用 java.security.policy 属性来授予适当的权限。</p><p>这是一个基本的 RMI 示例，实际应用中可能涉及到更多的设置和配置，如安全性、多线程处理等。</p><h3 id="_6-4-writeobject-和-readobject-自定义序列化策略" tabindex="-1"><a class="header-anchor" href="#_6-4-writeobject-和-readobject-自定义序列化策略" aria-hidden="true">#</a> 6.4 writeObject 和 readObject 自定义序列化策略</h3><hr><p>在 Java 的序列化过程中，你可以使用 writeObject 和 readObject 方法来自定义序列化和反序列化策略。这允许你在默认序列化机制之外添加自己的逻辑，以处理一些特定的需求，比如敏感数据的加密、复杂对象的定制序列化等。</p><p>要实现自定义序列化策略，你需要在要序列化的类中定义这两个方法。writeObject 方法负责将对象的状态写入到输出流中，而 readObject 方法负责从输入流中读取状态并恢复对象的状态。这两个方法需要使用默认的私有访问修饰符，以便 JVM 能够访问它们。</p><p>以下是一个简单的示例，演示了如何在一个类中实现自定义的序列化和反序列化逻辑：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">CustomSerializable</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">String</span> sensitiveData<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">CustomSerializable</span><span class="token punctuation">(</span><span class="token class-name">String</span> sensitiveData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sensitiveData <span class="token operator">=</span> sensitiveData<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name">ObjectOutputStream</span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token comment">// Encrypt sensitive data before serialization</span>
        <span class="token class-name">String</span> encryptedData <span class="token operator">=</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>sensitiveData<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>encryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">ObjectInputStream</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        in<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> encryptedData <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sensitiveData <span class="token operator">=</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>encryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Encrypt sensitive data</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Encryption logic</span>
        <span class="token keyword">return</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Decrypt sensitive data</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">decrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> encryptedData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Decryption logic</span>
        <span class="token keyword">return</span> encryptedData<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getSensitiveData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sensitiveData<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomSerializationExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">CustomSerializable</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomSerializable</span><span class="token punctuation">(</span><span class="token string">&quot;Sensitive information&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// Serialize</span>
        <span class="token class-name">FileOutputStream</span> fileOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">&quot;custom_serialization.ser&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>fileOut<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        fileOut<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Object has been serialized.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Deserialize</span>
        <span class="token class-name">FileInputStream</span> fileIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;custom_serialization.ser&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>fileIn<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CustomSerializable</span> deserializedObj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">CustomSerializable</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        fileIn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Object has been deserialized.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Decrypted sensitive data: &quot;</span> <span class="token operator">+</span> deserializedObj<span class="token punctuation">.</span><span class="token function">getSensitiveData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，writeObject 方法将敏感数据进行加密后序列化，readObject 方法从流中读取加密数据并解密恢复。需要注意的是，sensitiveData 字段被标记为 transient，这意味着默认的序列化机制将不会序列化该字段。因此，在 writeObject 方法中，我们需要自行处理这个字段的序列化和反序列化逻辑。</p><p>自定义序列化和反序列化逻辑可以根据你的需求进行调整。这使你能够在序列化过程中实现更高级的安全性、性能优化以及定制的行为。</p><h3 id="_6-5-静态变量的序列化" tabindex="-1"><a class="header-anchor" href="#_6-5-静态变量的序列化" aria-hidden="true">#</a> 6.5 静态变量的序列化？</h3><hr><div class="hint-container tip"><p class="hint-container-title">提示</p><p>在Java中，静态变量不会被序列化，因为序列化是针对对象实例的，而静态变量是与类相关联的，不属于对象的状态。当对象被序列化时，只有对象的实例变量会被序列化，静态变量不会被包含在序列化数据中。</p></div><p>这意味着，当你将一个包含静态变量的对象序列化后，静态变量的状态不会被保存，而在反序列化时，静态变量会保持其类加载时的初始值。</p><p>下面是一个示例，说明静态变量在序列化过程中的行为：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> instanceVariable<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> staticVariable <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerializationExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyClass</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        obj<span class="token punctuation">.</span>instanceVariable <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
        
        <span class="token comment">// Serialize the object</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileOutputStream</span> fileOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">&quot;object.ser&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>fileOut<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// Deserialize the object</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileInputStream</span> fileIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;object.ser&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">ObjectInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>fileIn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">MyClass</span> newObj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyClass</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Instance Variable: &quot;</span> <span class="token operator">+</span> newObj<span class="token punctuation">.</span>instanceVariable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Instance Variable: 20</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Static Variable: &quot;</span> <span class="token operator">+</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span>staticVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Output: Static Variable: 10</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，尽管序列化和反序列化了对象，但静态变量staticVariable的值仍然保持为其初始值10，因为静态变量不会受到序列化的影响。</p><h2 id="_7-java-注解" tabindex="-1"><a class="header-anchor" href="#_7-java-注解" aria-hidden="true">#</a> 7. Java 注解</h2><h3 id="_7-1-4-种标准元注解是哪四种" tabindex="-1"><a class="header-anchor" href="#_7-1-4-种标准元注解是哪四种" aria-hidden="true">#</a> 7.1 4 种标准元注解是哪四种？</h3><hr><p>在Java中，有四种标准元注解（Meta-Annotations），用于为自定义注解提供额外的信息或修改注解的行为。这些标准元注解是：</p><ol><li><p><strong>@Retention：</strong> 用于指定注解的保留策略，即注解在什么级别保留（源代码、编译时、运行时）。有三个预定义的保留策略：SOURCE（只在源代码中保留）、CLASS（在编译时保留，默认值）、RUNTIME（在运行时保留）。</p></li><li><p><strong>@Target：</strong> 用于指定注解可以应用的地方（元素类型）。它接受一个元素类型的数组作为参数，例如：ElementType.TYPE（类、接口、枚举等）、ElementType.FIELD（字段）、ElementType.METHOD（方法）、ElementType.PARAMETER（参数）、ElementType.CONSTRUCTOR（构造函数）等。</p></li><li><p><strong>@Documented：</strong> 表示注解应该被包含在生成的Java文档中。默认情况下，注解不会出现在文档中，但使用了@Documented后，注解会被包含在生成的文档中。</p></li><li><p><strong>@Inherited：</strong> 用于指示注解是否可以被子类继承。如果一个注解被标注了@Inherited，那么如果一个类使用了该注解，其子类会自动继承该注解。</p></li></ol><p>这些标准元注解可以用于创建自定义注解，并控制这些自定义注解的行为和用法。自定义注解可以通过组合这些标准元注解来定义其保留策略、适用范围等属性。</p><h2 id="_8-多线程-并发面试题" tabindex="-1"><a class="header-anchor" href="#_8-多线程-并发面试题" aria-hidden="true">#</a> 8. 多线程 &amp;并发面试题</h2><h3 id="_8-1-什么是线程" tabindex="-1"><a class="header-anchor" href="#_8-1-什么是线程" aria-hidden="true">#</a> 8.1 什么是线程？</h3><hr><p>线程是计算机科学中的一个重要概念，它是操作系统能够进行运算调度的最小单位。线程是进程内的执行单元，一个进程可以包含多个线程，它们共享进程的资源，如内存空间、文件句柄等。线程可以看作是在同一个进程内部独立运行的多个子任务。</p><p>与进程相比，线程的创建、销毁和切换开销较小，因为它们共享了很多资源，所以线程之间的通信和数据共享也更加方便。线程之间的切换通常比进程切换更加高效，因为线程不需要切换地址空间。</p><p>线程可以分为以下几种类型：</p><ol><li><p><strong>用户线程（User Thread）：</strong> 这些线程由应用程序开发人员创建和管理，操作系统对其一无所知，线程调度也由应用程序控制。</p></li><li><p><strong>内核线程（Kernel Thread）：</strong> 这些线程由操作系统内核创建和管理。操作系统可以在不同的处理器上并行执行内核线程，从而实现多任务处理。</p></li><li><p><strong>轻量级进程（LWP，Lightweight Process）：</strong> 这是一种抽象概念，它将多个用户线程映射到少量内核线程上。这样做的好处是能够在用户级实现线程的切换，减少了内核切换的开销。</p></li></ol><p>线程在多核处理器上能够充分利用并行性，提高程序的执行效率。然而，线程之间的同步和共享资源的管理可能会引发复杂的编程问题，如竞态条件（Race Condition）和死锁（Deadlock）等。因此，在使用线程进行编程时，需要谨慎考虑线程间的协作和资源管理，以确保程序的正确性和性能。</p><h3 id="_8-2-创建线程的-4-种方式" tabindex="-1"><a class="header-anchor" href="#_8-2-创建线程的-4-种方式" aria-hidden="true">#</a> 8.2 创建线程的 4 种方式</h3><hr><ol><li>继承 Thread 类</li><li>实现 Runnable 接口</li><li>Callable 接口(可以得到返回结果)</li><li>线程池方式</li></ol><h3 id="_8-3-实现多线程-thread-和-runnable-区别" tabindex="-1"><a class="header-anchor" href="#_8-3-实现多线程-thread-和-runnable-区别" aria-hidden="true">#</a> 8.3 实现多线程 Thread 和 Runnable 区别？</h3><hr><p>在Java编程语言中，你可以使用两种主要方式来实现多线程：通过继承Thread类或通过实现Runnable接口。这两种方式都允许你创建并执行多个线程，但它们在一些方面有所不同。以下是它们之间的主要区别：</p><ol><li><strong>继承Thread类：</strong></li></ol><p>这种方式需要创建一个继承自Thread类的子类，并且重写子类的run()方法来定义线程的逻辑。 通过调用子类的start()方法来启动线程。 由于Java只支持单继承，所以如果你的类已经继承了其他类，则无法使用这种方式创建线程。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程的逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>实现Runnable接口：</strong></li></ol><p>这种方式需要实现Runnable接口，并实现其中的run()方法来定义线程的逻辑。 创建一个实现了Runnable接口的类的实例，然后将其传递给Thread类的构造函数来创建线程对象。 这种方式允许你在同一个类中实现多个接口，以支持更灵活的设计。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程的逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyRunnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>总的来说，使用实现Runnable接口的方式更加灵活，因为它允许你在一个类中实现多个接口，并且不会受到Java单继承的限制。此外，通过实现Runnable接口，你还可以将相同的Runnable对象传递给多个线程，实现线程共享逻辑的目的。然而，继承Thread类的方式更加简单，适用于简单的多线程需求。</p></div><h3 id="_8-4-4种线程池" tabindex="-1"><a class="header-anchor" href="#_8-4-4种线程池" aria-hidden="true">#</a> 8.4 4种线程池</h3><hr><p>在Java中，线程池是一种用于管理和复用线程的机制，可以帮助提高多线程应用程序的性能和效率。Java标准库中提供了四种主要的线程池实现，分别是：FixedThreadPool、CachedThreadPool、ScheduledThreadPool和SingleThreadPool。</p><ol><li><strong>FixedThreadPool（固定线程池）：</strong></li></ol><p>FixedThreadPool会创建一个固定数量的线程池，线程数在池中是固定的。如果线程池中的线程都在忙碌，新的任务会被放入等待队列中，直到有线程空闲下来才会执行。适用于并发量可以预测的情况。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li><strong>CachedThreadPool（缓存线程池）：</strong></li></ol><p>CachedThreadPool会根据需要创建新线程，如果有空闲线程可用，就会重用它们，否则会创建新线程。适用于需要处理大量短期任务的情况，但需要注意防止线程数过多导致资源耗尽。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3"><li><strong>ScheduledThreadPool（计划任务线程池）：</strong></li></ol><p>ScheduledThreadPool是一个固定大小的线程池，可以用于执行定时任务和周期性任务。它可以在固定延迟或固定时间间隔内执行任务。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ScheduledExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="4"><li><strong>SingleThreadExecutor（单线程线程池）：</strong></li></ol><p>SingleThreadExecutor只创建一个单独的工作线程来执行任务，适用于需要按顺序执行任务的情况，可以保证任务之间不会并发执行。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这些线程池实现都位于java.util.concurrent包下，并通过Executors工厂类提供。虽然这些线程池在不同场景下有各自的优势，但在使用时需要根据具体情况选择合适的线程池，以避免资源浪费和性能问题。同时，使用线程池能够有效地管理线程的生命周期，降低线程创建和销毁的开销。</p><h3 id="_8-5-线程池的-7-个参数介绍" tabindex="-1"><a class="header-anchor" href="#_8-5-线程池的-7-个参数介绍" aria-hidden="true">#</a> 8.5 线程池的 7 个参数介绍</h3><hr><ul><li>corePoolSize：核心线程数量</li><li>maximumPoolSize：最大线程数量</li><li>keepAliveTime：线程存活时间</li><li>TimeUnit：线程存活时间单位</li><li><code>BlockingQueue&lt;Runnable&gt;</code>：阻塞队列</li><li>ThreadFactory：线程工厂</li><li>RejectdExecutionHandler：拒绝策略</li></ul><h3 id="_8-6-java-中的-volatile-变量" tabindex="-1"><a class="header-anchor" href="#_8-6-java-中的-volatile-变量" aria-hidden="true">#</a> 8.6 java 中的 volatile 变量</h3><hr><p>在Java中，volatile是一个关键字，用于修饰变量。volatile关键字的主要作用是告诉编译器和JVM，这个变量可能被多个线程同时访问，需要采取特定的内存同步措施，以保证对该变量的操作在多线程环境下的可见性和有序性。</p><p>在多线程环境下，普通的变量可能会由于各个线程的本地缓存以及编译器的优化，导致变量值在不同线程间不一致，从而产生意想不到的结果。而使用volatile关键字可以解决这种问题。</p><p>当一个变量被声明为volatile时，以下特性将会应用：</p><ol><li><p><strong>可见性：</strong> 当一个线程修改了volatile变量的值，这个变化会立即被其他线程看到。这是因为volatile变量的修改会立即刷新到主内存，其他线程读取时会从主内存中获取最新值。</p></li><li><p><strong>禁止指令重排序：</strong> volatile关键字会防止编译器和JVM对volatile变量的操作进行重排序，从而确保操作的顺序性。这可以防止出现意外的指令重排，保证了操作的有序性。</p></li></ol><p>然而，需要注意的是，volatile只适用于某些特定的场景，如标志位的读写、双重检查锁等。它并不能解决所有的线程安全问题，特别是不能保证原子性。如果需要进行更复杂的操作，比如多个volatile变量之间的复合操作，还是需要结合其他的同步机制，如锁或原子类。</p><p>总之，volatile关键字在多线程编程中是一个重要的工具，能够帮助开发人员确保在多线程环境下的变量访问的可见性和有序性，从而减少因并发访问导致的问题。</p><h3 id="_8-7-notify-和-notifyall-有什么区别" tabindex="-1"><a class="header-anchor" href="#_8-7-notify-和-notifyall-有什么区别" aria-hidden="true">#</a> 8.7 notify()和 notifyAll()有什么区别？</h3><hr><p>notify()和notifyAll()都是Java中用于多线程通信的方法，它们用于唤醒等待在某个对象上的线程。主要区别在于唤醒哪些线程以及如何选择使用。</p><ol><li><p><strong>notify()方法：</strong></p><ul><li>当一个线程调用某个对象的notify()方法时，它会唤醒在该对象上等待的单个线程（无法确定是哪个具体线程），并使其从等待状态进入到可运行状态。</li><li>如果有多个线程等待在该对象上，只有其中一个线程会被唤醒，但具体是哪个线程取决于线程调度器的选择。</li><li>使用notify()方法时，你需要确保只有一个等待线程与该对象相关，否则可能会导致某些线程一直处于等待状态。</li></ul></li><li><p><strong>notifyAll()方法：</strong></p><ul><li>当一个线程调用某个对象的notifyAll()方法时，它会唤醒在该对象上等待的所有线程，使它们从等待状态进入到可运行状态。</li><li>所有等待在该对象上的线程都有机会被唤醒，这可以避免一些线程永远等待下去的情况。</li><li>notifyAll()方法通常用于更加复杂的线程同步场景，例如生产者-消费者问题。</li></ul></li></ol><p>在使用notify()和notifyAll()时，需要注意以下几点：</p><ul><li>它们都必须在同步块或同步方法中使用，因为它们需要获得对象的锁才能进行操作。</li><li>调用notify()或notifyAll()不会立即释放锁，而是在同步块或同步方法执行完毕后才会释放。</li><li>唤醒的线程需要竞争对象的锁才能继续执行，所以被唤醒的线程可能不会立即执行，而是要等待锁被释放后竞争成功才能运行。</li></ul><p>根据实际的多线程通信需求，你可以选择使用notify()还是notifyAll()。一般来说，如果你只需要唤醒一个线程，且能确保只有一个线程在等待，可以使用notify()；如果需要唤醒多个线程或者不确定有多少线程在等待，应该使用notifyAll()。</p><h3 id="_8-8-sleep-和-wait-有什么区别" tabindex="-1"><a class="header-anchor" href="#_8-8-sleep-和-wait-有什么区别" aria-hidden="true">#</a> 8.8 sleep()和 wait() 有什么区别？</h3><hr><p>sleep()和wait()都是在Java多线程编程中用于控制线程行为的方法，但它们在功能和用法上有明显的区别。</p><ol><li><strong>sleep()方法：</strong><ul><li>sleep()方法是Thread类的静态方法，用于让当前线程暂停一段时间，进入阻塞状态，然后再次被唤醒。</li><li>sleep()方法不会释放线程所持有的锁，因此其他线程无法获得这个锁，不能进入同步块或方法。</li><li>sleep()方法的目的是为了暂停线程，以便控制执行时间或模拟延迟等情况。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 暂停1秒钟</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理异常</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>wait()方法：</strong><ul><li>wait()方法是Object类的方法，用于让当前线程等待，并临时释放对象的锁，进入等待状态。其他线程可以通过notify()或notifyAll()方法唤醒等待中的线程。</li><li>wait()方法需要在同步块或同步方法中调用，因为它要求线程在调用wait()方法前持有对象的锁，以便在等待状态时释放锁，允许其他线程执行同步块。</li><li>wait()方法的主要目的是实现线程间的协调与通信。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前线程等待，并释放lock对象的锁</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理异常</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总之，sleep()方法用于线程暂停一段时间，不释放锁；而wait()方法用于线程等待其他线程发出的通知，会释放锁。选择哪个方法取决于你的需求，如果需要在等待状态中释放锁以便其他线程执行，就应该使用wait()方法。</p><h3 id="_8-9-thread-类中的-start-和-run-方法有什么区别" tabindex="-1"><a class="header-anchor" href="#_8-9-thread-类中的-start-和-run-方法有什么区别" aria-hidden="true">#</a> 8.9 Thread 类中的 start() 和 run() 方法有什么区别？</h3><hr><p>在Java中，Thread类是用于创建和操作线程的基本类。Thread类中的start()方法和run()方法是与线程的启动和执行相关的两个重要方法，它们有着明显的区别：</p><ol><li><strong>start()方法：</strong><ul><li>start()方法是用于启动一个新线程的方法。当你调用一个线程对象的start()方法时，它会使得操作系统创建一个新的线程，然后调用新线程的run()方法来执行线程的任务。</li><li>start()方法会在后台进行一些准备工作，如分配资源、初始化线程等，然后立即返回，不会阻塞当前线程的继续执行。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Thread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动新线程并执行 run() 方法</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>run()方法：</strong><ul><li>run()方法是Thread类中的一个普通方法，用于定义线程的任务逻辑。当一个线程被启动并执行时，它会执行自己的run()方法中定义的代码。</li><li>直接调用run()方法只会在当前线程中执行，不会启动新的线程。这就是普通的方法调用，没有并发执行的效果。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Thread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myThread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在当前线程中执行 run() 方法，不会启动新线程</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结区别：</strong></p><ul><li>调用start()方法会启动一个新线程，并在新线程中执行run()方法。</li><li>直接调用run()方法只会在当前线程中执行run()方法的代码，没有并发效果。</li><li>在多线程编程中，通常使用start()方法来启动新线程，以实现并发执行不同线程的任务。直接调用run()方法则主要用于在当前线程中执行某个方法，而不涉及多线程操作。</li></ul><h3 id="_8-9-为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面" tabindex="-1"><a class="header-anchor" href="#_8-9-为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面" aria-hidden="true">#</a> 8.9 为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？</h3><hr><p>wait(), notify(), 和 notifyAll() 方法不在Thread类中，而是在Object类中， <strong>是因为它们涉及线程间的协调与通信，而不仅仅是单个线程的操作。</strong> 这些方法用于实现线程间的等待、唤醒和通知机制，使得多个线程能够更有效地协调工作。</p><div class="hint-container tip"><p class="hint-container-title">主要的原因包括：</p><ol><li><p><strong>通用性：</strong> wait(), notify(), 和 notifyAll() 方法是用于控制多个线程之间的交互。它们并不是线程的特定操作，而是在任何对象上都可以调用的方法。因为所有的对象都继承自Object类，所以将这些方法放在Object类中，可以保证在任何对象上都可以使用这些机制。</p></li><li><p><strong>对象级别的协调：</strong> 这些方法涉及等待和唤醒机制， <strong>需要在多个线程之间进行协调。而线程本身并不是等待或唤醒的对象，真正需要等待或唤醒的是共享资源的对象。</strong> 因此，将这些方法放在Object类中，更符合实际的线程协调和通信的需求。</p></li><li><p><strong>避免方法重写的问题：</strong> 如果将这些方法放在Thread类中，可能会导致问题。因为Thread是一个可以被继承的类，如果在子类中重写了这些方法，可能会破坏线程间的协调机制。</p></li></ol></div><p>总之，将wait(), notify(), 和 notifyAll() 方法放在Object类中更合理，因为它们是用于实现多线程间的协调和通信机制，而不仅仅是线程自身的操作。通过在Object类中定义这些方法，能够更好地支持多线程编程中的等待和唤醒机制。</p><h3 id="_8-10-共享锁和独占锁" tabindex="-1"><a class="header-anchor" href="#_8-10-共享锁和独占锁" aria-hidden="true">#</a> 8.10 共享锁和独占锁</h3><hr><p>共享锁（Shared Lock）和独占锁（Exclusive Lock，也称为排他锁）是在并发编程中用于控制多线程对共享资源访问的两种不同的锁类型。</p><ol><li><strong>共享锁（Shared Lock）：</strong></li></ol><ul><li>共享锁允许多个线程同时获得锁，并且可以同时读取共享资源，但不能进行写操作。多个线程可以并发地持有共享锁，从而实现资源的共享访问。</li><li>共享锁适用于对于多个线程可以同时读取资源，而写操作可能较少的情况，以此来提高读取操作的并发性能。</li></ul><ol start="2"><li><strong>独占锁（Exclusive Lock，或排他锁）：</strong></li></ol><ul><li>独占锁只允许一个线程获得锁，这个线程可以进行读和写操作，其他线程无法同时持有该锁。只有当独占锁释放后，其他线程才有机会获得这个锁。</li><li>独占锁适用于需要保护写操作或其他会修改资源状态的操作的情况，以确保在任何时候只有一个线程能够修改资源，避免数据不一致和竞态条件。</li><li>在不同的情况下，需要根据共享资源的访问模式来选择合适的锁类型。如果资源主要被读取，而写操作较少，可以选择共享锁。如果资源可能被修改，就需要使用独占锁来确保在任何时候只有一个线程能够修改资源。</li></ul><p>Java中的ReentrantReadWriteLock就是一种实现了共享锁和独占锁的锁机制，其中读锁是共享锁，写锁是独占锁。这种锁的选择可以根据实际需求来进行灵活的调整，以平衡资源的读写并发性能和数据的一致性。</p><h3 id="_8-11-java-中-interrupted-和-isinterruptedd-方法的区别" tabindex="-1"><a class="header-anchor" href="#_8-11-java-中-interrupted-和-isinterruptedd-方法的区别" aria-hidden="true">#</a> 8.11 Java 中 interrupted 和 isInterruptedd 方法的区别？</h3><hr><p>interrupted()和isInterrupted()是Java中与线程中断相关的两个方法，用于查询线程的中断状态。它们有以下区别：</p><ol><li><p><strong>interrupted()方法：</strong></p><ul><li>interrupted()是一个静态方法，可以直接通过Thread类调用。</li><li>当线程调用了interrupt()方法后，其中断状态会被置为true，如果在此时调用interrupted()方法，它会返回true并清除当前线程的中断状态。如果线程没有被中断，interrupted()方法会返回false。</li><li>interrupted()方法的调用会清除当前线程的中断状态，即使线程并未实际被中断。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> interruptedStatus <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回并清除中断状态</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li><strong>isInterrupted()方法：</strong><ul><li>isInterrupted()是实例方法，通过线程对象调用。</li><li>当线程调用了interrupt()方法后，其中断状态会被置为true。isInterrupted()方法用于查询线程的中断状态，但不会清除中断状态。它返回true表示线程已被中断，返回false表示线程未被中断。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> interruptedStatus <span class="token operator">=</span> thread<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查询中断状态，不清除</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">在使用这两个方法时，需要注意以下几点：</p><ul><li>interrupted()方法用于静态上下文（类级别），可以清除中断状态。</li><li>isInterrupted()方法用于实例上下文（对象级别），不会清除中断状态。</li><li>这两个方法都是线程的查询方法，不会抛出InterruptedException异常，只是查询线程的中断状态。</li></ul><p>总之，interrupted()和isInterrupted()方法都可以用于查询线程的中断状态，但前者会清除中断状态，后者不会。你可以根据具体的情况选择合适的方法来判断线程是否被中断。</p></div><h3 id="_8-12-java-中-synchronized-和-reentrantlock-有什么不同" tabindex="-1"><a class="header-anchor" href="#_8-12-java-中-synchronized-和-reentrantlock-有什么不同" aria-hidden="true">#</a> 8.12 Java 中 synchronized 和 ReentrantLock 有什么不同？</h3><hr><p>synchronized和ReentrantLock都是Java中用于实现线程同步的机制，用于确保多线程环境下对共享资源的安全访问。它们有以下不同点：</p><ol><li><p><strong>可重入性：</strong></p><ul><li>synchronized是Java内置的关键字，具有天然的可重入性。在同一个线程中，可以多次获得同一个锁，而不会被阻塞。</li><li>ReentrantLock也具有可重入性，但需要显式地调用lock()方法多次才能获得多个锁。</li></ul></li><li><p><strong>灵活性：</strong></p><ul><li>synchronized关键字的使用更为简单，自动管理锁的获取和释放，但它的灵活性相对较低，例如无法设置等待超时时间、无法尝试非阻塞获取锁等。</li><li>ReentrantLock提供了更多的灵活性，如支持公平锁和非公平锁、能够设置等待超时时间、提供了tryLock()方法用于非阻塞地获取锁等。</li></ul></li><li><p><strong>性能：</strong></p><ul><li>在低竞争情况下，synchronized通常具有较好的性能，因为它由JVM内部进行了优化。</li><li>ReentrantLock在高竞争情况下可能会有更好的性能，因为它提供了更多的控制，可以避免饥饿问题。</li></ul></li><li><p><strong>异常处理：</strong></p><ul><li>synchronized对于异常的处理相对简单，当异常发生时，锁会自动释放。</li><li>ReentrantLock需要显式地在finally块中释放锁，以确保异常发生时锁能够被释放。</li></ul></li><li><p><strong>选择权：</strong></p><ul><li>synchronized适用于简单的同步需求，易于使用，无需显式地释放锁。</li><li>ReentrantLock适用于复杂的同步需求，提供了更多的控制和功能。</li></ul></li></ol><p>总的来说，synchronized是Java内置的同步机制，使用起来更为简单，而ReentrantLock是Java提供的更灵活和功能更丰富的同步机制，适用于更复杂的并发编程场景。在选择使用哪种机制时，需要根据具体的需求和性能特点进行权衡。</p><h3 id="_8-13-有三个线程-t1-t2-t3-如何保证顺序执行" tabindex="-1"><a class="header-anchor" href="#_8-13-有三个线程-t1-t2-t3-如何保证顺序执行" aria-hidden="true">#</a> 8.13 有三个线程 T1,T2,T3,如何保证顺序执行？</h3><hr><p>要保证三个线程 T1、T2、T3 按照特定顺序执行，可以利用线程间的等待和唤醒机制来实现。以下是一种基本的方式，其中使用了Object的wait()和notify()方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SequentialExecution</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    turn <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                    lock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    turn <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
                    lock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 如果需要循环执行，可以重置 turn 并 notifyAll()</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，通过共享一个lock对象，使用turn变量来表示轮到哪个线程执行，每个线程在执行完毕后都会通过notifyAll()唤醒其他线程，从而实现了线程间的协调和顺序执行。</p><p>需要注意的是，这种方式依赖于wait()和notify()的调用顺序，以及线程调度的具体情况，可能会导致一些线程饥饿或无法执行的问题。在实际应用中，也可以考虑使用CountDownLatch等更高级的同步工具来实现类似的顺序控制。</p><p>使用 CountDownLatch 来实现三个线程 T1、T2、T3 的顺序执行，可以利用 CountDownLatch 的计数特性以及线程等待和唤醒机制。下面是使用 CountDownLatch 的示例代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SequentialExecutionWithCountDownLatch</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> latch1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> latch2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            latch1<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒T2</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                latch1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待T1完成</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                latch2<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒T3</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                latch2<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待T2完成</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-14-synchronizedmap-和-concurrenthashmap-有什么区别" tabindex="-1"><a class="header-anchor" href="#_8-14-synchronizedmap-和-concurrenthashmap-有什么区别" aria-hidden="true">#</a> 8.14 SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h3><hr><p>SynchronizedMap和ConcurrentHashMap都是Java中用于在多线程环境下操作Map的类，但它们在线程安全性和性能方面有一些区别。</p><ol><li><p><strong>SynchronizedMap：</strong></p><ul><li>SynchronizedMap是通过在每个Map操作上加锁来实现线程安全的。它是通过将普通的Map对象包装成一个线程安全的Map，使用synchronized关键字来确保多线程环境下的同步。</li><li>在每次对Map进行操作时，需要获取整个Map的锁，这会导致在高并发情况下性能较低。同时，由于锁的粒度较大，可能会影响到其他线程的并发操作。</li></ul></li><li><p><strong>ConcurrentHashMap：</strong></p><ul><li>ConcurrentHashMap是Java中专门设计用于高并发环境下的Map实现。它使用了一些复杂的数据结构和算法，以减小锁的粒度，从而提高并发性能。</li><li>ConcurrentHashMap将Map分割成多个段（Segment），每个段内部有自己的锁，不同的线程可以并发地操作不同的段。这样，在多线程环境下，不同段的操作可以并行进行，从而提高了性能。</li></ul></li></ol><div class="hint-container tip"><p class="hint-container-title">总结区别：</p><ul><li>SynchronizedMap是在每个操作上使用锁来保证线程安全，锁的粒度较大，性能相对较低。</li><li>ConcurrentHashMap使用分段锁技术，将Map分割成多个段，从而减小锁的粒度，提高了并发性能。</li><li>在实际使用中，如果需要在多线程环境下使用Map，并且对并发性能有较高要求，通常会优先选择ConcurrentHashMap。但如果并发性能要求不高，或者希望通过简单的方式实现线程安全，可以考虑使用synchronized关键字来包装Map，形成SynchronizedMap。</li></ul></div><h3 id="_8-15-什么是线程安全" tabindex="-1"><a class="header-anchor" href="#_8-15-什么是线程安全" aria-hidden="true">#</a> 8.15 什么是线程安全</h3><hr><p>线程安全（Thread Safety）是指在多线程环境下，程序或系统能够正确地处理多个线程对共享资源的并发访问，而不会引发不正确的结果或产生未定义的行为。一个线程安全的程序在多线程同时访问时，能够保证数据的一致性、正确性和可预期的行为。</p><p><strong>线程安全的实现通常要考虑以下几个方面：</strong></p><ol><li><p><strong>原子性（Atomicity）：</strong> 即一个操作要么完全执行，要么完全不执行。多线程环境下，如果某个操作涉及多个步骤，需要确保它们能够作为一个原子操作执行，以避免不一致的结果。</p></li><li><p><strong>可见性（Visibility）：</strong> 当一个线程修改了某个共享变量的值，其他线程能够立即看到修改后的值，而不是看到修改之前的值。这可以通过使用volatile关键字或锁来实现。</p></li><li><p><strong>有序性（Ordering）：</strong> 程序中的操作应该按照一定的顺序执行，以避免因为指令重排序而导致的不正确行为。volatile、锁和内存屏障等机制可以用来确保操作的有序性。</p></li><li><p><strong>竞态条件（Race Condition）：</strong> 当多个线程同时访问和修改共享资源时，可能会产生竞态条件，导致不可预期的结果。需要使用同步机制，如锁或其他并发工具，来避免竞态条件。</p></li></ol><p>线程安全是多线程编程中非常重要的概念，不正确的线程安全实现可能会导致数据损坏、死锁、饥饿等问题。开发者在编写多线程程序时，需要仔细考虑并正确地处理多线程之间的并发访问，以确保程序在不同线程间能够正确地协同工作。</p><h3 id="_8-16-重量级锁-mutex-lock" tabindex="-1"><a class="header-anchor" href="#_8-16-重量级锁-mutex-lock" aria-hidden="true">#</a> 8.16 重量级锁（Mutex Lock）</h3><hr><p>重量级锁（Mutex Lock）是一种用于线程同步的锁机制，通常实现较为复杂，适用于对线程同步性能要求不高但对并发性能有要求的情况。它的实现涉及较多的系统开销，适用于竞争激烈的情况。</p><p><strong>重量级锁的主要特点包括：</strong></p><ol><li><p><strong>内部数据结构：</strong> 重量级锁一般包含一个互斥量（mutex）和一个阻塞队列（wait queue）。互斥量用于控制多个线程对资源的访问，阻塞队列用于存储由于资源竞争而需要等待的线程。</p></li><li><p><strong>阻塞和唤醒：</strong> 当一个线程获得了重量级锁，其他线程需要访问同一资源时，会被阻塞并加入到阻塞队列中。一旦拥有锁的线程释放了锁，阻塞队列中的一个或多个线程会被唤醒，开始竞争锁。</p></li><li><p><strong>系统开销：</strong> 由于涉及到阻塞和唤醒等操作，重量级锁的实现比较复杂，而且在竞争不激烈的情况下可能会引入较大的系统开销。</p></li></ol><div class="hint-container tip"><p class="hint-container-title">重量级锁适用于以下情况</p><ul><li>线程同步需求相对较低，对并发性能要求较高的情况。</li><li>系统资源充足，能够容忍较大的线程切换和阻塞唤醒开销。</li><li>在竞争激烈的情况下，重量级锁可以提供较为公平的资源分配。</li></ul></div><p>然而，在大部分情况下，由于重量级锁的高开销，更轻量级的锁实现如偏向锁、轻量级锁和自旋锁通常能够更好地满足多线程编程的性能需求。</p><h3 id="_8-17-偏向锁" tabindex="-1"><a class="header-anchor" href="#_8-17-偏向锁" aria-hidden="true">#</a> 8.17 偏向锁</h3><hr><p>偏向锁（Biased Locking）是Java虚拟机（JVM）为了优化无竞争情况下的锁性能而引入的一种锁机制。它的设计初衷是解决在无竞争情况下传统锁（如重量级锁）引入的性能开销。</p><p>偏向锁的主要思想是，如果一个线程获得了一个锁并且没有其他线程来竞争这个锁，那么这个锁就进入了偏向模式，此时这个线程再次请求锁时，无需再次进行竞争，直接获得锁。</p><p><strong>偏向锁的特点包括：</strong></p><ol><li><strong>延迟竞争：</strong> 偏向锁会延迟竞争的过程，直到另一个线程来竞争锁，或者原来获得偏向锁的线程被回收。</li><li><strong>自动撤销：</strong> 如果在偏向模式下，其他线程尝试获取锁，偏向锁会被撤销，锁膨胀为重量级锁，其他线程就可以进行正常的竞争。</li><li><strong>适用场景：</strong> 偏向锁适用于多线程环境下，大部分情况下只有一个线程访问同步块的场景。这在很多情况下是成立的，因为在实际程序中，锁通常会被多个线程重复地获得。</li></ol><div class="hint-container warning"><p class="hint-container-title">注意</p><p>偏向锁的引入减少了无竞争情况下的性能开销，但在多线程竞争激烈的情况下，偏向锁可能会带来额外的性能开销，因为它需要不断地检查锁的状态。当竞争变得激烈时，偏向锁会自动升级为重量级锁，以保证正确的线程同步。</p></div><p>需要注意的是，偏向锁在JVM中的具体实现可能会因不同的版本而有所不同。</p><h3 id="_8-18-java-线程池中-submit-和-execute-方法有什么区别" tabindex="-1"><a class="header-anchor" href="#_8-18-java-线程池中-submit-和-execute-方法有什么区别" aria-hidden="true">#</a> 8.18 Java 线程池中 submit() 和 execute()方法有什么区别？</h3><hr><p>在Java线程池中，submit()和execute()方法都用于向线程池提交任务，但它们有一些区别：</p><ol><li><strong><code>submit()方法：</code></strong><ul><li>submit()方法是ExecutorService接口中定义的方法，返回一个Future对象，用于表示任务的执行结果。</li><li>submit()方法可以接受Runnable或Callable类型的任务。</li><li>submit()方法可以捕获任务执行过程中抛出的异常，并通过Future对象的get()方法抛出异常或返回结果。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong><code>execute()方法：</code></strong><ul><li>execute()方法是Executor接口中定义的方法，没有返回值，无法获得任务的执行结果。</li><li>execute()方法只能接受Runnable类型的任务。</li><li>execute()方法不能捕获任务执行过程中抛出的异常，因此需要在任务内部自行处理异常。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">综上所述</p><ul><li>submit()方法比execute()方法更为灵活，因为它不仅可以接受Runnable任务，还可以接受Callable任务，并且能够获得任务的执行结果或捕获异常。</li><li>execute()方法更为简单，适用于不需要关心任务的返回结果的场景。通常情况下，如果需要获取任务的执行结果或捕获异常，优先选择使用submit()方法。</li></ul></div><h3 id="_8-19-说说自己是怎么使用-synchronized-关键字-在项目中用到了吗-synchronized-关键字最主要的三种使用方式" tabindex="-1"><a class="header-anchor" href="#_8-19-说说自己是怎么使用-synchronized-关键字-在项目中用到了吗-synchronized-关键字最主要的三种使用方式" aria-hidden="true">#</a> 8.19 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗 synchronized 关键字最主要的三种使用方式</h3><hr><p>synchronized关键字主要用于保护多线程环境下的共享资源，以确保线程安全。以下是synchronized关键字的三种主要使用方式：</p><ol><li><strong>实例方法同步：</strong></li></ol><p>在方法前使用synchronized关键字，确保同一实例对象的不同线程无法同时进入同步方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">synchronizedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 同步代码块</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>代码块同步（实例锁）：</strong> 使用synchronized关键字包裹一个代码块，锁住的是指定的实例对象，只有获得锁的线程才能进入同步代码块。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 同步代码块</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>静态方法同步（类锁）：</strong> 在静态方法前使用synchronized关键字，锁住的是整个类的Class对象，防止不同实例的线程同时进入同步方法。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">staticSynchronizedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 同步代码块</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在项目中，synchronized关键字常用于以下场景：</p><ul><li><strong>多线程访问共享资源：</strong> 当多个线程需要共同访问某个共享资源，如共享变量、数据结构等时，使用synchronized确保线程间的操作是安全的。</li><li><strong>线程安全类的实现：</strong> 在设计并发安全的自定义类时，使用synchronized来保护其中的状态，以防止竞态条件等问题。</li><li><strong>防止死锁：</strong> 在多个线程之间存在相互等待的情况下，使用synchronized来确保获取锁的顺序，从而避免死锁问题。</li></ul><p>需要注意，虽然synchronized可以解决线程安全问题，但过度使用可能会影响性能，因为它会引入线程间的竞争和等待。在某些情况下，更轻量级的同步机制如java.util.concurrent包中的类可能更适合高性能的并发编程。</p><h3 id="_8-20-什么是线程安全-vector-是一个线程安全类吗" tabindex="-1"><a class="header-anchor" href="#_8-20-什么是线程安全-vector-是一个线程安全类吗" aria-hidden="true">#</a> 8.20 什么是线程安全？Vector 是一个线程安全类吗？</h3><hr><p>线程安全（Thread Safety）是指在多线程环境下，程序或系统能够正确地处理多个线程对共享资源的并发访问，而不会引发不正确的结果或产生未定义的行为。一个线程安全的程序在多线程同时访问时，能够保证数据的一致性、正确性和可预期的行为。</p><p>关于Vector，它是Java中的一个线程安全的类，是一个动态数组，类似于ArrayList，但相对于ArrayList来说，Vector提供了一些同步机制以确保线程安全。</p><p><strong>Vector是线程安全的主要原因在于它的方法都使用了synchronized关键字来进行同步</strong> ，这意味着在多线程环境下，多个线程可以安全地对Vector进行读取和写入操作，不会出现竞态条件等问题。然而，这也导致了在高并发情况下的性能相对较低，因为synchronized操作可能引入较大的开销。</p><p>需要注意的是，虽然Vector是线程安全的，但在现代Java中，推荐使用ArrayList的线程安全替代方案，如Collections.synchronizedList(new ArrayList&lt;&gt;())或CopyOnWriteArrayList。这些替代方案可以在多线程环境下提供较好的性能和更灵活的同步机制。</p><h3 id="_8-21-如何停止一个正在运行的线程" tabindex="-1"><a class="header-anchor" href="#_8-21-如何停止一个正在运行的线程" aria-hidden="true">#</a> 8.21 如何停止一个正在运行的线程</h3><hr><p>停止一个正在运行的线程在多线程编程中需要谨慎处理，因为直接强制停止线程可能会导致资源泄漏、数据不一致等问题。在Java中，推荐使用协作的方式来安全地停止线程。</p><p>以下是一种常见的方式来停止一个线程：</p><ol><li><strong>使用标志位：</strong> 在线程内部使用一个标志位来控制线程是否继续执行。当外部需要停止线程时，设置标志位为true，线程在合适的时机检查标志位并主动退出。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>isRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 线程执行的任务</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在外部调用 stop 方法来停止线程</span>
<span class="token class-name">MyRunnable</span> myRunnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>myRunnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
myRunnable<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>使用interrupt()方法：</strong> 调用线程的interrupt()方法来中断线程。线程在适当的时候会检查是否被中断，然后做出响应。需要注意，这并不是强制停止线程，而是一种更优雅的终止线程的方式。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 线程执行的任务</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在外部调用 interrupt 方法来中断线程</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，直接调用线程的stop()方法是不推荐的，因为它可能导致资源泄漏或数据不一致。另外，一些线程可能会阻塞在I/O或其他操作上，使用标志位或interrupt()方法可以更好地处理这种情况。</p><h3 id="_8-22-线程基本方法" tabindex="-1"><a class="header-anchor" href="#_8-22-线程基本方法" aria-hidden="true">#</a> 8.22 线程基本方法</h3><hr><p>在Java中，线程类java.lang.Thread提供了一些基本的方法，用于控制和管理线程的行为。以下是一些常用的线程基本方法：</p><ol><li><strong>start()方法：</strong></li></ol><p>用于启动线程，使线程进入可运行状态（Runnable）。一旦线程进入可运行状态，系统会自动调度线程，调用线程的run()方法执行任务。</p><ol start="2"><li><strong>run()方法：</strong></li></ol><p>run()方法是线程的主体，包含了线程要执行的代码逻辑。当线程被调度并处于可运行状态时，会执行run()方法中的代码。</p><ol start="3"><li><strong>sleep(long millis)方法：</strong></li></ol><p>使线程进入阻塞状态，暂停执行一段时间。millis参数指定线程要休眠的毫秒数。sleep()可能会抛出InterruptedException异常。</p><ol start="4"><li><strong>yield()方法：</strong></li></ol><p>提示线程调度器放弃当前线程的CPU执行时间，将CPU资源让给其他线程。但并不能保证线程会立即释放CPU。</p><ol start="5"><li><strong>join()方法：</strong></li></ol><p>等待调用join()方法的线程结束。如果在另一个线程上调用了join()方法，当前线程将等待被调用线程执行完毕。</p><ol start="6"><li><strong>interrupt()方法：</strong></li></ol><p>用于中断线程。调用interrupt()方法会设置线程的中断标志，线程在适当时机检查该标志来决定是否中断执行。</p><ol start="7"><li><strong>isInterrupted()方法：</strong></li></ol><p>用于查询线程的中断状态。返回true表示线程已被中断，返回false表示线程未被中断。</p><ol start="8"><li><strong>currentThread()静态方法：</strong></li></ol><p>返回当前正在执行的线程的引用。</p><ol start="10"><li><strong>setName(String name)和getName()方法：</strong></li></ol><p>用于设置和获取线程的名字。方便在调试和日志输出时识别线程。</p><p>以上只是一些基本的线程方法，Java还提供了其他更多用于线程管理和同步的方法，如synchronized关键字、wait()和notify()等。在多线程编程时，了解这些方法的使用和行为非常重要。</p><h2 id="_9-jvm" tabindex="-1"><a class="header-anchor" href="#_9-jvm" aria-hidden="true">#</a> 9. JVM</h2><h3 id="_9-1-jvm-运行时内存-内存模型" tabindex="-1"><a class="header-anchor" href="#_9-1-jvm-运行时内存-内存模型" aria-hidden="true">#</a> 9.1 JVM 运行时内存(内存模型)</h3><hr><p>线程独占：</p><ul><li>栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8大基础类型加上一个应用类型，所以还是一个指向地址的指针。</li><li>本地方法栈：主要为 Native 方法服务</li><li>程序计数器：记录当前线程执行的行号，执行Native 方法时 , 程序计数器为空 .</li></ul><p>线程共享：</p><ul><li>堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配。当堆没有可用空间时 , 会抛出 OOM 异常 . 根据对象的存活周期不同 ,JVM 把对象进行分代管理 , 由垃圾回收器进行垃圾的回收管理</li><li>方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据。1.7的永久代和 1.8 的元空间都是方法区的一种实现</li></ul><figure><img src="`+p+`" alt="JVM内存模型" tabindex="0" loading="lazy"><figcaption>JVM内存模型</figcaption></figure><h3 id="_9-2-64-位-jvm-中-int-的长度是多数" tabindex="-1"><a class="header-anchor" href="#_9-2-64-位-jvm-中-int-的长度是多数" aria-hidden="true">#</a> 9.2 64 位 JVM 中，int 的长度是多数？</h3><hr><p>在64位的JVM中，int 的长度仍然是32位，即4个字节。这是因为 int 类型在Java规范中定义为32位有符号整数，无论JVM运行在32位还是64位的系统上，int 类型的长度都保持不变。不同位数的JVM主要影响指针和引用的大小，而基本数据类型如 int、long、float 和 double 的大小在不同位数的JVM上保持一致。</p><h3 id="_9-3-新生代、老年代、永久代" tabindex="-1"><a class="header-anchor" href="#_9-3-新生代、老年代、永久代" aria-hidden="true">#</a> 9.3 新生代、老年代、永久代</h3><hr><p>在Java虚拟机的堆内存中，内存空间被划分为不同的区域，用于不同类型的对象分配和垃圾回收。新生代、老年代和永久代（或在Java 8及以后的版本中是元数据区）是这些区域的主要部分。</p><ol><li><p><strong>新生代（Young Generation）：</strong> 新生代是堆内存的一部分，它主要用于存放新创建的对象。新生代又被划分为三个区域：Eden区和两个Survivor区（通常称为From区和To区）。新创建的对象首先会被分配到Eden区，然后经过一轮或多轮垃圾回收后，仍然存活的对象会被移动到Survivor区。在Survivor区中，经过一段时间的存活后，对象最终会被晋升到老年代。</p></li><li><p><strong>老年代（Old Generation）：</strong> 老年代用于存放存活时间较长的对象。当对象在新生代中经过多次垃圾回收仍然存活时，它们会被晋升到老年代。老年代的垃圾回收相对较少，因为其中的对象寿命较长，所以垃圾回收频率较低。</p></li><li><p><strong>永久代（Permanent Generation，Java 8之前的版本）：</strong> 永久代用于存放类的元数据、常量池、静态变量、即时编译器生成的代码等。在Java 8及以前的版本中，永久代可能会导致一些问题，如内存溢出。为了解决这些问题，Java 8引入了元数据区（Metaspace）作为代替，它不再将元数据存放在堆中，而是使用本地内存。</p></li></ol><p>需要注意的是，虽然术语“永久代”在Java 8及以后的版本中已被废弃，但为了与旧有的资料保持一致，人们仍然可能会使用这个术语。在Java 8及以后的版本中，用于存放类的元数据和相关信息的区域被称为元数据区（Metaspace）或称为“元空间”。</p><p>这些不同的代（区域）的划分和管理有助于优化内存使用和垃圾回收的性能。不同的垃圾回收算法和策略会在新生代和老年代之间进行调整，以满足不同对象的寿命特性。</p><h3 id="_9-4-怎样通过-java-程序来判断-jvm-是-32-位-还是-64-位" tabindex="-1"><a class="header-anchor" href="#_9-4-怎样通过-java-程序来判断-jvm-是-32-位-还是-64-位" aria-hidden="true">#</a> 9.4 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</h3><hr><p>你可以通过Java程序来判断JVM是32位还是64位。以下是一种可以实现的方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JVMBitCheck</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> arch <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;os.arch&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;OS Architecture: &quot;</span> <span class="token operator">+</span> arch<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">String</span> bitness <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;sun.arch.data.model&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;JVM Bitness: &quot;</span> <span class="token operator">+</span> bitness<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例程序中，我们使用了System.getProperty方法来获取两个系统属性：</p><p>os.arch：该属性返回操作系统的体系结构，通常是&quot;amd64&quot;表示64位，&quot;x86&quot;表示32位。</p><p>sun.arch.data.model：该属性返回JVM的位数，如果是&quot;64&quot;，表示JVM是64位的，如果是&quot;32&quot;，表示JVM是32位的。</p><p>通过输出这两个属性的值，你可以确定JVM的位数。请注意，这种方法的可移植性可能会受到限制，因为它依赖于系统属性的名称和返回值。在不同的JVM实现中，这些属性的名称和用法可能会有所不同。</p><h3 id="_9-5-分代收集算法" tabindex="-1"><a class="header-anchor" href="#_9-5-分代收集算法" aria-hidden="true">#</a> 9.5 分代收集算法</h3><hr><p>分代垃圾收集算法是Java虚拟机中用于管理堆内存的一种策略，它根据对象的生命周期将堆内存分为不同的代（区域），并针对不同代使用不同的垃圾收集算法，以提高垃圾回收的效率。通常分为新生代（Young Generation）和老年代（Old Generation），有时还包括永久代（或元数据区）。</p><p>以下是两个主要的分代垃圾收集算法：</p><ol><li><strong>新生代收集算法：</strong></li></ol><ul><li>复制算法（Copying Algorithm）： 这是新生代最常用的垃圾收集算法。新生代被分为一个Eden区和两个Survivor区（From和To区）。在每次垃圾回收时，将存活的对象从Eden区和一个Survivor区复制到另一个Survivor区，然后清空原来的Eden区和使用过的Survivor区。该算法的优点是简单高效，适用于大部分新生代的情况。</li><li>标记-压缩算法（Mark-Compact Algorithm）： 在一些情况下，对象的存活率较高，使用复制算法会导致较大的空间浪费。标记-压缩算法在标记-清除算法的基础上，将存活的对象压缩到内存的一端，从而减少碎片化。</li></ul><ol start="2"><li><strong>老年代收集算法：</strong></li></ol><ul><li>标记-清除算法（Mark-Sweep Algorithm）： 这是最基本的老年代收集算法。首先标记所有存活的对象，然后清除所有未标记的对象。这会产生内存碎片，影响后续对象的分配。</li><li>标记-压缩算法（Mark-Compact Algorithm）： 与新生代类似，老年代也可以使用标记-压缩算法来解决内存碎片问题。该算法在标记阶段找到存活对象，并将它们压缩到内存的一端，从而消除碎片。</li></ul><p>要选择合适的垃圾收集算法和策略，需要考虑应用程序的特性、对象的生命周期以及性能需求。Java虚拟机提供了不同的垃圾收集器，如Serial、Parallel、CMS、G1等，它们在不同场景下有不同的优势。通过合理的配置和选择，可以实现更高效的内存管理和垃圾回收。</p><figure><img src="`+o+`" alt="垃圾回收模型" tabindex="0" loading="lazy"><figcaption>垃圾回收模型</figcaption></figure><h3 id="_9-6-jre、jdk、jvm-及-jit-之间有什么不同" tabindex="-1"><a class="header-anchor" href="#_9-6-jre、jdk、jvm-及-jit-之间有什么不同" aria-hidden="true">#</a> 9.6 JRE、JDK、JVM 及 JIT 之间有什么不同？</h3><hr><p>JRE、JDK、JVM和JIT是与Java编程相关的术语，它们分别代表不同的概念和组件。</p><p><strong>JRE（Java Runtime Environment）：</strong> JRE是Java运行时环境，它是用于在计算机上执行Java程序的一套软件包。JRE包括Java虚拟机（JVM）以及支持Java程序所需的类库、资源和其他运行时组件。当你想要运行一个已编译的Java程序时，只需安装JRE即可，因为它提供了运行Java程序所需的一切。</p><p><strong>JDK（Java Development Kit）：</strong> JDK是Java开发工具包，它是用于开发Java应用程序的一套软件包。JDK包括JRE，但还附带了编译器（javac）、调试器（jdb）、各种开发工具和其他用于开发Java程序的组件。如果你打算开发Java应用程序，你需要安装JDK，因为它提供了编写、编译和调试Java程序所需的工具和库。</p><p><strong>JVM（Java Virtual Machine）：</strong> JVM是Java虚拟机，它是Java程序的运行时环境。JVM负责将Java源代码编译成字节码，并在运行时执行这些字节码。它还管理着程序的内存、垃圾回收、线程等。JVM是跨平台的，因此可以在不同的操作系统上运行相同的Java程序，只需针对不同平台提供对应的JVM。</p><p><strong>JIT（Just-In-Time Compiler）：</strong> JIT是即时编译器，是JVM的一部分。JIT负责将字节码转换为本地机器代码，以便在运行时更高效地执行。JIT在程序运行期间动态地将热点代码（频繁执行的代码块）编译成机器代码，从而提高程序的执行速度。</p><div class="hint-container tip"><p class="hint-container-title">总结来说</p><ul><li>JRE是用于运行Java程序的环境，包括JVM和运行时库。</li><li>JDK是用于开发Java程序的工具包，包括JRE以及开发工具和库。</li><li>JVM是Java程序的运行时环境，负责执行字节码。</li><li>JIT是JVM的组成部分，负责将字节码编译为本地机器代码，以提高执行效率。</li></ul></div><h3 id="_9-7-java-强引用、软引用、弱引用、虚引用" tabindex="-1"><a class="header-anchor" href="#_9-7-java-强引用、软引用、弱引用、虚引用" aria-hidden="true">#</a> 9.7 JAVA 强引用、软引用、弱引用、虚引用</h3><hr><p>在Java中，引用是一种机制，用于控制垃圾回收器对对象的处理方式。根据引用的强度和特性，可以分为四种类型：强引用、软引用、弱引用和虚引用。</p><p><strong>强引用（Strong Reference）：</strong> 强引用是最普通的引用类型。当一个对象具有强引用时，垃圾回收器不会回收该对象，即使内存不足也不会回收。只有在没有任何强引用指向一个对象时，该对象才会被判定为可回收。</p><p><strong>软引用（Soft Reference）：</strong> 软引用用于描述还有一些强引用指向对象，但在内存不足时，垃圾回收器可以选择性地回收软引用指向的对象。这使得软引用特别适用于缓存等场景，可以在内存不足时释放一些缓存对象，以避免OutOfMemoryError。</p><p><strong>弱引用（Weak Reference）：</strong> 弱引用更弱于软引用。如果一个对象只具有弱引用，那么在下一次垃圾回收时，无论内存是否足够，都会被回收。弱引用通常用于构建对象的缓存，但不会阻止被缓存对象被回收。</p><p><strong>虚引用（Phantom Reference）：</strong> 虚引用是最弱的引用类型，几乎没有引用力度。它用于跟踪对象被垃圾回收器回收的活动，但本身并不能通过虚引用来获取对象。虚引用通常与一个ReferenceQueue关联，当虚引用指向的对象被回收时，会将引用添加到关联的ReferenceQueue中。</p><p>这些引用类型的使用取决于应用程序的需求。强引用适用于那些需要确保对象不被回收的场景，而软引用和弱引用则适用于需要更灵活的内存管理的场景，虚引用则主要用于监控对象回收的情况。</p><h3 id="_9-8-怎么获取-java-程序使用的内存-堆使用的百分比" tabindex="-1"><a class="header-anchor" href="#_9-8-怎么获取-java-程序使用的内存-堆使用的百分比" aria-hidden="true">#</a> 9.8 怎么获取 Java 程序使用的内存？堆使用的百分比？</h3><hr><p>可以使用命令行工具来获取Java程序的内存使用情况和堆的使用百分比。以下是一些常用的命令和工具：</p><ol><li><strong>jstat：</strong> jstat命令是Java提供的一个用于监控Java应用程序的工具，它可以用来获取各种与垃圾回收相关的统计数据，包括堆内存的使用情况。以下是获取堆内存使用的示例命令：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>jstat <span class="token parameter variable">-gc</span> <span class="token operator">&lt;</span>process_id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中 <code>&lt;process_id&gt;</code> 是你要监控的Java进程的进程ID。运行这个命令后，你会得到包括堆内存的各种统计数据。</p><ol start="2"><li><strong>jmap：</strong> jmap命令可以用来生成Java进程的内存快照（heap dump）。通过分析这些快照，你可以了解Java程序的内存使用情况。以下是获取内存快照的示例命令：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>jmap <span class="token parameter variable">-dump:format</span><span class="token operator">=</span>b,file<span class="token operator">=</span>heapdump.hprof <span class="token operator">&lt;</span>process_id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这将在当前目录下生成一个名为 heapdump.hprof 的内存快照文件。</p><ol start="3"><li><strong>top 和 ps：</strong> 使用常规的系统监控工具，如 top 或 ps，可以查看Java进程的内存使用情况。以下是获取Java进程内存使用情况的示例命令：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">top</span> <span class="token parameter variable">-p</span> <span class="token operator">&lt;</span>process_id<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ps</span> <span class="token parameter variable">-p</span> <span class="token operator">&lt;</span>process_id<span class="token operator">&gt;</span> <span class="token parameter variable">-o</span> rss,vsz
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这些命令将显示Java进程的实际内存占用（rss）和虚拟内存大小（vsz）。</p><p>这些命令可以在终端中执行，以获取Java程序在Linux系统上的内存使用情况。注意，<code>&lt;process_id&gt;</code> 是目标Java进程的进程ID。</p><h3 id="_9-9-描述一下-jvm-加载-class-文件的原理机制" tabindex="-1"><a class="header-anchor" href="#_9-9-描述一下-jvm-加载-class-文件的原理机制" aria-hidden="true">#</a> 9.9 描述一下 JVM 加载 class 文件的原理机制</h3><hr><p>其中 验证 , 准备 , 解析 合称链接</p><ul><li>加载： 通过类的完全限定名 , 查找此类字节码文件 , 利用字节码文件创建 Class 对象 .</li><li>验证： 确保 Class 文件符合当前虚拟机的要求 , 不会危害到虚拟机自身安全 .</li><li>准备： 进行内存分配 , 为 static 修饰的类变量分配内存 , 并设置初始值 (0 或 null). 不包含final 修饰的静态变量 , 因为final变量在编译时分配 .</li><li>解析： 将常量池中的符号引用替换为直接引用的过程 . 直接引用为直接指向目标的指针或者相对偏移量等 .</li><li>初始化： 主要完成静态块执行以及静态变量的赋值 . 先初始化父类 , 再初始化当前类 . 只有对类主动使用时才会初始化 .</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>触发条件包括 , 创建类的实例时 , 访问类的静态方法或静态变量的时候 , 使用 Class.forName 反射类的时候 , 或者某个子类初始化的时候 .</p><p>Java 自带的加载器加载的类 , 在虚拟机的生命周期中是不会被卸载的 , 只有用户自定义的加载器加载的类才可以被卸 .</p></div><p>双亲委派模式 , 即加载器加载类时先把请求委托给自己的父类加载器执行 , 直到顶层的启动类加载器 .</p><ul><li>启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH） 来加载 Java类。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</li></ul><p>父类加载器能够完成加载则成功返回 , 不能则子类加载器才自己尝试加载 .</p><p>优点 :</p><ol><li>避免类的重复加载</li><li>避免 Java 的核心 API 被篡改</li></ol><h3 id="_9-10-serial-old-收集器-单线程标记整理算法" tabindex="-1"><a class="header-anchor" href="#_9-10-serial-old-收集器-单线程标记整理算法" aria-hidden="true">#</a> 9.10 Serial Old 收集器(单线程标记整理算法)</h3><hr><p>Serial Old收集器是Java虚拟机中的一种垃圾收集器，它主要用于管理老年代中的对象，采用标记整理算法。与Serial收集器不同，Serial Old收集器是单线程的，它只使用一个线程来执行垃圾回收操作。由于它是单线程的，因此在垃圾回收期间，应用程序的所有线程都需要被暂停（停顿），这被称为“Stop-The-World”暂停。</p><p>主要特点和原理机制：</p><p><strong>老年代垃圾回收：</strong> Serial Old收集器主要用于老年代的垃圾回收，即管理具有长生命周期的对象。</p><p><strong>标记整理算法：</strong> Serial Old收集器使用标记整理算法。在垃圾回收过程中，首先会标记出存活的对象，然后对存活的对象进行整理，将它们紧凑排列在一起，从而消除内存碎片。</p><p><strong>Stop-The-World暂停：</strong> 在进行垃圾回收时，Serial Old收集器会暂停应用程序的所有线程，以便执行垃圾回收操作。这种暂停会影响应用程序的响应性能，因此需要在合适的时机进行垃圾回收，以减少暂停时间的影响。</p><p><strong>适用于单核CPU或小型应用：</strong> 由于Serial Old收集器是单线程的，因此它在多核CPU上的利用率较低。它通常适用于单核CPU或小型应用，对吞吐量要求不高的场景。</p><p><strong>HotSpot虚拟机中的实现：</strong> Serial Old收集器是HotSpot虚拟机中的一部分，可以与Serial收集器（用于新生代）结合使用，形成一种“Serial + Serial Old”的垃圾回收策略。</p><p>需要注意的是，虽然Serial Old收集器的吞吐量相对较低，但它对于一些较小的、低延迟要求不高的应用场景仍然是一种可行的选择。对于大型应用或高性能需求的场景，可能需要考虑其他垃圾收集器，如Parallel Old、CMS、G1等。</p><h3 id="_9-11-parallel-old收集器" tabindex="-1"><a class="header-anchor" href="#_9-11-parallel-old收集器" aria-hidden="true">#</a> 9.11 Parallel Old收集器</h3><hr><p>Parallel Old收集器是Java虚拟机中的一种垃圾收集器，它主要用于管理老年代中的对象，采用并行化的方式进行垃圾回收。与Serial Old收集器不同，Parallel Old收集器使用多个线程并行执行垃圾回收操作，从而提高了垃圾回收的吞吐量。它是一种面向吞吐量优化的收集器。</p><p><strong>主要特点和原理机制：</strong></p><ol><li><p><strong>并行收集：</strong> Parallel Old收集器使用多个线程并行执行垃圾回收操作，从而在一定程度上提高了垃圾回收的吞吐量。这使得它适用于多核CPU的环境，可以更充分地利用多核计算能力。</p></li><li><p><strong>老年代垃圾回收：</strong> Parallel Old收集器主要用于老年代的垃圾回收，即管理具有长生命周期的对象。</p></li><li><p><strong>标记-整理算法：</strong> Parallel Old收集器使用标记-整理算法。在垃圾回收过程中，首先会标记出存活的对象，然后对存活的对象进行整理，将它们紧凑排列在一起，从而消除内存碎片。</p></li><li><p><strong>应用暂停时间：</strong> 虽然Parallel Old收集器使用多线程并行执行，但在垃圾回收过程中仍然需要执行“Stop-The-World”暂停，以确保正确执行垃圾回收操作。但与单线程的收集器相比，Parallel Old的暂停时间通常会更短，因为多线程可以并行处理任务。</p></li><li><p><strong>适用于高吞吐量场景：</strong> Parallel Old收集器适用于对吞吐量要求较高的应用场景，例如后台运算型的应用。通过多线程的并行处理，可以在一定程度上减少垃圾回收对应用性能的影响。</p></li></ol><p>需要注意的是，虽然Parallel Old收集器在吞吐量方面有很好的表现，但它可能会引入一定的线程管理和同步开销，对响应时间的影响可能不如其他收集器，因此在某些低延迟要求的场景下，需要综合考虑使用其他的垃圾收集策略。</p><h3 id="_9-12-cms收集器" tabindex="-1"><a class="header-anchor" href="#_9-12-cms收集器" aria-hidden="true">#</a> 9.12 CMS收集器</h3><hr><p>CMS（Concurrent Mark-Sweep）收集器是Java虚拟机中的一种垃圾收集器，它主要用于管理老年代中的对象，以减少垃圾回收对应用的停顿时间。CMS收集器通过并发执行大部分垃圾回收操作，以降低应用的停顿时间，适用于低延迟要求的应用场景。</p><p><strong>主要特点和原理机制：</strong></p><ol><li><p><strong>并发收集：</strong> CMS收集器采用并发的方式进行垃圾回收，即在应用程序运行的同时，部分垃圾回收操作在另一个线程中进行。这使得垃圾回收和应用程序的执行可以并行执行，从而减少了“Stop-The-World”暂停时间。</p></li><li><p><strong>老年代垃圾回收：</strong> CMS收集器主要用于老年代的垃圾回收，即管理具有长生命周期的对象。</p></li><li><p><strong>标记-清除算法：</strong> CMS收集器使用标记-清除算法。在标记阶段，它标记出所有存活的对象。在清除阶段，它会清除所有未标记的对象，但这个过程会产生内存碎片。</p></li><li><p><strong>三个并发阶段：</strong> CMS收集器的垃圾回收过程分为三个并发的阶段：初始标记、并发标记、重新标记。其中，并发标记阶段是与应用程序并行执行的，重新标记阶段是为了处理在并发标记期间发生的对象引用变化。</p></li><li><p><strong>降低停顿时间：</strong> CMS收集器的设计目标是降低垃圾回收对应用程序停顿时间的影响。它通过并发执行部分操作，尽量减少“Stop-The-World”暂停的时间。但由于标记-清除算法可能会产生内存碎片，因此在应用内存较大时可能需要进行更频繁的垃圾回收，以减少碎片。</p></li><li><p><strong>适用于低延迟要求：</strong> CMS收集器适用于对低延迟要求较高的应用场景，可以减少垃圾回收对应用性能的影响。然而，它可能引入一些附加的线程开销，因此需要综合考虑应用的特性和需求。</p></li></ol><div class="hint-container warning"><p class="hint-container-title">注意</p><p>需要注意的是，CMS收集器在一些特殊情况下可能会出现“Concurrent Mode Failure”（并发模式失败），导致一次“Full GC”。为了解决这个问题，可以使用G1收集器等其他收集器。</p></div><h3 id="_9-13-g1收集器" tabindex="-1"><a class="header-anchor" href="#_9-13-g1收集器" aria-hidden="true">#</a> 9.13 G1收集器</h3><hr><p>G1（Garbage-First）收集器是Java虚拟机中的一种垃圾收集器，它是一种面向性能和低延迟的垃圾收集器，主要用于管理堆内存中的对象。与传统的垃圾收集器相比，G1收集器在垃圾回收过程中更加可控，可以有效减少长时间的垃圾回收暂停。</p><p><strong>主要特点和原理机制：</strong></p><ol><li><p><strong>分代收集器：</strong> G1收集器同样分为新生代和老年代，但与传统的分代收集器不同，G1收集器将堆内存分成不同大小的区域，称为“区域”（Region），而不是传统的Eden、Survivor和老年代。</p></li><li><p><strong>并行与并发：</strong> G1收集器结合了并行和并发的特性。它在进行垃圾回收时会并行地执行一些步骤，如垃圾收集和压缩。同时，它还利用并发来执行标记和清理等操作，以减少应用暂停时间。</p></li><li><p><strong>Garbage-First策略：</strong> G1收集器的名字“Garbage-First”意味着它优先回收产生最多垃圾的区域。在每次垃圾回收时，G1会选择一个或多个产生垃圾最多的区域进行回收，以最大程度地优化垃圾回收效果。</p></li><li><p><strong>预测停顿时间：</strong> G1收集器可以预测垃圾回收的停顿时间，根据应用的需求来调整垃圾回收策略。这使得应用程序可以更好地控制垃圾回收对性能的影响。</p></li><li><p><strong>混合收集：</strong> G1收集器采用一种混合收集（Mixed Collections）策略，它将部分回收周期用于并发标记和清理，而在其他周期中执行全局的垃圾收集和压缩。</p></li><li><p><strong>适用于大内存应用：</strong> G1收集器适用于大内存的应用场景，可以更高效地管理大堆内存，并降低垃圾回收对应用性能的影响。</p></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>需要注意的是，虽然G1收集器在很多方面具有优势，但在一些特定情况下可能会出现一些性能问题。因此，在选择垃圾收集器时，需要综合考虑应用的特性、需求和性能，选择最适合的垃圾收集器。</p></div><h3 id="_9-14-minor-gc-与-full-gc-分别在什么时候发生" tabindex="-1"><a class="header-anchor" href="#_9-14-minor-gc-与-full-gc-分别在什么时候发生" aria-hidden="true">#</a> 9.14 Minor GC 与 Full GC 分别在什么时候发生？</h3><hr><p>Minor GC（新生代垃圾回收）和Full GC（老年代垃圾回收）是Java虚拟机进行垃圾回收时的两种主要类型，它们在不同的情况下发生。</p><p><strong>Minor GC（新生代垃圾回收）：</strong></p><p>Minor GC发生在新生代，即年轻代中的Eden区和Survivor区之间的区域。新生代是存放刚刚被创建的对象的区域，大部分对象在这个区域被迅速分配并消亡。Minor GC的主要任务是回收新生代中的垃圾对象，通常发生的频率比较高。</p><p>当新生代的Eden区满了时，会触发Minor GC。在Minor GC过程中，Eden区和Survivor区中的存活对象会被标记并复制到另一个Survivor区，同时非存活的对象会被回收。Minor GC的特点是速度较快，通常只涉及一部分的堆内存。</p><p><strong>Full GC（老年代垃圾回收）：</strong></p><p>Full GC发生在老年代，即年老代中的区域。老年代是存放已经存活了一段时间的对象的区域，通常包含着更多的长生命周期对象。Full GC的任务是回收老年代中的垃圾对象，它会涉及到整个堆内存。</p><p><strong>Full GC的发生条件相对较多，其中一些情况包括：</strong></p><ul><li>当老年代空间不足时，会触发Full GC。这可能是因为老年代中有大量存活的对象，导致内存不够。</li><li>在对永久代进行垃圾回收（例如回收无用的类加载器、反射等信息）时，也可能触发Full GC。</li><li>在手动调用System.gc()方法时，会建议JVM执行Full GC，但是否执行取决于JVM的策略。</li></ul><p>需要注意的是，Full GC通常会导致较长时间的“Stop-The-World”暂停，即应用程序的所有线程会被暂停，直到垃圾回收完成。因此，在设计和部署应用程序时，需要合理选择垃圾收集策略，以平衡吞吐量和停顿时间的需求。</p><h3 id="_9-15-有哪些jvm调优" tabindex="-1"><a class="header-anchor" href="#_9-15-有哪些jvm调优" aria-hidden="true">#</a> 9.15 有哪些JVM调优</h3><hr><ol><li><strong>堆设置</strong><ul><li>-Xmx:3072M</li><li>-Xms:3072M</li></ul></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>参数-Xms和-Xmx，通常设置为相同的值，避免运行时要不断扩展JVM内存,每次垃圾回收都得重新分配，建议扩大至3-4倍FullGC后的老年代空间占用。</p></div><ol start="2"><li><strong>年轻代</strong><ul><li>-Xmn:1024M</li></ul></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>1-1.5倍FullGC之后的老年代空间占用。</p><p>避免新生代设置过小，当新生代设置过小时，会带来两个问题：一是minor GC次数频繁，二是可能导致 minor GC对象直接进老年代。当老年代内存不足时，会触发Full GC。 避免新生代设置过大，当新生代设置过大时，会带来两个问题：一是老年代变小，可能导致Full GC频繁执行；二是 minor GC 执行回收的时间大幅度增加。</p><p>线上生产环境，使用-Xmn一个即可（推荐）</p><p>或者同时使用 -XX:NewSize=1024m 和 -XX:MaxNewSize=1024m来设置</p></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？</p><p>如下：</p><p>高优先级：-XX:NewSize/-XX:MaxNewSize</p><p>中优先级：-Xmn（默认等效 -Xmn=-XX:NewSize=-XX:MaxNewSize=?）</p><p>低优先级：-XX:NewRatio</p><p>推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境。-Xmn 配合 -Xms/-Xmx，即可将堆内存布局完成。</p></div><ol start="3"><li><strong>方法区</strong><ul><li>-XX:MetaspaceSize=256m</li><li>-XX:MaxMetaspaceSize=256m</li></ul></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>基于jdk1.7版本，永久代：参数-XX:PermSize和-XX:MaxPermSize；</p><p>基于jdk1.8版本，元空间：参数 -XX:MetaspaceSize和-XX:MaxMetaspaceSize；</p><p>通常设置为相同的值，避免运行时要不断扩展，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。</p></div><ol start="4"><li><strong>年轻代中Eden区与Survivor区的比值</strong><ul><li>-XX:SurvivorRatio=4</li></ul></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。官方推荐幸存代占新生代的1/10。</p></div><ol start="5"><li><strong>新生代存活区切换的次数</strong><ul><li>-XX:MaxTenuringThreshold=15</li></ul></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>表示一个对象如果在Survivor区（救助空间）移动了15次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</p></div><ol start="6"><li><strong>堆dump</strong> 出现oom时生成堆dump</li></ol><ul><li>-XX:+HeapDumpOnOutOfMemoryError</li></ul><p>生成堆文件地址</p><ul><li>-XX:HeapDumpPath=/home/...</li></ul><p>或者使用jmap生成 发现程序异常前通过执行指令，直接生成当前JVM的dump文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>jmap <span class="token parameter variable">-dump:file</span><span class="token operator">=</span>dump-log.dump pid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="7"><li><strong>垃圾回收器</strong> 新生代使用ParNew</li></ol><ul><li>-XX:+UseParNewGC</li></ul><p>老年代使用CMS</p><ul><li>-XX:+UseConcMarkSweepGC</li></ul><h2 id="_10-mysql" tabindex="-1"><a class="header-anchor" href="#_10-mysql" aria-hidden="true">#</a> 10. MySql</h2><h3 id="_10-1-mysql-中有哪些不同的表格" tabindex="-1"><a class="header-anchor" href="#_10-1-mysql-中有哪些不同的表格" aria-hidden="true">#</a> 10.1 MySQL 中有哪些不同的表格？</h3><hr><p>在 MySQL 中，有几种常见的表格类型（也称为存储引擎），它们具有不同的特点和用途。以下是一些主要的 MySQL 表格类型：</p><ol><li><p><strong>InnoDB：</strong> InnoDB 是 MySQL 默认的事务性存储引擎。它支持事务、外键约束和行级锁定，适用于需要数据完整性和并发性的应用。InnoDB 提供了高度的崩溃恢复能力，并具有较好的性能。</p></li><li><p><strong>MyISAM：</strong> 在早期版本的 MySQL 中，MyISAM 是默认的存储引擎。它不支持事务和行级锁定，但具有较高的读取性能。MyISAM 适用于读频繁的应用，如查询密集型应用。</p></li><li><p><strong>Memory（或 Heap）：</strong> Memory 存储引擎将表格存储在内存中，提供了极快的读写速度，适用于临时数据存储。然而，由于数据存储在内存中，断电或重启会导致数据丢失。</p></li><li><p><strong>Archive：</strong> Archive 存储引擎专注于高压缩和高性能的插入操作。它适用于需要长期存储归档数据的场景，但不支持索引，只支持 INSERT 和 SELECT 操作。</p></li><li><p><strong>CSV：</strong> CSV 存储引擎将数据存储为逗号分隔的文本文件。它适用于导入/导出数据，但不适合大规模查询。</p></li><li><p><strong>Blackhole：</strong> Blackhole 存储引擎接收数据写入，但数据实际上不会被存储，只是被丢弃。它通常用于复制和数据分发场景。</p></li><li><p><strong>Federated：</strong> Federated 存储引擎允许在一个 MySQL 服务器上查询另一个 MySQL 服务器上的数据，实现分布式查询。</p></li><li><p><strong>NDB Cluster：</strong> NDB 存储引擎用于 MySQL Cluster，支持分布式数据库集群。它提供高可用性和高容错性，适用于需要在多台计算机上分布数据的场景。</p></li><li><p><strong>TokuDB：</strong> TokuDB 存储引擎专注于大量写入的高性能，适用于需要处理大量写操作的应用，如日志记录和分析。</p></li></ol><p>需要注意的是，MySQL 版本可能会影响可用的存储引擎列表，而且新的存储引擎可能会随着版本的更新而引入。在选择适合的存储引擎时，需考虑应用的需求、性能要求和数据完整性等因素。</p><h3 id="_10-2-tokudb-fractal-tree-节点带数据" tabindex="-1"><a class="header-anchor" href="#_10-2-tokudb-fractal-tree-节点带数据" aria-hidden="true">#</a> 10.2 TokuDB（ Fractal Tree-节点带数据）</h3><hr><p>TokuDB 是一个特殊的存储引擎，它基于 Fractal Tree 技术，旨在提供高效的写入性能和压缩存储，特别适用于需要处理大量写入操作的应用。Fractal Tree 是一种数据结构，可以在高写入负载下维持较低的磁盘碎片化，从而提供出色的性能。</p><p><strong>TokuDB 的一些特点包括：</strong></p><ol><li><p><strong>高效的写入性能：</strong> TokuDB 在处理大量写入操作时表现出色。它通过优化磁盘写入模式，减少了随机磁盘写入，从而提高了写入性能。</p></li><li><p><strong>压缩存储：</strong> TokuDB 使用了一种称为 Fractal Tree Indexing 的技术，这种技术可以在不牺牲查询性能的情况下对数据进行高效压缩。这有助于减少存储空间占用。</p></li><li><p><strong>在线压缩：</strong> TokuDB 允许在运行时对数据进行在线压缩，而不需要停止数据库操作。这可以帮助优化存储和提高查询性能。</p></li><li><p><strong>磁盘碎片化管理：</strong> TokuDB 通过 Fractal Tree 索引结构减少了磁盘碎片化，这有助于维持较稳定的性能。</p></li><li><p><strong>支持事务和并发：</strong> TokuDB 支持事务和并发性，使其不仅适用于写入密集型应用，还适用于需要数据一致性和并发访问的场景。</p></li></ol><p>总之，TokuDB 通过利用 Fractal Tree 技术和其他优化，提供了在高写入负载下表现良好的存储引擎。它适用于需要大量写入操作和压缩存储的应用，例如日志记录、分析和大规模数据采集等场景。需要注意的是，TokuDB 并非 MySQL 的默认存储引擎，需要单独安装和配置。</p><h3 id="_10-3-mysql-中-innodb-支持的四种事务隔离级别名称-以及逐级之间的区别" tabindex="-1"><a class="header-anchor" href="#_10-3-mysql-中-innodb-支持的四种事务隔离级别名称-以及逐级之间的区别" aria-hidden="true">#</a> 10.3 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><hr><p>MySQL 中 InnoDB 存储引擎支持四种事务隔离级别，每个级别提供不同程度的事务隔离性和并发控制。以下是这些隔离级别的名称以及它们之间的区别：</p><p><strong>读未提交（Read Uncommitted）：</strong></p><ul><li>在此隔离级别下，事务可以读取其他事务尚未提交的未提交数据。</li><li>最低的隔离级别，不提供数据一致性保证。</li><li>可能会导致脏读（读取到其他事务未提交的数据）和不可重复读（同一事务内多次读取同一行数据的结果不同）。</li></ul><p><strong>读已提交（Read Committed）：</strong></p><ul><li>在此隔离级别下，事务只能读取已经提交的数据。</li><li>解决了脏读问题，但仍然可能会遇到不可重复读问题。</li><li>多个事务可能会看到同一行数据在不同时间点的不同版本。</li></ul><p><strong>可重复读（Repeatable Read）：</strong></p><ul><li>在此隔离级别下，事务在整个事务期间看到的数据是一致的，不受其他并发事务的影响。</li><li>解决了不可重复读问题，但仍可能遇到幻读问题。</li><li>幻读是指在同一事务中执行相同查询，但结果集的行数不同。</li></ul><p><strong>串行化（Serializable）：</strong></p><ul><li>在此隔离级别下，事务完全隔离，事务之间没有任何并发性。 最* 高级别的隔离，可以防止脏读、不可重复读和幻读，但可能会导致性能下降，因为事务需要等待其他事务完成。</li></ul><p>逐级之间的区别主要在于对并发性和数据一致性的权衡。更高的隔离级别通常提供更好的数据一致性，但可能会影响并发性能。在选择隔离级别时，需要根据应用的需求和性能要求进行权衡，以确保数据的正确性和性能的平衡。默认情况下，InnoDB 使用的是“可重复读”隔离级别。可以使用以下语句来设置特定事务的隔离级别：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token operator">&lt;</span>隔离级别<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中，<code>&lt;隔离级别&gt;</code> 是 &quot;READ UNCOMMITTED&quot;、&quot;READ COMMITTED&quot;、&quot;REPEATABLE READ&quot; 或 &quot;SERIALIZABLE&quot; 之一。</p><h3 id="_10-4-myisamchk-是用来做什么的" tabindex="-1"><a class="header-anchor" href="#_10-4-myisamchk-是用来做什么的" aria-hidden="true">#</a> 10.4 myisamchk 是用来做什么的？</h3><hr><p>myisamchk 是一个 MySQL 提供的命令行工具，用于对 MyISAM 存储引擎表格进行检查、维护和修复。MyISAM 是 MySQL 中的一种存储引擎，虽然在现代 MySQL 版本中被 InnoDB 取代为默认引擎，但在一些特定的用例和历史应用中仍然可能会使用 MyISAM 表格。</p><p>myisamchk 提供了一系列功能，包括：</p><ol><li><p><strong>检查表格的完整性：</strong> myisamchk 可以检查 MyISAM 表格的数据文件和索引文件是否损坏或存在问题。它可以帮助发现表格中的错误和异常情况。</p></li><li><p><strong>优化表格：</strong> myisamchk 可以对 MyISAM 表格进行优化，重新组织数据文件和索引文件，从而提高表格的查询性能。这个过程可以消除碎片化，并使数据更加紧凑。</p></li><li><p><strong>修复表格：</strong> 在检查中发现问题时，myisamchk 可以尝试修复 MyISAM 表格的损坏数据。然而，需要注意的是，在修复过程中可能会丢失部分数据，因此在使用之前最好备份数据。</p></li><li><p><strong>恢复误删除的数据：</strong> myisamchk 有时可以从损坏的 MyISAM 表格中恢复被误删除的数据，但并不是所有情况下都可行。</p></li><li><p><strong>变更表格状态：</strong> myisamchk 还可以修改表格的状态，如标记表格为只读或读写。</p></li></ol><p>需要注意的是，myisamchk 只适用于 MyISAM 存储引擎表格，不适用于其他存储引擎，比如 InnoDB。如果你在使用 MyISAM 表格，并且需要检查、修复或优化这些表格，那么可以考虑使用 myisamchk 工具来执行这些操作。</p><h3 id="_10-5-myisam-表格将在哪里存储-并且还提供其存储格式" tabindex="-1"><a class="header-anchor" href="#_10-5-myisam-表格将在哪里存储-并且还提供其存储格式" aria-hidden="true">#</a> 10.5 MyISAM 表格将在哪里存储，并且还提供其存储格式？</h3><hr><p>MyISAM 表格的数据和索引以文件的形式存储在数据库的数据目录中。具体来说，MyISAM 表格的每个表格都由三个文件组成：</p><ol><li><p><strong>表格文件 (.MYD)：</strong> 这个文件存储了实际的数据行。它包含了表格的所有数据记录。</p></li><li><p><strong>索引文件 (.MYI)：</strong> 这个文件存储了表格的索引信息，用于加速查询操作。索引文件中的内容是基于表格的一个或多个索引的。</p></li><li><p><strong>数据字典文件 (.frm)：</strong> 这个文件存储了表格的结构和元数据信息，包括列的名称、数据类型等。</p></li></ol><p>关于存储格式，MyISAM 表格在物理上使用了一种称为定长记录的存储方式，这意味着每条数据记录都会占用相同的固定长度。这有助于快速的读取操作，但可能导致存储浪费，特别是对于变长字段或者存在大量空白的记录。</p><p>MyISAM 表格的索引使用 B-tree（平衡树）结构，这种结构可以快速地定位和访问数据。MyISAM 存储引擎在维护索引时使用 B-tree 索引结构来保持数据的有序性，从而提供高效的查询性能。</p><p>需要注意的是，虽然 MyISAM 在早期版本的 MySQL 中是默认的存储引擎，但在现代 MySQL 版本中，InnoDB 已经成为默认的存储引擎，并且被广泛使用。InnoDB 具有更好的事务支持、并发性和数据完整性。如果你在新项目中使用 MySQL，通常会优先选择 InnoDB 存储引擎。</p><h3 id="_10-6-常见索引原则有" tabindex="-1"><a class="header-anchor" href="#_10-6-常见索引原则有" aria-hidden="true">#</a> 10.6 常见索引原则有</h3><hr><p>在数据库中创建索引是提高查询性能和加速数据访问的重要手段之一。以下是一些常见的索引原则，可以帮助你在设计数据库时做出更明智的决策：</p><ol><li><p>**选择适当的列：**选择那些经常在查询中用作条件或连接的列作为索引列。通常，主键、外键和经常被搜索的列都是很好的索引候选者。</p></li><li><p>**避免过多的索引：**虽然索引可以提高查询性能，但过多的索引可能会导致维护开销和性能下降。每个索引都需要占用存储空间并影响插入、更新和删除操作的性能。</p></li><li><p>**选择适当的索引类型：**不同的数据库存储引擎支持不同类型的索引，如 B-tree、哈希索引、全文索引等。根据具体的查询和数据需求选择适合的索引类型。</p></li><li><p>**优先考虑联合索引：**在多个列上创建联合索引，可以为涉及这些列的复合条件查询提供更好的性能。但要注意，联合索引可能增加维护开销，因此需要权衡。</p></li><li><p>**注意列的选择性：**索引的选择性指的是索引中不重复值的比例。高选择性的列会更适合做索引，因为它们可以更精确地定位数据。</p></li><li><p><strong>避免冗余索引：</strong> 当多个索引中包含相同的列或相似的列组合时，可能会导致冗余索引。冗余索引不仅浪费空间，还会影响性能。</p></li><li><p><strong>定期维护和优化索引：</strong> 随着数据库的使用，索引可能会变得不再高效。定期进行索引维护和优化操作，如重新构建索引、删除不必要的索引等，可以保持良好的性能。</p></li><li><p><strong>考虑查询的频率和类型：</strong> 根据查询的类型（范围查询、精确查询等）和频率选择合适的索引策略。有些索引在某些查询类型下更有效。</p></li><li><p><strong>考虑内存和磁盘的平衡：</strong> 内存中的索引可以更快地访问，但随着数据量的增加，适当的磁盘索引也是必要的。在设计索引时要权衡内存和磁盘资源的使用。</p></li><li><p>**测试和监测性能：**在设计索引后，一定要测试和监测查询性能的变化。有时候，索引的添加或修改可能对性能产生负面影响，需要进行适当的调整。</p></li></ol><p>综上所述，创建索引是一个权衡和策略性的过程。需要根据具体的应用场景、查询模式和数据特点来选择和设计索引，以获得最佳的性能和数据访问效率。</p>`,1293);function g(h,b){const a=r("font");return i(),c("div",null,[k,u("p",null,[n("总结：Java 中是值传递，对于基本数据类型，传递的是实际值；对于对象引用，传递的是引用的副本，方法内的操作可能影响调用处的对象，"),t(a,{color:"red"},{default:e(()=>[n("但不会改变原始引用指向的对象。")]),_:1})]),v,t(a,{color:"red",size:"4"},{default:e(()=>[n("总结:")]),_:1}),m])}const S=l(d,[["render",g],["__file","interview-2023.html.vue"]]);export{S as default};
