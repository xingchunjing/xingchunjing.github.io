import{_ as e,X as p,Y as t,a0 as l,a1 as i,Z as n,$ as s,a2 as c,E as o}from"./framework-f01f539c.js";const r="/assets/images/linux-jstack01.jpeg",u="/assets/images/linux-jstack02.jpeg",d={},m=n("h1",{id:"内存溢出处理",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#内存溢出处理","aria-hidden":"true"},"#"),s(" 内存溢出处理")],-1),v=n("p",null,"由于服务器突然间报警内存占用过高，只好先查看服务器上是哪个服务占用内存过高，一点一点慢慢来",-1),b=c(`<h2 id="_1-查看内存占用情况定位线程" tabindex="-1"><a class="header-anchor" href="#_1-查看内存占用情况定位线程" aria-hidden="true">#</a> 1. 查看内存占用情况定位线程</h2><hr><p>使用top命令进行查看，由于要查看内存使用情况所以需要按内存排一下序</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#按进程的CPU使用率排序</span>
运行top命令后，键入大写P

<span class="token comment">#按进程的内存使用率排序</span>
运行top命令后，键入大写M
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+r+`" alt="top M" tabindex="0" loading="lazy"><figcaption>top M</figcaption></figure><h2 id="_2-定位线程问题-通过命令查看线程情况" tabindex="-1"><a class="header-anchor" href="#_2-定位线程问题-通过命令查看线程情况" aria-hidden="true">#</a> 2. 定位线程问题（通过命令查看线程情况）</h2><hr><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ps</span> p <span class="token number">10483</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-o</span> pcpu,pmem,pid,tid,time,tname,cmd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从这个可以看到线程情况，当时情况紧急没有截图，所以我下面的图是同一个服务写文档时运行的</p><figure><img src="`+u+`" alt="ps p 10483" tabindex="0" loading="lazy"><figcaption>ps p 10483</figcaption></figure><p>具体可以执行下面操作看有多少个线程</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token function">ps</span> p <span class="token number">24013</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-o</span> pcpu,pmem,pid,tid,time,tname,cmd <span class="token operator">|</span><span class="token function">wc</span> <span class="token parameter variable">-l</span>

 <span class="token number">100</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-查看内存使用堆栈" tabindex="-1"><a class="header-anchor" href="#_3-查看内存使用堆栈" aria-hidden="true">#</a> 3. 查看内存使用堆栈</h2><hr><p>在这里我挑选了TID=24014的线程进行分析(选择一个执行时间较长的)，首先需要将24014这个id转换为16进制。需输入如下命令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token builtin class-name">printf</span> <span class="token string">&quot;%x<span class="token entity" title="\\n">\\n</span>&quot;</span> <span class="token number">24014</span>

 5dce
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-将pid为-24013-的堆栈信息打印到jstack-log中" tabindex="-1"><a class="header-anchor" href="#_4-将pid为-24013-的堆栈信息打印到jstack-log中" aria-hidden="true">#</a> 4. 将PID为 24013 的堆栈信息打印到jstack.log中</h2><hr><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#输出目录自定</span>
jstack <span class="token parameter variable">-l</span> <span class="token number">24013</span> <span class="token operator">&gt;</span> /usr/local/temp/jstack.log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>查看具体信息后，发现程序中并没有自己写的代码有死锁或者是等待的东西，那就应该是默认配置相关了，其中有两个比较多<code>http-nio-xxxx-exec-xx</code>和<code>lettuce-eventExecutorLoop-1-x</code></p><p><code>http-nio-4001-exec-30</code>是Tomcat的工作线程名称。在Tomcat中，每个工作线程都被分配一个独特的名称，以便在调试和性能分析时能够轻松地跟踪线程的执行情况。</p><p><code>http-nio-4001-exec-30</code> 中的 <code>4001</code> 表示Tomcat监听的端口号， <code>exec</code> 表示该线程是Tomcat的工作线程， <code>30</code> 表示该线程的标识符。</p><p>如果在jstack输出中看到大量类似 <code>http-nio-xxxx-exec-xx</code> 的线程，这可能意味着应用程序正在处理大量的并发请求。每个请求都需要一个工作线程来处理，并且这些工作线程都需要占用一定的内存和CPU资源。如果应用程序的并发请求量过高，可能会导致系统资源瓶颈，进而影响应用程序的性能和稳定性。</p><p>如果应用程序需要处理大量的并发请求，建议根据实际情况来配置Tomcat的线程池参数，以确保应用程序的性能和稳定性。</p><p>这边使用的是springboot2.3X以上的版本，配置内置的tomcat参数与之前的有些不一样</p><p>在application.yml中进行配置，例如：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">tomcat</span><span class="token punctuation">:</span>
    <span class="token key atrule">threads</span><span class="token punctuation">:</span>
      <span class="token key atrule">max</span><span class="token punctuation">:</span> 500 //线程池的最大线程数。默认值200
      <span class="token key atrule">min-spare</span><span class="token punctuation">:</span> 50 //线程池中最少的空闲线程数。默认值10
      <span class="token key atrule">idle-timeout</span><span class="token punctuation">:</span> 60000 //指定在空闲线程被回收之前等待的最大毫秒数。默认值60s
    <span class="token key atrule">accept-count</span><span class="token punctuation">:</span> 200 //指定在队列中等待处理的最大连接数。默认值100
    <span class="token key atrule">max-connections</span><span class="token punctuation">:</span> 20000 //最大连接数。默认值10000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>lettuce-eventExecutorLoop-1-x</code> 是Lettuce Redis客户端的线程名称，其中的 <code>x</code> 表示线程标识符。Lettuce使用Netty作为底层网络通信框架，每个Netty EventLoop都会创建一个Lettuce线程，并分配一个独特的线程名称，以便在调试和性能分析时能够轻松地跟踪线程的执行情况。</p><p>在Lettuce Redis客户端中，每个Redis命令都是异步执行的，即客户端会在发送请求之后立即返回，并通过回调函数或者Future等方式获取结果。Lettuce使用EventLoop线程来处理I/O事件、连接管理和Redis命令执行等任务，以提高客户端的性能和吞吐量。</p><p>如果在jstack输出中看到大量类似 <code>lettuce-eventExecutorLoop-1-x</code> 的线程，这可能意味着应用程序正在与Redis进行大量的交互，并且使用了Lettuce客户端。每个Lettuce线程都需要占用一定的内存和CPU资源，如果线程数量过多，可能会导致系统资源瓶颈，进而影响应用程序的性能和稳定性。</p><p>如果应用程序需要与Redis进行大量的交互，建议根据实际情况来配置Lettuce的线程池参数，以确保应用程序的性能和稳定性。</p><p>在application.yml中进行配置，例如：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost  <span class="token comment"># Redis服务器地址，默认为localhost</span>
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>       <span class="token comment"># Redis服务器端口，默认为6379</span>
    <span class="token key atrule">password</span><span class="token punctuation">:</span>        <span class="token comment"># Redis密码，默认为空</span>
    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token comment"># Redis数据库索引（0-15），默认为0</span>
    <span class="token key atrule">timeout</span><span class="token punctuation">:</span> <span class="token number">1000</span>    <span class="token comment"># 连接超时时间（毫秒），默认为1000</span>
    <span class="token key atrule">jedis</span><span class="token punctuation">:</span>
      <span class="token key atrule">pool</span><span class="token punctuation">:</span>
        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span>       <span class="token comment"># 连接池最大连接数，默认为8</span>
        <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>         <span class="token comment"># 连接池最大空闲连接数，默认为8</span>
        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span>         <span class="token comment"># 连接池最小空闲连接数，默认为0</span>
        <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> <span class="token number">-1</span>        <span class="token comment"># 连接池最大等待时间（毫秒），默认为-1（表示无限等待）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改了配置文件在观察吧，我在导出jstack的时候运维已经重启了服务，我不清楚这个是不是当时有问题的原因，但是从后来分析的情况来看，确实存在一定的问题...</p><p>后续会跟进...</p><p>后续跟进 : 我在执行<code>ps p 10483 -L -o pcpu,pmem,pid,tid,time,tname,cmd</code>命令式发现有个线程时间2分钟还没结束，去jstack查看了一下，是 System Clock</p><p>这个线程是一个系统线程，是JVM中专门负责管理系统时钟的线程，它会定期更新JVM中的系统时间，以及JVM中的一些相关参数，如 java.util.Date 和 System.currentTimeMillis()等方法的返回值。该线程的状态为 TIMED_WAITING ，意味着它是在等待时钟时间的到来，并在等待的过程中处于定时等待状态。这种状态在Java应用程序中非常常见，并且通常是正常的行为，不应该引起太多的注意。但是2分钟还没执行完就多少有点时间长，查看了一下代码，发现使用了 SimpleDateFormat</p><p>SimpleDateFormat 并不是线程安全的，如果多个线程同时使用同一个 SimpleDateFormat 对象进行日期格式化，就有可能出现线程安全问题，在程序中我也看到不知怎么的这一块是写在属性当中，所有方法共用，这一块应该存在问题，优化到方法内部或者如果确定要只定义一个的话：</p><p>如果多个线程同时读取同一个SimpleDateFormat对象的话，会出现线程安全问题，因为SimpleDateFormat不是线程安全的。所以如果多个线程同时读取时可能会出现线程阻塞的情况。为了避免这种情况，可以考虑使用ThreadLocal来保证每个线程有自己的SimpleDateFormat对象。这样就可以避免多个线程之间的竞争，提高程序的性能和稳定性。</p><h2 id="_5-补充1" tabindex="-1"><a class="header-anchor" href="#_5-补充1" aria-hidden="true">#</a> 5. 补充1</h2><p>后续跟进中，发现内存还是越来越大，使用top以后res还是居高不下，接着进行查看跟踪</p><p>根据进程id执行</p><h3 id="查看活着的进程" tabindex="-1"><a class="header-anchor" href="#查看活着的进程" aria-hidden="true">#</a> 查看活着的进程</h3><hr><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 查看活着的进程</span>
jmap <span class="token parameter variable">-histo:live</span> pid

<span class="token comment">## 这里截取了部分</span>
num     <span class="token comment">#instances         #bytes  class name</span>
----------------------------------------------
   <span class="token number">1</span>:         <span class="token number">80790</span>       <span class="token number">10028800</span>  <span class="token punctuation">[</span>C
   <span class="token number">2</span>:          <span class="token number">8588</span>        <span class="token number">5616312</span>  <span class="token punctuation">[</span>B
   <span class="token number">3</span>:         <span class="token number">84228</span>        <span class="token number">2695296</span>  java.util.concurrent.ConcurrentHashMap<span class="token variable">$Node</span>
   <span class="token number">4</span>:         <span class="token number">26168</span>        <span class="token number">2302784</span>  java.lang.reflect.Method
   <span class="token number">5</span>:         <span class="token number">80161</span>        <span class="token number">1923864</span>  java.lang.String
   <span class="token number">6</span>:         <span class="token number">15826</span>        <span class="token number">1748536</span>  java.lang.Class
   <span class="token number">7</span>:         <span class="token number">27455</span>        <span class="token number">1317840</span>  org.aspectj.weaver.reflect.ShadowMatchImpl
<span class="token punctuation">..</span>.
<span class="token number">2808</span>:             <span class="token number">1</span>             <span class="token number">32</span>  io.lettuce.core.resource.ExponentialDelay
<span class="token number">2809</span>:             <span class="token number">1</span>             <span class="token number">32</span>  io.netty.buffer.EmptyByteBuf
<span class="token number">2810</span>:             <span class="token number">1</span>             <span class="token number">32</span>  io.netty.channel.DefaultChannelId
<span class="token number">2811</span>:             <span class="token number">1</span>             <span class="token number">32</span>  io.netty.channel.nio.NioEventLoopGroup
<span class="token number">2812</span>:             <span class="token number">1</span>             <span class="token number">32</span>  io.netty.util.AttributeKey
<span class="token number">2813</span>:             <span class="token number">1</span>             <span class="token number">32</span>  io.netty.util.HashedWheelTimer<span class="token variable">$Worker</span>
<span class="token number">2814</span>:             <span class="token number">1</span>             <span class="token number">32</span>  io.netty.util.concurrent.DefaultEventExecutorGroup
<span class="token number">2815</span>:             <span class="token number">1</span>             <span class="token number">32</span>  io.netty.util.concurrent.DefaultPromise<span class="token variable">$StacklessCancellationException</span>
<span class="token number">2816</span>:             <span class="token number">2</span>             <span class="token number">32</span>  io.netty.util.concurrent.MultithreadEventExecutorGroup<span class="token variable">$1</span>
<span class="token number">2817</span>:             <span class="token number">2</span>             <span class="token number">32</span>  io.netty.util.concurrent.ThreadPerTaskExecutor
<span class="token number">2818</span>:             <span class="token number">2</span>             <span class="token number">32</span>  io.netty.util.internal.logging.Slf4JLoggerFactory
<span class="token number">2819</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.beans.ThreadGroupContext
<span class="token number">2820</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.beans.ThreadGroupContext<span class="token variable">$1</span>
<span class="token number">2821</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.io.FileNotFoundException
<span class="token number">2822</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.io.RandomAccessFile
<span class="token number">2823</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.io.UnixFileSystem
<span class="token number">2824</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.lang.ArithmeticException
<span class="token number">2825</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.lang.ArrayIndexOutOfBoundsException
<span class="token number">2826</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.lang.ClassCastException
<span class="token number">2827</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.lang.IllegalStateException
<span class="token number">2828</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.lang.NullPointerException
<span class="token number">2829</span>:             <span class="token number">2</span>             <span class="token number">32</span>  java.lang.Shutdown<span class="token variable">$Lock</span>
<span class="token number">2830</span>:             <span class="token number">1</span>             <span class="token number">32</span>  java.lang.StackTraceElement
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>此命令可以用来查看内存信息，实例个数以及占用内存大小</p><ul><li>num：序号</li><li>instances：实例数量</li><li>bytes：占用空间大小</li><li>class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]</li></ul></div><p>查看fullGC以后剩下的都是一些系统之类的内存占用，暂时看起来正常?🐶</p><p><strong>查看占用内存多的线程</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>jmap <span class="token parameter variable">-histo</span> pid｜head <span class="token parameter variable">-20</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="查看堆内存使用情况" tabindex="-1"><a class="header-anchor" href="#查看堆内存使用情况" aria-hidden="true">#</a> 查看堆内存使用情况</h3><hr><p>然后我又看了一下堆内存使用情况</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>jmap <span class="token parameter variable">-heap</span> pid

Debugger attached successfully.
Server compiler detected.
JVM version is <span class="token number">25.231</span>-b11

using thread-local object allocation.
Parallel GC with <span class="token number">8</span> thread<span class="token punctuation">(</span>s<span class="token punctuation">)</span>

Heap Configuration:
   MinHeapFreeRatio         <span class="token operator">=</span> <span class="token number">0</span>
   MaxHeapFreeRatio         <span class="token operator">=</span> <span class="token number">100</span>
   MaxHeapSize              <span class="token operator">=</span> <span class="token number">8233418752</span> <span class="token punctuation">(</span><span class="token number">7852</span>.0MB<span class="token punctuation">)</span>
   NewSize                  <span class="token operator">=</span> <span class="token number">171966464</span> <span class="token punctuation">(</span><span class="token number">164</span>.0MB<span class="token punctuation">)</span>
   MaxNewSize               <span class="token operator">=</span> <span class="token number">2744123392</span> <span class="token punctuation">(</span><span class="token number">2617</span>.0MB<span class="token punctuation">)</span>
   OldSize                  <span class="token operator">=</span> <span class="token number">343932928</span> <span class="token punctuation">(</span><span class="token number">328</span>.0MB<span class="token punctuation">)</span>
   NewRatio                 <span class="token operator">=</span> <span class="token number">2</span>
   SurvivorRatio            <span class="token operator">=</span> <span class="token number">8</span>
   MetaspaceSize            <span class="token operator">=</span> <span class="token number">21807104</span> <span class="token punctuation">(</span><span class="token number">20</span>.796875MB<span class="token punctuation">)</span>
   CompressedClassSpaceSize <span class="token operator">=</span> <span class="token number">1073741824</span> <span class="token punctuation">(</span><span class="token number">1024</span>.0MB<span class="token punctuation">)</span>
   MaxMetaspaceSize         <span class="token operator">=</span> <span class="token number">17592186044415</span> MB
   G1HeapRegionSize         <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span>.0MB<span class="token punctuation">)</span>
Heap Usage:
PS Young Generation
Eden Space:
   capacity <span class="token operator">=</span> <span class="token number">975699968</span> <span class="token punctuation">(</span><span class="token number">930</span>.5MB<span class="token punctuation">)</span>
   used     <span class="token operator">=</span> <span class="token number">41373880</span> <span class="token punctuation">(</span><span class="token number">39</span>.45720672607422MB<span class="token punctuation">)</span>
   <span class="token function">free</span>     <span class="token operator">=</span> <span class="token number">934326088</span> <span class="token punctuation">(</span><span class="token number">891</span>.0427932739258MB<span class="token punctuation">)</span>
   <span class="token number">4.240430599255692</span>% used
From Space:
   capacity <span class="token operator">=</span> <span class="token number">857735168</span> <span class="token punctuation">(</span><span class="token number">818</span>.0MB<span class="token punctuation">)</span>
   used     <span class="token operator">=</span> <span class="token number">1616864</span> <span class="token punctuation">(</span><span class="token number">1</span>.541961669921875MB<span class="token punctuation">)</span>
   <span class="token function">free</span>     <span class="token operator">=</span> <span class="token number">856118304</span> <span class="token punctuation">(</span><span class="token number">816</span>.4580383300781MB<span class="token punctuation">)</span>
   <span class="token number">0.18850387162859109</span>% used
To Space:
   capacity <span class="token operator">=</span> <span class="token number">858783744</span> <span class="token punctuation">(</span><span class="token number">819</span>.0MB<span class="token punctuation">)</span>
   used     <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span>.0MB<span class="token punctuation">)</span>
   <span class="token function">free</span>     <span class="token operator">=</span> <span class="token number">858783744</span> <span class="token punctuation">(</span><span class="token number">819</span>.0MB<span class="token punctuation">)</span>
   <span class="token number">0.0</span>% used
PS Old Generation
   capacity <span class="token operator">=</span> <span class="token number">2798649344</span> <span class="token punctuation">(</span><span class="token number">2669</span>.0MB<span class="token punctuation">)</span>
   used     <span class="token operator">=</span> <span class="token number">40148408</span> <span class="token punctuation">(</span><span class="token number">38</span>.28850555419922MB<span class="token punctuation">)</span>
   <span class="token function">free</span>     <span class="token operator">=</span> <span class="token number">2758500936</span> <span class="token punctuation">(</span><span class="token number">2630</span>.711494445801MB<span class="token punctuation">)</span>
   <span class="token number">1.4345637150318178</span>% used
<span class="token number">31252</span> interned Strings occupying <span class="token number">3290976</span> bytes.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序没有做jvm配置，使用的是默认属性，但是GC过后看起来使用率什么的都很低，暂时看起来也正常，但是top的res还是在7G左右</p><h3 id="查看进程内存映射文件" tabindex="-1"><a class="header-anchor" href="#查看进程内存映射文件" aria-hidden="true">#</a> 查看进程内存映射文件</h3><hr><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>jmap <span class="token parameter variable">-dump:format</span><span class="token operator">=</span>b,file<span class="token operator">=</span>heap.bin pid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这将生成一个名为 heap.bin 的二进制文件，其中包含了 Java 堆的内存快照。</p><p>使用内存分析工具：使用内存分析工具，如 Eclipse Memory Analyzer (MAT) 或 VisualVM 的 Heap Dump Analyzer，打开生成的 heap.bin 文件</p><p>我使用的是JProfiler分析快照文件，好像也还好，</p><h3 id="查看进程的内存映像信息" tabindex="-1"><a class="header-anchor" href="#查看进程的内存映像信息" aria-hidden="true">#</a> 查看进程的内存映像信息</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>pmap <span class="token parameter variable">-x</span> pid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个命令用于查看进程的内存映像信息，能够查看进程在哪些地方用了多少内存。常用 pmap -x pid 来查看。</p><p>有两处的address都在3G以上，可能这就是问题所在...待解决</p><div class="hint-container danger"><p class="hint-container-title">警告</p><p>待使用GDB进一步分析占用大量匿名内存的进程</p><p>通过使用GDB，可以进一步分析占用大量内存的进程，并查看具体内存地址周围的内容。这有助于定位内存占用问题的根本原因，并进一步调试和优化代码。</p><p>请注意，使用GDB进行调试需要一定的调试经验，并且在生产环境中进行调试时需要格外小心。确保了解GDB的使用方法，并对正在调试的进程进行适当的备份和保护。</p></div><h3 id="堆外-其他内存占用" tabindex="-1"><a class="header-anchor" href="#堆外-其他内存占用" aria-hidden="true">#</a> 堆外/其他内存占用</h3><p>这边怀疑是堆外内存占用或者其他类型的内存占用</p><ul><li><p>堆外内存使用：堆外内存是指由Java程序直接分配的、不在Java堆中的内存。这种内存通常用于存储直接字节缓冲区、本地方法栈、JNI（Java Native Interface）调用等。您可以使用Java虚拟机的工具和API来监视和诊断堆外内存的使用情况。例如，可以使用jcmd pid VM.native_memory summary命令来查看Java进程的堆外内存摘要。</p></li><li><p>本地资源占用：Java程序可能会使用一些本地资源，如文件句柄、网络连接、数据库连接等，这些资源可能会占用系统的内存或文件描述符。可以检查程序中是否有没有正确关闭或释放这些本地资源的情况，确保它们被正确地管理和释放。</p></li><li><p>第三方库或组件：您的程序可能使用了一些第三方库或组件，这些库可能使用了堆外内存或本地资源。请查阅这些库的文档，了解它们是否有堆外内存的使用要求或注意事项。</p></li><li><p>操作系统级的内存占用：除了Java进程本身，操作系统也会使用一定的内存。例如，操作系统缓存、共享库等都会占用一部分内存。您可以使用操作系统的工具或命令来监视系统级的内存占用情况。</p></li></ul><p>综上所述，如果怀疑存在堆外内存的占用或其他类型的内存占用，建议使用适当的工具和方法来监视和分析堆外内存、本地资源的使用情况，并进一步检查第三方库或组件的文档，确保程序中没有未释放的资源或异常的内存占用情况。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>NMT 是一项Java虚拟机（JVM）功能，它允许监视和诊断Java进程使用的堆外内存。</p><p>可以根据需要启用 Native Memory Tracking（NMT）来跟踪堆外内存的使用情况</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">NativeMemoryTracking</span><span class="token operator">=</span>summary
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，启用 NMT 可能会增加对系统资源的使用，包括内存和处理器资源。因此，在启用 NMT 时，请确保系统具备足够的资源来支持您的应用程序和监控需求。</p><p>启用 NMT 后，您可以使用以下命令来查看堆外内存的摘要信息：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>jcmd pid VM.native_memory summary
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div><p>这边开启了NMT在观察一段时间....</p><h3 id="暂时改动" tabindex="-1"><a class="header-anchor" href="#暂时改动" aria-hidden="true">#</a> 暂时改动</h3><ul><li>开启了NMT(其中一台服务)</li><li>在分析问题的时候，突然出现了一个大的对象直接进入老年代，优化代码</li></ul><p>这边在分析问题的时候，发现刚完成GC后出现了一个很大的对象出现在了老年代区域，是由于对象太大年轻代无法分配足够的内存空间，所以直接进入了老年代，查看代码是有一处查询数据库，由于有个字段前端传过来为空了，这边之前没做处理，直接查询数据库导致数据超量，完成代码优化，后续持续观察...</p><h2 id="_6-跟进" tabindex="-1"><a class="header-anchor" href="#_6-跟进" aria-hidden="true">#</a> 6. 跟进</h2><p>通过持续观察，目前程序占用内存一只良好，应该没什么问题了，不过在笔者的学习过程中，发现了一个比较好用的线上监控诊断的产品，阿里的Arthas，可以更好的协助定位问题</p><p>非常强大...Σ(●ﾟдﾟ●)</p>`,77);function k(h,g){const a=o("font");return p(),t("div",null,[m,l(a,{color:"red",size:"3"},{default:i(()=>[s(" 紧急‼️：今天线上项目突然间内存占用激增，下面记录一下自己查看分析问题的流程 "),v]),_:1}),b])}const y=e(d,[["render",k],["__file","linux_jstack.html.vue"]]);export{y as default};
