<p style="line-height: 2;"><span style="color: rgb(225, 60, 57); font-size: 16px; font-family: 华文楷体;">紧急‼️：今天线上项目突然间内存占用激增，下面记录一下自己查看分析问题的流程</span></p><p style="line-height: 2;"><span style="color: rgb(225, 60, 57); font-size: 16px; font-family: 华文楷体;">由于服务器突然间报警内存占用过高，只好先查看服务器上是哪个服务占用内存过高，一点一点慢慢来</span></p><p style="line-height: 2;"><span style="color: rgb(66, 144, 247); font-size: 16px; font-family: 华文楷体;">一. 查看内存占用情况定位线程</span></p><p style="line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">使用top命令进行查看，由于要查看内存使用情况所以需要按内存排一下序</span></p><pre><code class="language-shell">#按进程的CPU使用率排序
运行top命令后，键入大写P

#按进程的内存使用率排序
运行top命令后，键入大写M
</code></pre><p style="line-height: 2;"><br></p><p style="line-height: 2;"><img src="/article/linux-jstack01.jpg" alt="" data-href="/article/linux-jstack01.jpg" style=""></p><p style="line-height: 2;"><span style="color: rgb(66, 144, 247); background-color: rgb(255, 255, 255); font-size: 16px; font-family: 华文楷体;">二. 定位线程问题（通过命令查看线程情况）</span></p><pre><code class="language-shell">ps p 10483 -L -o pcpu,pmem,pid,tid,time,tname,cmd</code></pre><p style="line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">从这个可以看到线程情况当时情况紧急没有截图，所以我下面的图是同一个服务写文档时运行的</span></p><p><img src="/article/linux-jstack02.jpg" alt="" data-href="/article/linux-jstack02.jpg" style=""/></p><p style="line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">具体可以执行下面操作看有多少个线程</span></p><pre><code class="language-shell"> ps p 24013 -L -o pcpu,pmem,pid,tid,time,tname,cmd |wc -l
 
 100</code></pre><p style="line-height: 2;"><span style="color: rgb(66, 144, 247); font-size: 16px; font-family: 华文楷体;">三. 查看内存使用堆栈</span></p><p style="line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">在这里我挑选了TID=24014的线程进行分析，首先需要将24014这个id转换为16进制。需输入如下命令</span></p><pre><code class="language-shell"> printf "%x\n" 24014
 
 5dce</code></pre><p style="line-height: 2;"><span style="color: rgb(66, 144, 247); font-size: 16px; font-family: 华文楷体;">四. </span><span style="color: rgb(66, 144, 247); background-color: rgb(255, 255, 255); font-size: 16px; font-family: 华文楷体;">将PID为</span><span style="color: rgb(225, 60, 57); font-family: 华文楷体;">24013</span><span style="color: rgb(66, 144, 247); background-color: rgb(255, 255, 255); font-size: 16px; font-family: 华文楷体;">的堆栈信息打印到jstack.log中</span></p><pre><code class="language-shell">#输出目录自定
jstack -l 24013 &gt; /usr/local/temp/jstack.log</code></pre><p style="text-indent: 2em; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">查看具体信息后，发现程序中并没有自己写的代码有死锁或者是等待的东西，那就应该是默认配置相关了，其中有两个比较多</span><span style="color: rgb(17, 24, 39); font-size: 14px; font-family: 华文楷体;">http-nio-xxxx-exec-xx和lettuce-eventExecutorLoop-1-x</span></p><p style="text-indent: 2em; text-align: start; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;"><code>http-nio-4001-exec-30</code></span><span style="font-size: 14px; font-family: 华文楷体;">是Tomcat的工作线程名称。在Tomcat中，每个工作线程都被分配一个独特的名称，以便在调试和性能分析时能够轻松地跟踪线程的执行情况。</span></p><p style="text-indent: 2em; text-align: start; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;"><code>http-nio-4001-exec-30</code></span><span style="font-size: 14px; font-family: 华文楷体;">中的</span><span style="font-size: 14px; font-family: 华文楷体;"><code>4001</code></span><span style="font-size: 14px; font-family: 华文楷体;">表示Tomcat监听的端口号，</span><span style="font-size: 14px; font-family: 华文楷体;"><code>exec</code></span><span style="font-size: 14px; font-family: 华文楷体;">表示该线程是Tomcat的工作线程，</span><span style="font-size: 14px; font-family: 华文楷体;"><code>30</code></span><span style="font-size: 14px; font-family: 华文楷体;">表示该线程的标识符。</span></p><p style="text-indent: 2em; text-align: start; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">如果您在jstack输出中看到大量类似</span><span style="font-size: 14px; font-family: 华文楷体;"><code>http-nio-xxxx-exec-xx</code></span><span style="font-size: 14px; font-family: 华文楷体;">的线程，这可能意味着应用程序正在处理大量的并发请求。每个请求都需要一个工作线程来处理，并且这些工作线程都需要占用一定的内存和CPU资源。如果应用程序的并发请求量过高，可能会导致系统资源瓶颈，进而影响应用程序的性能和稳定性。</span></p><p style="text-indent: 2em; text-align: start; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">如果应用程序需要处理大量的并发请求，建议您根据实际情况来配置Tomcat的线程池参数，以确保应用程序的性能和稳定性。</span></p><p style="text-align: start; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">这边使用的是springboot2.3X以上的版本，配置内置的tomcat参数与之前的有些不一样</span></p><p style="text-align: start; line-height: 2;"><span style="color: rgb(225, 60, 57); font-size: 14px; font-family: 华文楷体;">在application.yml中进行配置，例如：</span></p><pre><code class="language-yaml">server:
  tomcat:
    threads:
      max: 500 //线程池的最大线程数。默认值200
      min-spare: 50 //线程池中最少的空闲线程数。默认值10
      idle-timeout: 60000 //指定在空闲线程被回收之前等待的最大毫秒数。默认值60s
    accept-count: 200 //指定在队列中等待处理的最大连接数。默认值100
    max-connections: 20000 //最大连接数。默认值10000</code></pre><p style="text-indent: 2em; text-align: start; line-height: 2;"><span style="color: var(--tw-prose-code); font-size: 14px; font-family: 华文楷体;"><code>lettuce-eventExecutorLoop-1-x</code></span><span style="font-size: 14px; font-family: 华文楷体;">是Lettuce Redis客户端的线程名称，其中的</span><span style="color: var(--tw-prose-code); font-size: 14px; font-family: 华文楷体;"><code>x</code></span><span style="font-size: 14px; font-family: 华文楷体;">表示线程标识符。Lettuce使用Netty作为底层网络通信框架，每个Netty EventLoop都会创建一个Lettuce线程，并分配一个独特的线程名称，以便在调试和性能分析时能够轻松地跟踪线程的执行情况。</span></p><p style="text-indent: 2em; text-align: start; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">在Lettuce Redis客户端中，每个Redis命令都是异步执行的，即客户端会在发送请求之后立即返回，并通过回调函数或者Future等方式获取结果。Lettuce使用EventLoop线程来处理I/O事件、连接管理和Redis命令执行等任务，以提高客户端的性能和吞吐量。</span></p><p style="text-indent: 2em; text-align: start; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">如果在jstack输出中看到大量类似</span><span style="color: var(--tw-prose-code); font-size: 14px; font-family: 华文楷体;"><code>lettuce-eventExecutorLoop-1-x</code></span><span style="font-size: 14px; font-family: 华文楷体;">的线程，这可能意味着应用程序正在与Redis进行大量的交互，并且使用了Lettuce客户端。每个Lettuce线程都需要占用一定的内存和CPU资源，如果线程数量过多，可能会导致系统资源瓶颈，进而影响应用程序的性能和稳定性。</span></p><p style="text-indent: 2em; text-align: start; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">如果应用程序需要与Redis进行大量的交互，建议根据实际情况来配置Lettuce的线程池参数，以确保应用程序的性能和稳定性。</span></p><p style="text-align: start; line-height: 2;"><span style="color: rgb(225, 60, 57); font-size: 14px; font-family: 华文楷体;">在application.yml中进行配置，例如：</span></p><pre><code class="language-yaml">spring:
  redis:
    host: localhost  # Redis服务器地址，默认为localhost
    port: 6379       # Redis服务器端口，默认为6379
    password:        # Redis密码，默认为空
    database: 0      # Redis数据库索引（0-15），默认为0
    timeout: 1000    # 连接超时时间（毫秒），默认为1000
    jedis:
      pool:
        max-active: 8       # 连接池最大连接数，默认为8
        max-idle: 8         # 连接池最大空闲连接数，默认为8
        min-idle: 0         # 连接池最小空闲连接数，默认为0
        max-wait: -1        # 连接池最大等待时间（毫秒），默认为-1（表示无限等待）</code></pre><p style="line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">修改了配置文件在观察吧，我在导出jstack的时候运维已经重启了服务，我不清楚这个是不是当时有问题的原因，但是从后来分析的情况来看，确实存在一定的问题...</span></p><p style="line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">后续会跟进...</span></p><p style="text-indent: 2em; line-height: 2;"><span style="color: rgb(225, 60, 57); font-size: 14px; font-family: 华文楷体;">后续跟进</span><span style="font-size: 14px; font-family: 华文楷体;">: &nbsp;我在执行ps p 10483 -L -o pcpu,pmem,pid,tid,time,tname,cmd命令式发现有个线程时间2分钟还没结束，去jstack查看了一下，是</span><span style="color: rgb(17, 24, 39); font-size: 14px; font-family: 华文楷体;">System Clock</span></p><p style="text-indent: 2em; line-height: 2;"><span style="color: rgb(55, 65, 81); font-size: 14px; font-family: 华文楷体;">这个线程是一个系统线程，是JVM中专门负责管理系统时钟的线程，它会定期更新JVM中的系统时间，以及JVM中的一些相关参数，如</span><span style="font-size: 14px; font-family: 华文楷体;">java.util.Date</span><span style="color: rgb(55, 65, 81); font-size: 14px; font-family: 华文楷体;">和</span><span style="font-size: 14px; font-family: 华文楷体;">System.currentTimeMillis()</span><span style="color: rgb(55, 65, 81); font-size: 14px; font-family: 华文楷体;">等方法的返回值。该线程的状态为</span><span style="font-size: 14px; font-family: 华文楷体;">TIMED_WAITING</span><span style="color: rgb(55, 65, 81); font-size: 14px; font-family: 华文楷体;">，意味着它是在等待时钟时间的到来，并在等待的过程中处于定时等待状态。这种状态在Java应用程序中非常常见，并且通常是正常的行为，不应该引起太多的注意。但是2分钟还没执行完就多少有点时间长，查看了一下代码，发现使用了</span><span style="color: rgb(17, 24, 39); background-color: rgb(247, 247, 248); font-size: 14px; font-family: 华文楷体;">SimpleDateFormat</span></p><p style="text-indent: 2em; line-height: 2;"><span style="font-size: 14px; font-family: 华文楷体;">SimpleDateFormat</span><span style="color: rgb(55, 65, 81); font-size: 14px; font-family: 华文楷体;"> 并不是线程安全的，如果多个线程同时使用同一个 </span><span style="font-size: 14px; font-family: 华文楷体;">SimpleDateFormat</span><span style="color: rgb(55, 65, 81); font-size: 14px; font-family: 华文楷体;"> 对象进行日期格式化，就有可能出现线程安全问题，在程序中我也看到不知怎么的这一块是写在属性当中，所有方法共用，这一块应该存在问题，优化到方法内部或者如果确定要只定义一个的话：</span></p><p style="text-indent: 2em; line-height: 2;"><span style="color: rgb(55, 65, 81); font-size: 14px; font-family: 华文楷体;">如果多个线程同时读取同一个SimpleDateFormat对象的话，会出现线程安全问题，因为SimpleDateFormat不是线程安全的。所以如果多个线程同时读取时可能会出现线程阻塞的情况。为了避免这种情况，可以考虑使用ThreadLocal来保证每个线程有自己的SimpleDateFormat对象。这样就可以避免多个线程之间的竞争，提高程序的性能和稳定性。</span></p>