import{_ as e,X as a,Y as i,a2 as r}from"./framework-f01f539c.js";const t="/assets/images/rabbit-mq01.jpg",h="/assets/images/rabbit-mq02.jpg",n="/assets/images/rabbit-mq03.jpg",d="/assets/images/rabbit-mq04.jpg",l={},s=r('<h1 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq" aria-hidden="true">#</a> RabbitMQ</h1><h2 id="为什么使用mq" tabindex="-1"><a class="header-anchor" href="#为什么使用mq" aria-hidden="true">#</a> 为什么使用MQ</h2><h3 id="流量削峰-解决高并发问题" tabindex="-1"><a class="header-anchor" href="#流量削峰-解决高并发问题" aria-hidden="true">#</a> 流量削峰：解决高并发问题</h3><hr><p>例如秒杀活动，可能会在短时间内产生大量请求同时打到服务端，如果后端对每个请求都进行数据库读写操作，定会造成服务器压力过大，产生服务异常甚至不可用。我们可以通过使用MQ实现流量缓冲，将所有请求先放入消息队列中，服务端每次处理业务先从消息队列获取，从而实现流量削峰，解决高并发问题。</p><h3 id="应用解耦-提升系统可用性" tabindex="-1"><a class="header-anchor" href="#应用解耦-提升系统可用性" aria-hidden="true">#</a> 应用解耦：提升系统可用性</h3><hr><p>例如电商应用中有订单系统、库存系统、物流系统、支付系统，当用户创建订单后，先后调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单失败。引入消息队列后，系统间耦合调用的问题会减少，任何一个子系统出现故障都不会影响用户下单，子系统故障恢复后，会继续处理消息，提升系统可用性。</p><h3 id="异步处理-提升响应速度" tabindex="-1"><a class="header-anchor" href="#异步处理-提升响应速度" aria-hidden="true">#</a> 异步处理：提升响应速度</h3><hr><p>当用户在客户端提交了一个同步请求，后端处理需要耗时很久才能响应，这对用户体验来说无疑是致命的。如果说用户并不关心请求是否处理完成，对于一些耗时的非事务性的业务处理，可以使用消息队列异步请求的方式，将请求信息放入消息队列，直接返回客户端响应，后端监听队列自行处理，提升响应速度。</p><figure><img src="'+t+'" alt="图示" tabindex="0" loading="lazy"><figcaption>图示</figcaption></figure><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2><figure><img src="'+h+'" alt="工作原理" tabindex="0" loading="lazy"><figcaption>工作原理</figcaption></figure><ul><li>生产者（Producer）通过信道（Channel）把消息发送给交换机（Exchange)，当创建交换机时需要指定类型（四种类型：直接Direct，扇出Fanout ，主题Topic ，消息头Headers ）；</li><li>交换机（Exchange）接收消息并且负责对消息进行路由，交换机根据消息的属性来把消息分发到不同的队列（Queue）上；</li><li>消息（Message）会一直留在队列里直到被消费者（Consumer）消费。</li></ul><h2 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念" aria-hidden="true">#</a> 核心概念</h2><ul><li>生产者（Producer）：发送消息的应用。</li><li>消费者（Consumer）：接收消息的应用。</li><li>队列（Queue）：存储消息的缓存。</li><li>消息（Message）：由生产者通过RabbitMQ发送给消费者的信息。</li><li>连接（Connection）：连接RabbitMQ和应用服务器的TCP连接。</li><li>信道（Channel）：连接里的一个虚拟通道，通过消息队列发送或者接收消息时，都是通过信道进行的。如果每一次访问RabbitMQ都建立一个Connection，在消息量很大时，建立TCP Connection将消耗很大，效率也较低，Channel是Connection内部建的逻辑链接，每个channel之间是完全隔离的，极大的减少了创建TCP Connection的消耗</li><li>交换机（Exchange）：交换机负责从生产者那里接收消息，并根据交换类型分发到对应的消息队列里。根据分发规则，匹配查询表中的routing key，分发消息到Queue中去,常用的类型有: direct (point-to-point), topic(publish-subscribe) and fanout(multicast)</li><li>绑定（Binding）：绑定是队列和交换机的一个关联连接。</li><li>路由键（Routing Key）：路由键是供交换机查看并根据键来决定如何分发消息到队列的一个键，路由键可以说是消息的目的地址。</li><li>代理（Broker）：接收和分发消息的应用，RabbitMQ Server就是Message Broker。</li><li>虚拟主机（Virtual host）：出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange/queue 等。</li></ul><h2 id="高级应用" tabindex="-1"><a class="header-anchor" href="#高级应用" aria-hidden="true">#</a> 高级应用</h2><h3 id="死信队列" tabindex="-1"><a class="header-anchor" href="#死信队列" aria-hidden="true">#</a> 死信队列</h3><hr><p>死信队列（DLX，Dead-Letter-Exchange），利用DLX，当消息在一个队列中变成无法被消费的消息（dead message）之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX。</p><p>消息变成死信的几种情况：</p><ol><li>消息被拒绝（channel.basicReject/channel.basicNack）并且request=false；</li><li>消息在队列的存活时间超过设置的生存时间（TTL）时间；</li><li>队列达到最大长度（队列满了，无法再添加数据到队列中）。</li></ol><p>DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。</p><p>死信队列的设置：</p><ol><li>首先，需要设置死信队列的Exchange和queue，然后进行绑定；</li><li>然后，我们进行正常声明交换机、队列、绑定，只不过我们需要在队列机上一个参数即可：arguments.put(“x-dead-letter-exchange”,”dlx.exchange”)；这样消息在过期、被拒绝、队列在达到最大长度时，消息就可以直接路由到死信队列。</li></ol><figure><img src="'+n+'" alt="死信队列" tabindex="0" loading="lazy"><figcaption>死信队列</figcaption></figure><h3 id="延迟队列" tabindex="-1"><a class="header-anchor" href="#延迟队列" aria-hidden="true">#</a> 延迟队列</h3><hr><ol><li><p>基于rabbitmq_delayed_message_exchange插件，实现延迟队列效果。它是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在mnesia（一个分布式数据系统）表中，当达到投递时间时，才投递到目标队列中。使用延迟队列，可以有效解决定时任务带来的系统压力以及业务处理时效性等问题。</p></li><li><p>RabbitMQ本身没有延迟队列，需要靠TTL和DLX模拟出延迟的效果</p></li></ol><p>TTL（Time To Live）</p><p>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter</p><p>RabbitMQ针对队列中的消息过期时间有两种方法可以设置。</p><p>A: 通过队列属性设置，队列中所有消息都有相同的过期时间。</p><p>B: 对消息进行单独设置，每条消息TTL可以不同。</p><p>如果同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。消息在队列的生存时间一旦超过设置的TTL值，就成为dead letter</p><p>DLX (Dead-Letter-Exchange)</p><p>RabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由。</p><p>x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange</p><p>x-dead-letter-routing-key：指定routing-key发送</p><p>利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。</p><h3 id="队列幂等性" tabindex="-1"><a class="header-anchor" href="#队列幂等性" aria-hidden="true">#</a> 队列幂等性</h3><hr><p>对于一个资源，不管你请求一次还是请求多次，对该资源本身造成的影响应该是相同的，不能因为重复相同的请求而对该资源重复造成影响。注意关注的是请求操作对资源本身造成的影响，而不是请求资源返回的结果。 MQ消费者的幂等性一般使用全局ID或者写个唯一标识（比如流水号/时间戳/UUID/订单号）来判断该消息是否已消费过，也可以利用redis执行setnx命令，天然具有幂等性，从而实现不重复消费（推荐使用redis）。</p><h3 id="优先级队列" tabindex="-1"><a class="header-anchor" href="#优先级队列" aria-hidden="true">#</a> 优先级队列</h3><hr><p>优先级队列，也就是具有高优先级的队列，优先级高的消息具备优先被消费的特权。通过队列的 x-max-priority 参数设置队列的最大优先级，之后在发送消息时通过 priority 属性再设置当前消息的优先级。优先级应在 0 和 255 之间，推荐1 ~ 10。</p><ul><li>优先级默认最低为0，最高为队列设置的最大优先级；</li><li>对于单条消息来谈优先级是没有什么意义的。假如消费者的消费速度大于生产者的速度且Broker中没有消息堆积的情况下，对发送的消息设置优先级就没有什么意义，因为生产者刚发完一个消息就被消费者消费了，相当于Broker中至多只有一条消息。</li></ul><h3 id="惰性队列" tabindex="-1"><a class="header-anchor" href="#惰性队列" aria-hidden="true">#</a> 惰性队列</h3><hr><p>惰性队列会尽可能地将消息存入磁盘中，而在消费者消费消息时才会被加载到内存中，它支持更多的消息存储。 队列具备两种模式：default 和 lazy。默认的为 default 模式，在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。</p><h2 id="工作模式" tabindex="-1"><a class="header-anchor" href="#工作模式" aria-hidden="true">#</a> 工作模式</h2><h3 id="simple-简单模式" tabindex="-1"><a class="header-anchor" href="#simple-简单模式" aria-hidden="true">#</a> Simple（简单模式）</h3><p>一个消费者消费一个生产者生产的信息</p><h3 id="work-queues-工作模式" tabindex="-1"><a class="header-anchor" href="#work-queues-工作模式" aria-hidden="true">#</a> Work queues（工作模式）</h3><p>一个生产者生产信息，多个消费者进行消费，但是一条消息只能消费一次</p><h3 id="publish-subscribe-发布订阅模式" tabindex="-1"><a class="header-anchor" href="#publish-subscribe-发布订阅模式" aria-hidden="true">#</a> Publish/Subscribe（发布订阅模式）</h3><p>生产者首先投递消息到交换机，订阅了这个交换机的队列就会收到生产者投递的消息</p><h3 id="routing-路由模式" tabindex="-1"><a class="header-anchor" href="#routing-路由模式" aria-hidden="true">#</a> Routing（路由模式）</h3><p>生产者生产消息投递到direct交换机中，扇出交换机会根据消息携带的routing Key匹配相应的队列</p><h3 id="topics-主题模式" tabindex="-1"><a class="header-anchor" href="#topics-主题模式" aria-hidden="true">#</a> Topics（主题模式）</h3><p>生产者生产消息投递到topic交换机中，上面是完全匹配路由键，而主题模式是模糊匹配，只要有合适规则的路由就会投递给消费者</p><figure><img src="'+d+'" alt="路由/主题" tabindex="0" loading="lazy"><figcaption>路由/主题</figcaption></figure><h2 id="交换机类型" tabindex="-1"><a class="header-anchor" href="#交换机类型" aria-hidden="true">#</a> 交换机类型</h2><ol><li>direct Exchange(直接交换机)</li></ol><p>匹配路由键，只有完全匹配消息才会被转发</p><ol start="2"><li>Fanout Excange（扇出交换机）</li></ol><p>将消息发送至所有的队列</p><ol start="3"><li>Topic Exchange(主题交换机)</li></ol><p>将路由按模式匹配，此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.” 只会匹配到“abc.def”。</p><ol start="4"><li>Header Exchange</li></ol><p>在绑定Exchange和Queue的时候指定一组键值对，header为键，根据请求消息中携带的header进行路由</p>',72),c=[s];function o(p,u){return a(),i("div",null,c)}const g=e(l,[["render",o],["__file","rabbit-mq.html.vue"]]);export{g as default};
