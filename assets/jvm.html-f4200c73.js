const e=JSON.parse('{"key":"v-0b4a8e02","path":"/knowledge/jvm.html","title":"jvm","lang":"zh-CN","frontmatter":{"icon":"cycle","date":"2021-01-10T00:00:00.000Z","category":["java","后端"],"tag":["java","后端","jvm"],"star":true,"description":"jvm 1. JVM 内存模型 线程独占： 栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8大基础类型加上一个应用类型，所以还是一个指向地址的指针。 本地方法栈：主要为 Native 方法服务 程序计数器：记录当前线程执行的行号，执行Native 方法时 , 程序计数器为空 . 线程共享： 堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配。当堆没有可用空间时 , 会抛出 OOM 异常 . 根据对象的存活周期不同 ,JVM 把对象进行分代管理 , 由垃圾回收器进行垃圾的回收管理 方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据。1.7的永久代和 1.8 的元空间都是方法区的一种实现","head":[["meta",{"property":"og:url","content":"https://gitee.com/jing-xingchun/knowledge/jvm.html"}],["meta",{"property":"og:site_name","content":"Jingxc"}],["meta",{"property":"og:title","content":"jvm"}],["meta",{"property":"og:description","content":"jvm 1. JVM 内存模型 线程独占： 栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8大基础类型加上一个应用类型，所以还是一个指向地址的指针。 本地方法栈：主要为 Native 方法服务 程序计数器：记录当前线程执行的行号，执行Native 方法时 , 程序计数器为空 . 线程共享： 堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配。当堆没有可用空间时 , 会抛出 OOM 异常 . 根据对象的存活周期不同 ,JVM 把对象进行分代管理 , 由垃圾回收器进行垃圾的回收管理 方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据。1.7的永久代和 1.8 的元空间都是方法区的一种实现"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-22T10:48:01.000Z"}],["meta",{"property":"article:author","content":"Jingxc"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"后端"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:published_time","content":"2021-01-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-22T10:48:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"jvm\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-01-10T00:00:00.000Z\\",\\"dateModified\\":\\"2023-05-22T10:48:01.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jingxc\\",\\"url\\":\\"/\\"}]}"]]},"headers":[{"level":2,"title":"1. JVM 内存模型","slug":"_1-jvm-内存模型","link":"#_1-jvm-内存模型","children":[]},{"level":2,"title":"2. JVM 内存可见性","slug":"_2-jvm-内存可见性","link":"#_2-jvm-内存可见性","children":[]},{"level":2,"title":"3. 类的加载","slug":"_3-类的加载","link":"#_3-类的加载","children":[]},{"level":2,"title":"4. GC判断","slug":"_4-gc判断","link":"#_4-gc判断","children":[{"level":3,"title":"4.1 引用计数法","slug":"_4-1-引用计数法","link":"#_4-1-引用计数法","children":[]},{"level":3,"title":"4.2 根搜索路径可达性算法","slug":"_4-2-根搜索路径可达性算法","link":"#_4-2-根搜索路径可达性算法","children":[]}]},{"level":2,"title":"5. 垃圾回收算法","slug":"_5-垃圾回收算法","link":"#_5-垃圾回收算法","children":[{"level":3,"title":"5.1 标记-清除算法","slug":"_5-1-标记-清除算法","link":"#_5-1-标记-清除算法","children":[]},{"level":3,"title":"5.2 复制算法","slug":"_5-2-复制算法","link":"#_5-2-复制算法","children":[]},{"level":3,"title":"5.3 标记-整理算法","slug":"_5-3-标记-整理算法","link":"#_5-3-标记-整理算法","children":[]}]},{"level":2,"title":"6. 分代回收","slug":"_6-分代回收","link":"#_6-分代回收","children":[]},{"level":2,"title":"7. 垃圾回收器的分类","slug":"_7-垃圾回收器的分类","link":"#_7-垃圾回收器的分类","children":[{"level":3,"title":"7.1 CMS（Concurrent Mark Sweep）","slug":"_7-1-cms-concurrent-mark-sweep","link":"#_7-1-cms-concurrent-mark-sweep","children":[]},{"level":3,"title":"7.2 G1 垃圾回收器","slug":"_7-2-g1-垃圾回收器","link":"#_7-2-g1-垃圾回收器","children":[]}]},{"level":2,"title":"8. JVM Full GC的原因及应对策略","slug":"_8-jvm-full-gc的原因及应对策略","link":"#_8-jvm-full-gc的原因及应对策略","children":[{"level":3,"title":"8.1 System.gc()方法的调用","slug":"_8-1-system-gc-方法的调用","link":"#_8-1-system-gc-方法的调用","children":[]},{"level":3,"title":"8.2 老年代空间不足","slug":"_8-2-老年代空间不足","link":"#_8-2-老年代空间不足","children":[]},{"level":3,"title":"8.3 永生区空间不足","slug":"_8-3-永生区空间不足","link":"#_8-3-永生区空间不足","children":[]},{"level":3,"title":"8.4 CMS GC时出现promotion failed和concurrent mode failure","slug":"_8-4-cms-gc时出现promotion-failed和concurrent-mode-failure","link":"#_8-4-cms-gc时出现promotion-failed和concurrent-mode-failure","children":[]},{"level":3,"title":"8.5 统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间","slug":"_8-5-统计得到的minor-gc晋升到旧生代的平均大小大于老年代的剩余空间","link":"#_8-5-统计得到的minor-gc晋升到旧生代的平均大小大于老年代的剩余空间","children":[]},{"level":3,"title":"8.6 除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。","slug":"_8-6-除了以上4种状况外-对于使用rmi来进行rpc或管理的sun-jdk应用而言-默认情况下会一小时执行一次full-gc。","link":"#_8-6-除了以上4种状况外-对于使用rmi来进行rpc或管理的sun-jdk应用而言-默认情况下会一小时执行一次full-gc。","children":[]},{"level":3,"title":"8.7 堆中分配很大的对象","slug":"_8-7-堆中分配很大的对象","link":"#_8-7-堆中分配很大的对象","children":[]}]},{"level":2,"title":"9. JVM调优","slug":"_9-jvm调优","link":"#_9-jvm调优","children":[{"level":3,"title":"9.1 堆设置","slug":"_9-1-堆设置","link":"#_9-1-堆设置","children":[]},{"level":3,"title":"9.2 年轻代","slug":"_9-2-年轻代","link":"#_9-2-年轻代","children":[]},{"level":3,"title":"9.3 方法区","slug":"_9-3-方法区","link":"#_9-3-方法区","children":[]},{"level":3,"title":"9.4 年轻代中Eden区与Survivor区的比值","slug":"_9-4-年轻代中eden区与survivor区的比值","link":"#_9-4-年轻代中eden区与survivor区的比值","children":[]},{"level":3,"title":"9.5新生代存活区切换的次数","slug":"_9-5新生代存活区切换的次数","link":"#_9-5新生代存活区切换的次数","children":[]},{"level":3,"title":"9.6 堆dump","slug":"_9-6-堆dump","link":"#_9-6-堆dump","children":[]},{"level":3,"title":"9.7 垃圾回收器","slug":"_9-7-垃圾回收器","link":"#_9-7-垃圾回收器","children":[]}]}],"git":{"createdTime":1683473112000,"updatedTime":1684752481000,"contributors":[{"name":"Jingxc","email":"2584982513@qq.com","commits":1},{"name":"jingxc","email":"2584982513@qq.com","commits":1}]},"readingTime":{"minutes":18.36,"words":5508},"filePathRelative":"knowledge/jvm.md","localizedDate":"2021年1月10日","excerpt":"<h1> jvm</h1>\\n<h2> 1. JVM 内存模型</h2>\\n<p>线程独占：</p>\\n<ul>\\n<li>栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8大基础类型加上一个应用类型，所以还是一个指向地址的指针。</li>\\n<li>本地方法栈：主要为 Native 方法服务</li>\\n<li>程序计数器：记录当前线程执行的行号，执行Native 方法时 , 程序计数器为空 .</li>\\n</ul>\\n<p>线程共享：</p>\\n<ul>\\n<li>堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配。当堆没有可用空间时 , 会抛出 OOM 异常 . 根据对象的存活周期不同 ,JVM 把对象进行分代管理 , 由垃圾回收器进行垃圾的回收管理</li>\\n<li>方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据。1.7的永久代和 1.8 的元空间都是方法区的一种实现</li>\\n</ul>","autoDesc":true}');export{e as data};
